<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenKalman: OpenKalman::Eigen3::SelfAdjointMatrix&lt; NestedMatrix, storage_triangle &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenKalman
   </div>
   <div id="projectbrief">An open-source, heading-only library for Kalman filters and other recursive filters</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenKalman::Eigen3::SelfAdjointMatrix&lt; NestedMatrix, storage_triangle &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A self-adjoint matrix.  
 <a href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><h3>template&lt;typename NestedMatrix, TriangleType storage_triangle&gt;<br />
struct OpenKalman::Eigen3::SelfAdjointMatrix&lt; NestedMatrix, storage_triangle &gt;</h3>

<p>The matrix is guaranteed to be self-adjoint. It is <a class="el" href="namespace_open_kalman.html#a8b841cd9db4d9a19b89529d1aed58b03" title="Specifies that a type is a self-contained matrix or expression.">self_contained</a> iff NestedMatrix is <a class="el" href="namespace_open_kalman.html#a8b841cd9db4d9a19b89529d1aed58b03" title="Specifies that a type is a self-contained matrix or expression.">self_contained</a>. It may <em>also</em> be a diagonal matrix if storage_triangle is <a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2aa0e17e2709a0404ae3d7de03b8ea9093" title="The diagonal elements of the matrix.">TriangleType::diagonal</a>. Implicit conversions are available from any <a class="el" href="namespace_open_kalman.html#a63114cb8862cdcff4b5f0660b16a5bec">self_adjoint_matrix</a> of compatible size. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NestedMatrix</td><td>A nested <a class="el" href="namespace_open_kalman.html#a4fc1aa6874bf00181847d0bc6228514b">square_matrix</a> expression, on which the self-adjoint matrix is based. </td></tr>
    <tr><td class="paramname">storage_triangle</td><td>The TriangleType (<a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2a81e073b428b50247daba38531dcf412a">lower</a>, <a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2a0122b4c2c01ee1c698ecc309d2b8eb5a">upper</a>, or <a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2aa0e17e2709a0404ae3d7de03b8ea9093">diagonal</a>) in which the data is stored. <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> elements outside this triangle/diagonal are ignored. If the matrix is lower or upper triangular, elements are mapped from this selected triangle to the elements in the other triangle to ensure that the matrix is self-adjoint. If the matrix is diagonal, 0 is automatically mapped to each matrix element outside the diagonal. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_self_adjoint_matrix_8hpp_source.html#l00027">27</a> of file <a class="el" href="_self_adjoint_matrix_8hpp_source.html">SelfAdjointMatrix.hpp</a>.</p>
</div>
<p>Inherits OpenKalman::internal::MatrixBase&lt; Derived, NestedMatrix &gt;.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e585009e9dce68799151c931ddbd865"><td class="memTemplParams" colspan="2"><a id="a8e585009e9dce68799151c931ddbd865"></a>
template&lt;typename T  = Base, std::enable_if_t&lt; std::is_default_constructible_v&lt; T &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8e585009e9dce68799151c931ddbd865"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#a8e585009e9dce68799151c931ddbd865">SelfAdjointMatrix</a> ()</td></tr>
<tr class="memdesc:a8e585009e9dce68799151c931ddbd865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:a8e585009e9dce68799151c931ddbd865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77870148ff17728d70e10a38dc2bf3fc"><td class="memItemLeft" align="right" valign="top"><a id="a77870148ff17728d70e10a38dc2bf3fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#a77870148ff17728d70e10a38dc2bf3fc">SelfAdjointMatrix</a> (const <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">SelfAdjointMatrix</a> &amp;other)</td></tr>
<tr class="memdesc:a77870148ff17728d70e10a38dc2bf3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br /></td></tr>
<tr class="separator:a77870148ff17728d70e10a38dc2bf3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedde6fd58b0a00b7b47286ec52e5aec"><td class="memItemLeft" align="right" valign="top"><a id="afedde6fd58b0a00b7b47286ec52e5aec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#afedde6fd58b0a00b7b47286ec52e5aec">SelfAdjointMatrix</a> (<a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">SelfAdjointMatrix</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:afedde6fd58b0a00b7b47286ec52e5aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. <br /></td></tr>
<tr class="separator:afedde6fd58b0a00b7b47286ec52e5aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1640d33f911c426da6c92217dcbdd84a"><td class="memTemplParams" colspan="2"><a id="a1640d33f911c426da6c92217dcbdd84a"></a>
template&lt;typename Arg , std::enable_if_t&lt; eigen_self_adjoint_expr&lt; Arg &gt; and(not std::is_base_of_v&lt; SelfAdjointMatrix, std::decay_t&lt; Arg &gt;&gt;) and internal::same_storage_triangle_as&lt; Arg, SelfAdjointMatrix &gt; and(not eigen_diagonal_expr&lt; NestedMatrix &gt; or diagonal_matrix&lt; nested_matrix_t&lt; Arg &gt;&gt;) and std::is_constructible_v&lt; Base, decltype(nested_matrix(std::declval&lt; Arg &gt;()))&gt; , int &gt; </td></tr>
<tr class="memitem:a1640d33f911c426da6c92217dcbdd84a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#a1640d33f911c426da6c92217dcbdd84a">SelfAdjointMatrix</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a1640d33f911c426da6c92217dcbdd84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a compatible self-adjoint matrix object of the same storage type. <br /></td></tr>
<tr class="separator:a1640d33f911c426da6c92217dcbdd84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1640d33f911c426da6c92217dcbdd84a"><td class="memTemplParams" colspan="2"><a id="a1640d33f911c426da6c92217dcbdd84a"></a>
template&lt;typename Arg , std::enable_if_t&lt; eigen_self_adjoint_expr&lt; Arg &gt; and(not std::is_base_of_v&lt; SelfAdjointMatrix, std::decay_t&lt; Arg &gt;&gt;) and internal::same_storage_triangle_as&lt; Arg, SelfAdjointMatrix &gt; and eigen_diagonal_expr&lt; NestedMatrix &gt; and(not diagonal_matrix&lt; nested_matrix_t&lt; Arg &gt;&gt;) and std::is_constructible_v&lt; Base, decltype(to_diagonal(diagonal_of(nested_matrix(std::declval&lt; Arg &gt;()))))&gt; , int &gt; </td></tr>
<tr class="memitem:a1640d33f911c426da6c92217dcbdd84a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#a1640d33f911c426da6c92217dcbdd84a">SelfAdjointMatrix</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a1640d33f911c426da6c92217dcbdd84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a compatible self-adjoint matrix object if NestedMatrix is <a class="el" href="namespace_open_kalman_1_1_eigen3.html#a8d408b48a797fea59c2b1e5ecd532920">eigen_diagonal_expr</a>. <br /></td></tr>
<tr class="separator:a1640d33f911c426da6c92217dcbdd84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1640d33f911c426da6c92217dcbdd84a"><td class="memTemplParams" colspan="2"><a id="a1640d33f911c426da6c92217dcbdd84a"></a>
template&lt;typename Arg , std::enable_if_t&lt; eigen_self_adjoint_expr&lt; Arg &gt; and(not internal::same_storage_triangle_as&lt; Arg, SelfAdjointMatrix &gt;) and std::is_constructible_v&lt; Base, decltype(adjoint(nested_matrix(std::declval&lt; Arg &gt;())))&gt; , int &gt; </td></tr>
<tr class="memitem:a1640d33f911c426da6c92217dcbdd84a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#a1640d33f911c426da6c92217dcbdd84a">SelfAdjointMatrix</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a1640d33f911c426da6c92217dcbdd84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a compatible self-adjoint matrix object of the opposite storage type. <br /></td></tr>
<tr class="separator:a1640d33f911c426da6c92217dcbdd84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156f5afbfa5d721516e6db3948674d91"><td class="memTemplParams" colspan="2"><a id="a156f5afbfa5d721516e6db3948674d91"></a>
template&lt;typename Arg , std::enable_if_t&lt; eigen_diagonal_expr&lt; Arg &gt; and std::is_constructible_v&lt; Base, Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a156f5afbfa5d721516e6db3948674d91"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#a156f5afbfa5d721516e6db3948674d91">SelfAdjointMatrix</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a156f5afbfa5d721516e6db3948674d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from an <a class="el" href="namespace_open_kalman_1_1_eigen3.html#a8d408b48a797fea59c2b1e5ecd532920">eigen_diagonal_expr</a>. <br /></td></tr>
<tr class="separator:a156f5afbfa5d721516e6db3948674d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974497ad4596bc34bf41ce7534894eab"><td class="memTemplParams" colspan="2"><a id="a974497ad4596bc34bf41ce7534894eab"></a>
template&lt;typename Arg , std::enable_if_t&lt; self_adjoint_matrix&lt; Arg &gt; and std::is_base_of_v&lt; Eigen::TriangularBase&lt; std::decay_t&lt; Arg &gt;&gt;, std::decay_t&lt; Arg &gt;&gt; and internal::same_storage_triangle_as&lt; Arg, SelfAdjointMatrix &gt; and std::is_constructible_v&lt; Base, decltype(std::declval&lt; Arg &gt;().nestedExpression())&gt; , int &gt; </td></tr>
<tr class="memitem:a974497ad4596bc34bf41ce7534894eab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#a974497ad4596bc34bf41ce7534894eab">SelfAdjointMatrix</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a974497ad4596bc34bf41ce7534894eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a self-adjoint Eigen::TriangularBase-derived object of the same storage type. <br /></td></tr>
<tr class="separator:a974497ad4596bc34bf41ce7534894eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974497ad4596bc34bf41ce7534894eab"><td class="memTemplParams" colspan="2"><a id="a974497ad4596bc34bf41ce7534894eab"></a>
template&lt;typename Arg , std::enable_if_t&lt; self_adjoint_matrix&lt; Arg &gt; and std::is_base_of_v&lt; Eigen::TriangularBase&lt; std::decay_t&lt; Arg &gt;&gt;, std::decay_t&lt; Arg &gt;&gt; and(not internal::same_storage_triangle_as&lt; Arg, SelfAdjointMatrix &gt;) and std::is_constructible_v&lt; Base, decltype(adjoint(std::declval&lt; Arg &gt;().nestedExpression()))&gt; , int &gt; </td></tr>
<tr class="memitem:a974497ad4596bc34bf41ce7534894eab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#a974497ad4596bc34bf41ce7534894eab">SelfAdjointMatrix</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a974497ad4596bc34bf41ce7534894eab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a self-adjoint Eigen::TriangularBase-derived object of the opposite storage type. <br /></td></tr>
<tr class="separator:a974497ad4596bc34bf41ce7534894eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156f5afbfa5d721516e6db3948674d91"><td class="memTemplParams" colspan="2"><a id="a156f5afbfa5d721516e6db3948674d91"></a>
template&lt;typename Arg , std::enable_if_t&lt; eigen_matrix&lt; Arg &gt; and eigen_diagonal_expr&lt; NestedMatrix &gt; and square_matrix&lt; Arg &gt; and std::is_constructible_v&lt; Base, native_matrix_t&lt; Arg, MatrixTraits&lt; Arg &gt;::dimension, 1 &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a156f5afbfa5d721516e6db3948674d91"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#a156f5afbfa5d721516e6db3948674d91">SelfAdjointMatrix</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a156f5afbfa5d721516e6db3948674d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a square <a class="el" href="namespace_open_kalman_1_1_eigen3.html#a75cd699ad3fe06896706df1346cc4152">eigen_matrix</a> if NestedMatrix is <a class="el" href="namespace_open_kalman_1_1_eigen3.html#a8d408b48a797fea59c2b1e5ecd532920">eigen_diagonal_expr</a>. <br /></td></tr>
<tr class="separator:a156f5afbfa5d721516e6db3948674d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156f5afbfa5d721516e6db3948674d91"><td class="memTemplParams" colspan="2"><a id="a156f5afbfa5d721516e6db3948674d91"></a>
template&lt;typename Arg , std::enable_if_t&lt; eigen_matrix&lt; Arg &gt; and(not eigen_diagonal_expr&lt; NestedMatrix &gt;) and square_matrix&lt; Arg &gt; and std::is_constructible_v&lt; Base, Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a156f5afbfa5d721516e6db3948674d91"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#a156f5afbfa5d721516e6db3948674d91">SelfAdjointMatrix</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a156f5afbfa5d721516e6db3948674d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a <a class="el" href="namespace_open_kalman_1_1_eigen3.html#a75cd699ad3fe06896706df1346cc4152">eigen_matrix</a> if NestedMatrix is not <a class="el" href="namespace_open_kalman_1_1_eigen3.html#a8d408b48a797fea59c2b1e5ecd532920">eigen_diagonal_expr</a>. <br /></td></tr>
<tr class="separator:a156f5afbfa5d721516e6db3948674d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3b602937bbd92bdb3a7f89eb23abcd"><td class="memTemplParams" colspan="2">template&lt;typename ... Args, std::enable_if_t&lt; std::conjunction_v&lt; std::is_convertible&lt; Args, Scalar &gt;... &gt; and(storage_triangle !=TriangleType::diagonal or diagonal_matrix&lt; NestedMatrix &gt;) and(not zero_matrix&lt; NestedMatrix &gt;) and(not identity_matrix&lt; NestedMatrix &gt;) and((diagonal_matrix&lt; NestedMatrix &gt; and sizeof...(Args)==dimension) or sizeof...(Args)==dimension *dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:abb3b602937bbd92bdb3a7f89eb23abcd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#abb3b602937bbd92bdb3a7f89eb23abcd">SelfAdjointMatrix</a> (const Args ... args)</td></tr>
<tr class="memdesc:abb3b602937bbd92bdb3a7f89eb23abcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a list of scalar coefficients, in row-major order.  <a href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#abb3b602937bbd92bdb3a7f89eb23abcd">More...</a><br /></td></tr>
<tr class="separator:abb3b602937bbd92bdb3a7f89eb23abcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3b602937bbd92bdb3a7f89eb23abcd"><td class="memTemplParams" colspan="2">template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_convertible&lt; Args, Scalar &gt;... &gt; and(storage_triangle==TriangleType::diagonal) and(not diagonal_matrix&lt; NestedMatrix &gt;) and(diagonal_matrix&lt; NestedMatrix &gt; or sizeof...(Args)==dimension or sizeof...(Args)==dimension *dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:abb3b602937bbd92bdb3a7f89eb23abcd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#abb3b602937bbd92bdb3a7f89eb23abcd">SelfAdjointMatrix</a> (const Args ... args)</td></tr>
<tr class="memdesc:abb3b602937bbd92bdb3a7f89eb23abcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a list of scalar coefficients, in row-major order.  <a href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#abb3b602937bbd92bdb3a7f89eb23abcd">More...</a><br /></td></tr>
<tr class="separator:abb3b602937bbd92bdb3a7f89eb23abcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9387ede457804d492320a8aca2f0559"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#ab9387ede457804d492320a8aca2f0559">operator=</a> (const <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">SelfAdjointMatrix</a> &amp;other)</td></tr>
<tr class="separator:ab9387ede457804d492320a8aca2f0559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b35d8a423259c9ceeb5090839a0b3e"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#ab3b35d8a423259c9ceeb5090839a0b3e">operator=</a> (<a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">SelfAdjointMatrix</a> &amp;&amp;other) noexcept</td></tr>
<tr class="separator:ab3b35d8a423259c9ceeb5090839a0b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40518af67b984c4bfa6c258562e94d4"><td class="memTemplParams" colspan="2"><a id="af40518af67b984c4bfa6c258562e94d4"></a>
template&lt;typename Arg , std::enable_if_t&lt; eigen_self_adjoint_expr&lt; Arg &gt; and(not std::is_base_of_v&lt; SelfAdjointMatrix, std::decay_t&lt; Arg &gt;&gt;) and(MatrixTraits&lt; Arg &gt;::dimension==dimension) and modifiable&lt; NestedMatrix, nested_matrix_t&lt; Arg &gt;&gt; and((not eigen_diagonal_expr&lt; NestedMatrix &gt; and storage_triangle !=TriangleType::diagonal) or diagonal_matrix&lt; Arg &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af40518af67b984c4bfa6c258562e94d4"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#af40518af67b984c4bfa6c258562e94d4">operator=</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:af40518af67b984c4bfa6c258562e94d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from another self-adjoint matrix. <br /></td></tr>
<tr class="separator:af40518af67b984c4bfa6c258562e94d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40518af67b984c4bfa6c258562e94d4"><td class="memTemplParams" colspan="2"><a id="af40518af67b984c4bfa6c258562e94d4"></a>
template&lt;typename Arg , std::enable_if_t&lt; self_adjoint_matrix&lt; Arg &gt; and(not eigen_self_adjoint_expr&lt; Arg &gt;) and(MatrixTraits&lt; Arg &gt;::dimension==dimension) and modifiable&lt; NestedMatrix, Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af40518af67b984c4bfa6c258562e94d4"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#af40518af67b984c4bfa6c258562e94d4">operator=</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:af40518af67b984c4bfa6c258562e94d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from a general <a class="el" href="namespace_open_kalman.html#a63114cb8862cdcff4b5f0660b16a5bec">self_adjoint_matrix</a>. <br /></td></tr>
<tr class="separator:af40518af67b984c4bfa6c258562e94d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0905dc534b5439a96adf184f5419bc23"><td class="memItemLeft" align="right" valign="top"><a id="a0905dc534b5439a96adf184f5419bc23"></a>
auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nested_matrix</b> () &amp;</td></tr>
<tr class="memdesc:a0905dc534b5439a96adf184f5419bc23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nested matrix. <br /></td></tr>
<tr class="separator:a0905dc534b5439a96adf184f5419bc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c5c698bbcdd1aec1bcff3822e9a8c1"><td class="memItemLeft" align="right" valign="top"><a id="a35c5c698bbcdd1aec1bcff3822e9a8c1"></a>
decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><b>nested_matrix</b> () &amp;&amp;</td></tr>
<tr class="memdesc:a35c5c698bbcdd1aec1bcff3822e9a8c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a35c5c698bbcdd1aec1bcff3822e9a8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2071e5183ae0608ef3a4fc0d9d69c5a0"><td class="memItemLeft" align="right" valign="top"><a id="a2071e5183ae0608ef3a4fc0d9d69c5a0"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>nested_matrix</b> () const &amp;</td></tr>
<tr class="memdesc:a2071e5183ae0608ef3a4fc0d9d69c5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:a2071e5183ae0608ef3a4fc0d9d69c5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1952c5cf1a436d768bac386be6b69f"><td class="memItemLeft" align="right" valign="top"><a id="aaf1952c5cf1a436d768bac386be6b69f"></a>
decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><b>nested_matrix</b> () const &amp;&amp;</td></tr>
<tr class="memdesc:aaf1952c5cf1a436d768bac386be6b69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. <br /></td></tr>
<tr class="separator:aaf1952c5cf1a436d768bac386be6b69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb3b602937bbd92bdb3a7f89eb23abcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3b602937bbd92bdb3a7f89eb23abcd">&#9670;&nbsp;</a></span>SelfAdjointMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NestedMatrix , TriangleType storage_triangle&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args, std::enable_if_t&lt; std::conjunction_v&lt; std::is_convertible&lt; Args, Scalar &gt;... &gt; and(storage_triangle !=TriangleType::diagonal or diagonal_matrix&lt; NestedMatrix &gt;) and(not zero_matrix&lt; NestedMatrix &gt;) and(not identity_matrix&lt; NestedMatrix &gt;) and((diagonal_matrix&lt; NestedMatrix &gt; and sizeof...(Args)==dimension) or sizeof...(Args)==dimension *dimension), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">OpenKalman::Eigen3::SelfAdjointMatrix</a>&lt; NestedMatrix, storage_triangle &gt;::<a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">SelfAdjointMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Args ...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This assumes, without checking, that the coefficients represent a self-adjoint matrix. </p><dl class="section note"><dt>Note</dt><dd>Operative if storage_triangle is not <a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2aa0e17e2709a0404ae3d7de03b8ea9093" title="The diagonal elements of the matrix.">TriangleType::diagonal</a>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>List of scalar values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_self_adjoint_matrix_8hpp_source.html#l00198">198</a> of file <a class="el" href="_self_adjoint_matrix_8hpp_source.html">SelfAdjointMatrix.hpp</a>.</p>

</div>
</div>
<a id="abb3b602937bbd92bdb3a7f89eb23abcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3b602937bbd92bdb3a7f89eb23abcd">&#9670;&nbsp;</a></span>SelfAdjointMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NestedMatrix , TriangleType storage_triangle&gt; </div>
<div class="memtemplate">
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_convertible&lt; Args, Scalar &gt;... &gt; and(storage_triangle==TriangleType::diagonal) and(not diagonal_matrix&lt; NestedMatrix &gt;) and(diagonal_matrix&lt; NestedMatrix &gt; or sizeof...(Args)==dimension or sizeof...(Args)==dimension *dimension), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">OpenKalman::Eigen3::SelfAdjointMatrix</a>&lt; NestedMatrix, storage_triangle &gt;::<a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">SelfAdjointMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const Args ...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This assumes, without checking, that the coefficients represent a self-adjoint matrix. </p><dl class="section note"><dt>Note</dt><dd>Operative if NestedMatrix is not a <a class="el" href="namespace_open_kalman.html#acda49202b6dd92195051ed9db5fcdcaf">diagonal_matrix</a> but storage_triangle is <a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2aa0e17e2709a0404ae3d7de03b8ea9093" title="The diagonal elements of the matrix.">TriangleType::diagonal</a>. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>List of scalar values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_self_adjoint_matrix_8hpp_source.html#l00222">222</a> of file <a class="el" href="_self_adjoint_matrix_8hpp_source.html">SelfAdjointMatrix.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab9387ede457804d492320a8aca2f0559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9387ede457804d492320a8aca2f0559">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NestedMatrix , TriangleType storage_triangle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">OpenKalman::Eigen3::SelfAdjointMatrix</a>&lt; NestedMatrix, storage_triangle &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">SelfAdjointMatrix</a>&lt; NestedMatrix, storage_triangle &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignment operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html" title="A self-adjoint matrix.">SelfAdjointMatrix</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_self_adjoint_matrix_8hpp_source.html#l00231">231</a> of file <a class="el" href="_self_adjoint_matrix_8hpp_source.html">SelfAdjointMatrix.hpp</a>.</p>

</div>
</div>
<a id="ab3b35d8a423259c9ceeb5090839a0b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b35d8a423259c9ceeb5090839a0b3e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NestedMatrix , TriangleType storage_triangle&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">OpenKalman::Eigen3::SelfAdjointMatrix</a>&lt; NestedMatrix, storage_triangle &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">SelfAdjointMatrix</a>&lt; NestedMatrix, storage_triangle &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html" title="A self-adjoint matrix.">SelfAdjointMatrix</a> temporary value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_self_adjoint_matrix_8hpp_source.html#l00246">246</a> of file <a class="el" href="_self_adjoint_matrix_8hpp_source.html">SelfAdjointMatrix.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>C:/Users/cogden/CLionProjects/OpenKalman/OpenKalman/interfaces/eigen3/details/<a class="el" href="eigen3-forward-declarations_8hpp_source.html">eigen3-forward-declarations.hpp</a></li>
<li>C:/Users/cogden/CLionProjects/OpenKalman/OpenKalman/interfaces/eigen3/<a class="el" href="_self_adjoint_matrix_8hpp_source.html">SelfAdjointMatrix.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_open_kalman.html">OpenKalman</a></li><li class="navelem"><a class="el" href="namespace_open_kalman_1_1_eigen3.html">Eigen3</a></li><li class="navelem"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">SelfAdjointMatrix</a></li>
    <li class="footer">Generated on Sat Mar 27 2021 20:52:24 for OpenKalman by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0 </li>
  </ul>
</div>
</body>
</html>
