<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenKalman: OpenKalman Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenKalman
   </div>
   <div id="projectbrief">An open-source, heading-only library for Kalman filters and other recursive filters</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_open_kalman.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">OpenKalman Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_angle_degrees_traits.html">AngleDegreesTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_angle_positive_radians_traits.html">AnglePositiveRadiansTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_angle_traits.html">AngleTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_axis.html">Axis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_circle.html">Circle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_coefficients.html">Coefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of coefficient types to be associated with a variable. The types should be instances of <a class="el" href="struct_open_kalman_1_1is__coefficient.html" title="Whether an object is a coefficient.">is_coefficient</a>.  <a href="struct_open_kalman_1_1_coefficients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_coefficients_3_01_c_00_01_ctail_01_8_8_8_01_4.html">Coefficients&lt; C, Ctail ... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_coefficients_3_4.html">Coefficients&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_continuous_property_particle_distribution.html">ContinuousPropertyParticleDistribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> matrix.  <a href="struct_open_kalman_1_1_covariance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_cubature_points.html">CubaturePoints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_distance.html">Distance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_distribution_traits.html">DistributionTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits of a distribution.  <a href="struct_open_kalman_1_1_distribution_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_distribution_traits_3_01const_01_d_00_01_t_01_4.html">DistributionTraits&lt; const D, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_distribution_traits_3_01_d_01_6_6_00_01_t_01_4.html">DistributionTraits&lt; D &amp;&amp;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_distribution_traits_3_01_d_01_6_00_01_t_01_4.html">DistributionTraits&lt; D &amp;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_distribution_traits_3_01_gaussian_distribution_3_01_coeffs_00_01_matrix_bc59a4b7ea174b5f4a57b6c5fa6e55bd7.html">DistributionTraits&lt; GaussianDistribution&lt; Coeffs, MatrixBase, CovarianceBase, re &gt;, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen_diagonal.html">EigenDiagonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagonal matrix. Works similarly to Eigen::DiagonalMatrix.  <a href="struct_open_kalman_1_1_eigen_diagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen_self_adjoint_matrix.html">EigenSelfAdjointMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen_triangular_matrix.html">EigenTriangularMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen_zero.html">EigenZero</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typed vector.  <a href="struct_open_kalman_1_1_euclidean_mean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_finite_difference_linearization.html">FiniteDifferenceLinearization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_from_euclidean_expr.html">FromEuclideanExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_gaussian_distribution.html">GaussianDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian distribution, defined in terms of a mean vector and a covariance matrix.  <a href="struct_open_kalman_1_1_gaussian_distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_identity_transform.html">IdentityTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An identity transform from one statistical distribution to another.  <a href="struct_open_kalman_1_1_identity_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_identity_transformation.html">IdentityTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identity transformation from one single-column vector to another. Perturbation terms are treated as additive.  <a href="struct_open_kalman_1_1_identity_transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_inclination.html">Inclination</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__1by1.html">is_1by1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a 1-by-1 matrix.  <a href="struct_open_kalman_1_1is__1by1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__1by1_3_01_t_00_01std_1_1enable__if__t_3_01_matrix_traits_3_01_t_01_4_1ee71f5a574ba7a657f515def231ba7ee.html">is_1by1&lt; T, std::enable_if_t&lt; MatrixTraits&lt; T &gt;::dimension==1 and MatrixTraits&lt; T &gt;::columns==1 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defining a 1-by-1 matrix.  <a href="struct_open_kalman_1_1is__1by1_3_01_t_00_01std_1_1enable__if__t_3_01_matrix_traits_3_01_t_01_4_1ee71f5a574ba7a657f515def231ba7ee.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___cholesky.html">is_Cholesky</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a covariance is in the form of a Cholesky decomposition.  <a href="struct_open_kalman_1_1is___cholesky.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___cholesky_3_01_covariance_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_Cholesky&lt; Covariance&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___cholesky_3_01_gaussian_distribution_3_01_coefficients_00_01_mean_matr3ac2edca1703339ef2c785b5846544fb.html">is_Cholesky&lt; GaussianDistribution&lt; Coefficients, MeanMatrix, CovarianceMatrix, re &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___cholesky_3_01_square_root_covariance_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_Cholesky&lt; SquareRootCovariance&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__coefficient.html">is_coefficient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a coefficient.  <a href="struct_open_kalman_1_1is__coefficient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__coefficient_3_01_axis_01_4.html">is_coefficient&lt; Axis &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_axis.html">Axis</a> is a coefficient.  <a href="struct_open_kalman_1_1is__coefficient_3_01_axis_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__coefficient_3_01_circle_3_01_traits_01_4_01_4.html">is_coefficient&lt; Circle&lt; Traits &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_circle.html">Circle</a> is a coefficient.  <a href="struct_open_kalman_1_1is__coefficient_3_01_circle_3_01_traits_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__coefficient_3_01_coefficients_3_01_c_8_8_8_01_4_01_4.html">is_coefficient&lt; Coefficients&lt; C... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> can, itself, be a coefficient. May be used to group coefficients together as a unit.  <a href="struct_open_kalman_1_1is__coefficient_3_01_coefficients_3_01_c_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__coefficient_3_01_distance_01_4.html">is_coefficient&lt; Distance &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radius is a coefficient.  <a href="struct_open_kalman_1_1is__coefficient_3_01_distance_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__coefficient_3_01_inclination_3_01_traits_01_4_01_4.html">is_coefficient&lt; Inclination&lt; Traits &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_inclination.html">Inclination</a> is a coefficient.  <a href="struct_open_kalman_1_1is__coefficient_3_01_inclination_3_01_traits_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__coefficient_3_01_polar_3_01_coeff1_00_01_coeff2_01_4_01_4.html">is_coefficient&lt; Polar&lt; Coeff1, Coeff2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_polar.html">Polar</a> is a coefficient.  <a href="struct_open_kalman_1_1is__coefficient_3_01_polar_3_01_coeff1_00_01_coeff2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__coefficient_3_01_spherical_3_01_coeff1_00_01_coeff2_00_01_coeff3_01_4_01_4.html">is_coefficient&lt; Spherical&lt; Coeff1, Coeff2, Coeff3 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_spherical.html">Spherical</a> is aa coefficient.  <a href="struct_open_kalman_1_1is__coefficient_3_01_spherical_3_01_coeff1_00_01_coeff2_00_01_coeff3_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__column__vector.html">is_column_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the matrix is a column vector or set of column vectors.  <a href="struct_open_kalman_1_1is__column__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__column__vector_3_01_t_00_01std_1_1enable__if__t_3_01is__typed__matrix__v_3_01_t_01_4_01_4_01_4.html">is_column_vector&lt; T, std::enable_if_t&lt; is_typed_matrix_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typed matrix is a column vector if the columns are Axes only.  <a href="struct_open_kalman_1_1is__column__vector_3_01_t_00_01std_1_1enable__if__t_3_01is__typed__matrix__v_3_01_t_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__composite__coefficient.html">is_composite_coefficient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a composite coefficient.  <a href="struct_open_kalman_1_1is__composite__coefficient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__composite__coefficient_3_01_coefficients_3_01_c_8_8_8_01_4_01_4.html">is_composite_coefficient&lt; Coefficients&lt; C... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__covariance.html">is_covariance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a>.  <a href="struct_open_kalman_1_1is__covariance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__covariance_3_01_covariance_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_covariance&lt; Covariance&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__covariance_3_01_square_root_covariance_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_covariance&lt; SquareRootCovariance&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__covariance__base.html">is_covariance_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a base for <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a>.  <a href="struct_open_kalman_1_1is__covariance__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__covariance__base_3_01_eigen_diagonal_3_01_base_matrix_01_4_01_4.html">is_covariance_base&lt; EigenDiagonal&lt; BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__covariance__base_3_01_eigen_self_adjoint_matrix_3_01_base_matrix_00_01storage__triangle_01_4_01_4.html">is_covariance_base&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__covariance__base_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01triangle__type_01_4_01_4.html">is_covariance_base&lt; EigenTriangularMatrix&lt; BaseMatrix, triangle_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__covariance__base_3_01_eigen_zero_3_01_base_matrix_01_4_01_4.html">is_covariance_base&lt; EigenZero&lt; BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__covariance__base_3_01_t_00_01std_1_1enable__if__t_3_01is__native___eig2f07f4b770556a7b88061044c187d1cb.html">is_covariance_base&lt; T, std::enable_if_t&lt; is_native_Eigen_type_v&lt; T &gt; and(is_triangular_v&lt; T &gt; or is_self_adjoint_v&lt; T &gt;)&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal.html">is_diagonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a diagonal matrix.  <a href="struct_open_kalman_1_1is__diagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_covariance_3_01_coefficients_00_01_base_matrix_01_4_00_04b89bd4bac78b801318c13b8ae880618.html">is_diagonal&lt; Covariance&lt; Coefficients, BaseMatrix &gt;, std::enable_if_t&lt; not OpenKalman::is_zero_v&lt; BaseMatrix &gt; and not OpenKalman::is_identity_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_cwise_binary_op_3_01_eigen_1_1internal_1_1scal294aca6aeadd39ae7b09c9e12621e997.html">is_diagonal&lt; Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_difference_op&lt; typename Arg1::Scalar, typename Arg2::Scalar &gt;, Arg1, Arg2 &gt;, std::enable_if_t&lt; not(is_zero_v&lt; Arg1 &gt; and is_zero_v&lt; Arg2 &gt;) and not(is_identity_v&lt; Arg1 &gt; and is_identity_v&lt; Arg2 &gt;) and not(is_1by1_v&lt; Arg1 &gt; and is_1by1_v&lt; Arg2 &gt;)&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference of two diagonal matrices is also diagonal.  <a href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_cwise_binary_op_3_01_eigen_1_1internal_1_1scal294aca6aeadd39ae7b09c9e12621e997.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_cwise_binary_op_3_01_eigen_1_1internal_1_1scal4c7d8580fda1c07e23ddcc10e353d343.html">is_diagonal&lt; Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_product_op&lt; typename Arg1::Scalar, typename Arg2::Scalar &gt;, Arg1, Arg2 &gt;, std::enable_if_t&lt; not is_zero_v&lt; Arg1 &gt; and not is_zero_v&lt; Arg2 &gt; and not is_1by1_v&lt; Arg1 &gt; and not is_1by1_v&lt; Arg2 &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal matrix times a scalar is also diagonal.  <a href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_cwise_binary_op_3_01_eigen_1_1internal_1_1scal4c7d8580fda1c07e23ddcc10e353d343.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_cwise_binary_op_3_01_eigen_1_1internal_1_1scal551166b221dbfd2d2837bb5674492b66.html">is_diagonal&lt; Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_quotient_op&lt; typename Arg1::Scalar, typename Arg2::Scalar &gt;, Arg1, Arg2 &gt;, std::enable_if_t&lt; not is_zero_v&lt; Arg1 &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal matrix divided by a scalar is also diagonal.  <a href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_cwise_binary_op_3_01_eigen_1_1internal_1_1scal551166b221dbfd2d2837bb5674492b66.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_cwise_binary_op_3_01_eigen_1_1internal_1_1scalb427866a6e489f6d728bb356c5a3aab4.html">is_diagonal&lt; Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_sum_op&lt; typename Arg1::Scalar, typename Arg2::Scalar &gt;, Arg1, Arg2 &gt;, std::enable_if_t&lt; not(is_zero_v&lt; Arg1 &gt; and is_zero_v&lt; Arg2 &gt;) and not(is_1by1_v&lt; Arg1 &gt; and is_1by1_v&lt; Arg2 &gt;)&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of two diagonal matrices is also diagonal.  <a href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_cwise_binary_op_3_01_eigen_1_1internal_1_1scalb427866a6e489f6d728bb356c5a3aab4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_cwise_unary_op_3_01_eigen_1_1internal_1_1scala9e8f5ac11baa7d284dfbca91af840688.html">is_diagonal&lt; Eigen::CwiseUnaryOp&lt; Eigen::internal::scalar_opposite_op&lt; typename Arg::Scalar &gt;, Arg &gt;, std::enable_if_t&lt; not is_zero_v&lt; Arg &gt; and not is_1by1_v&lt; Arg &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The negation of an identity matrix is diagonal.  <a href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_cwise_unary_op_3_01_eigen_1_1internal_1_1scala9e8f5ac11baa7d284dfbca91af840688.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_product_3_01_arg1_00_01_arg2_01_4_00_01std_1_15ae140aa3467353bc6d238c4fa5989a5.html">is_diagonal&lt; Eigen::Product&lt; Arg1, Arg2 &gt;, std::enable_if_t&lt; not((is_zero_v&lt; Arg1 &gt; or is_zero_v&lt; Arg2 &gt;) or(is_identity_v&lt; Arg1 &gt; and is_identity_v&lt; Arg2 &gt;) or(Arg1::RowsAtCompileTime==1 and Arg2::ColsAtCompileTime==1))&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product of two diagonal matrices is also diagonal.  <a href="struct_open_kalman_1_1is__diagonal_3_01_eigen_1_1_product_3_01_arg1_00_01_arg2_01_4_00_01std_1_15ae140aa3467353bc6d238c4fa5989a5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_eigen_diagonal_3_01_base_matrix_01_4_00_01std_1_1enable_e6b0541924416dbf65fa608e2770f8cd.html">is_diagonal&lt; EigenDiagonal&lt; BaseMatrix &gt;, std::enable_if_t&lt; not is_zero_v&lt; BaseMatrix &gt; and not is_1by1_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_eigen_self_adjoint_matrix_3_01_base_matrix_00_01storage_771fb10fb6f15c39268119c4ad6ff845.html">is_diagonal&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt;, std::enable_if_t&lt; not is_zero_v&lt; BaseMatrix &gt; and not is_identity_v&lt; BaseMatrix &gt; and not is_1by1_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01triangle__c1f83a28517936ca5bae2887de705f86.html">is_diagonal&lt; EigenTriangularMatrix&lt; BaseMatrix, triangle_type &gt;, std::enable_if_t&lt; not is_zero_v&lt; BaseMatrix &gt; and not is_identity_v&lt; BaseMatrix &gt; and not is_1by1_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_gaussian_distribution_3_01_coefficients_00_01_mean_matri07af77aad55f59aac0801e3b4f14428b.html">is_diagonal&lt; GaussianDistribution&lt; Coefficients, MeanMatrix, CovarianceMatrix, re &gt;, std::enable_if_t&lt; not is_zero_v&lt; MeanMatrix &gt; or not is_zero_v&lt; CovarianceMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_square_root_covariance_3_01_coefficients_00_01_base_matrb8d505607c5d5eea549dea1c749e774a.html">is_diagonal&lt; SquareRootCovariance&lt; Coefficients, BaseMatrix &gt;, std::enable_if_t&lt; not is_zero_v&lt; BaseMatrix &gt; and not is_identity_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_t_00_01std_1_1enable__if__t_3_01is__zero__v_3_01_t_01_4_39d3ae3c69596fcfe7e80b27799c0a31.html">is_diagonal&lt; T, std::enable_if_t&lt; is_zero_v&lt; T &gt; or is_identity_v&lt; T &gt; or is_1by1_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero and identity matrices are diagonal.  <a href="struct_open_kalman_1_1is__diagonal_3_01_t_00_01std_1_1enable__if__t_3_01is__zero__v_3_01_t_01_4_39d3ae3c69596fcfe7e80b27799c0a31.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__diagonal_3_01_typed_matrix_3_01_coefficients_00_01_coefficients_00_01_976b60cf999dd779f5c5b25a5db08314.html">is_diagonal&lt; TypedMatrix&lt; Coefficients, Coefficients, BaseMatrix &gt;, std::enable_if_t&lt; not is_zero_v&lt; BaseMatrix &gt; and not is_identity_v&lt; BaseMatrix &gt; and not is_1by1_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__distribution.html">is_distribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a distribution.  <a href="struct_open_kalman_1_1is__distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__distribution_3_01_t_00_01std_1_1enable__if__t_3_01is___gaussian__distr7866addbe217de44033c0bf303169e60.html">is_distribution&lt; T, std::enable_if_t&lt; is_Gaussian_distribution_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen__lower__storage__triangle.html">is_Eigen_lower_storage_triangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen__lower__storage__triangle_3_01_eigen_self_adjoint_matrix_3_01_bba29dde6fd060ff45b8a251520cd6e04.html">is_Eigen_lower_storage_triangle&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, TriangleType::lower &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen__matrix.html">is_Eigen_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a regular Eigen matrix.  <a href="struct_open_kalman_1_1is___eigen__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen__upper__storage__triangle.html">is_Eigen_upper_storage_triangle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen__upper__storage__triangle_3_01_eigen_self_adjoint_matrix_3_01_b8bf1b4016112b8fd64e118b566662cb9.html">is_Eigen_upper_storage_triangle&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, TriangleType::upper &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen_diagonal.html">is_EigenDiagonal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen_diagonal_3_01_eigen_diagonal_3_01_base_matrix_01_4_01_4.html">is_EigenDiagonal&lt; EigenDiagonal&lt; BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen_self_adjoint_matrix.html">is_EigenSelfAdjointMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen_self_adjoint_matrix_3_01_eigen_self_adjoint_matrix_3_01_base_ma44808b91b873e772f75bad8edd42aa15.html">is_EigenSelfAdjointMatrix&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen_triangular_matrix.html">is_EigenTriangularMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen_triangular_matrix_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01triangle__type_01_4_01_4.html">is_EigenTriangularMatrix&lt; EigenTriangularMatrix&lt; BaseMatrix, triangle_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen_zero.html">is_EigenZero</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___eigen_zero_3_01_eigen_zero_3_01_base_matrix_01_4_01_4.html">is_EigenZero&lt; EigenZero&lt; BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable.html">is_element_gettable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object has elements that can be retrieved with N indices.  <a href="struct_open_kalman_1_1is__element__gettable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01const_01_t_00_01_n_00_01_enable_01_4.html">is_element_gettable&lt; const T, N, Enable &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_covariance_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_gettable&lt; Covariance&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_eigen_diagonal_3_01_base_matrix_01_4_00_01_n_01_4.html">is_element_gettable&lt; EigenDiagonal&lt; BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_eigen_self_adjoint_matrix_3_01_base_matrix_00_02ca288cc8ce8765da36b94b833918c89.html">is_element_gettable&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_eigen_self_adjoint_matrix_3_01_base_matrix_00_0ba5684c5bbe509ff71ee4db0387bce4e.html">is_element_gettable&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt;, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01triangle__type_01_4_00_011_01_4.html">is_element_gettable&lt; EigenTriangularMatrix&lt; BaseMatrix, triangle_type &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01triangle__type_01_4_00_012_01_4.html">is_element_gettable&lt; EigenTriangularMatrix&lt; BaseMatrix, triangle_type &gt;, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_eigen_zero_3_01_base_matrix_01_4_00_01_n_01_4.html">is_element_gettable&lt; EigenZero&lt; BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_euclidean_mean_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_gettable&lt; EuclideanMean&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_from_euclidean_expr_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_gettable&lt; FromEuclideanExpr&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_mean_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_gettable&lt; Mean&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_square_root_covariance_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_gettable&lt; SquareRootCovariance&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_t_01_6_6_00_01_n_00_01_enable_01_4.html">is_element_gettable&lt; T &amp;&amp;, N, Enable &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_t_01_6_00_01_n_00_01_enable_01_4.html">is_element_gettable&lt; T &amp;, N, Enable &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_t_00_011_00_01std_1_1enable__if__t_3_01std_1_1i13c8564cec2dd5df2f0f76d1bf09d958.html">is_element_gettable&lt; T, 1, std::enable_if_t&lt; std::is_same_v&lt; T, std::decay_t&lt; T &gt; &gt; and is_native_Eigen_type_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_t_00_012_00_01std_1_1enable__if__t_3_01std_1_1i1e394c1bea95df833aace347b8c29ed8.html">is_element_gettable&lt; T, 2, std::enable_if_t&lt; std::is_same_v&lt; T, std::decay_t&lt; T &gt; &gt; and is_native_Eigen_type_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_to_euclidean_expr_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_gettable&lt; ToEuclideanExpr&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__gettable_3_01_typed_matrix_3_01_row_coefficients_00_01_columne067d791207a59f4de97b0abc8669c34.html">is_element_gettable&lt; TypedMatrix&lt; RowCoefficients, ColumnCoefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable.html">is_element_settable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object has elements that can be set with N indices.  <a href="struct_open_kalman_1_1is__element__settable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_covariance_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_settable&lt; Covariance&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_eigen_diagonal_3_01_base_matrix_01_4_00_01_n_01_4.html">is_element_settable&lt; EigenDiagonal&lt; BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_eigen_self_adjoint_matrix_3_01_base_matrix_00_0b5745e3846f80dd4674dc54a570cd28c.html">is_element_settable&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_eigen_self_adjoint_matrix_3_01_base_matrix_00_0355ff4716c58856fe07f4418b23c3364.html">is_element_settable&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt;, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01triangle__type_01_4_00_011_01_4.html">is_element_settable&lt; EigenTriangularMatrix&lt; BaseMatrix, triangle_type &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01triangle__type_01_4_00_012_01_4.html">is_element_settable&lt; EigenTriangularMatrix&lt; BaseMatrix, triangle_type &gt;, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_eigen_zero_3_01_base_matrix_01_4_00_01_n_01_4.html">is_element_settable&lt; EigenZero&lt; BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_euclidean_mean_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_settable&lt; EuclideanMean&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_from_euclidean_expr_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_settable&lt; FromEuclideanExpr&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_mean_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_settable&lt; Mean&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_square_root_covariance_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_settable&lt; SquareRootCovariance&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_t_01_6_6_00_01_n_00_01_enable_01_4.html">is_element_settable&lt; T &amp;&amp;, N, Enable &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_t_01_6_00_01_n_00_01_enable_01_4.html">is_element_settable&lt; T &amp;, N, Enable &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_t_00_011_00_01std_1_1enable__if__t_3_01std_1_1i8de021f820ead1a931fd231d9c642544.html">is_element_settable&lt; T, 1, std::enable_if_t&lt; std::is_same_v&lt; T, std::decay_t&lt; T &gt; &gt; and is_native_Eigen_type_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_t_00_012_00_01std_1_1enable__if__t_3_01std_1_1i5933292d79957cb47321ff471a0692eb.html">is_element_settable&lt; T, 2, std::enable_if_t&lt; std::is_same_v&lt; T, std::decay_t&lt; T &gt; &gt; and is_native_Eigen_type_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_to_euclidean_expr_3_01_coefficients_00_01_base_matrix_01_4_00_01_n_01_4.html">is_element_settable&lt; ToEuclideanExpr&lt; Coefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__element__settable_3_01_typed_matrix_3_01_row_coefficients_00_01_columnd0688630ea0fdd6264f6ba5c4921f9a0.html">is_element_settable&lt; TypedMatrix&lt; RowCoefficients, ColumnCoefficients, BaseMatrix &gt;, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__equivalent.html">is_equivalent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether coefficients are equivalent.  <a href="struct_open_kalman_1_1is__equivalent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__equivalent_3_01_axis_00_01_axis_01_4.html">is_equivalent&lt; Axis, Axis &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__equivalent_3_01_circle_3_01_traits_01_4_00_01_circle_3_01_traits_01_4_01_4.html">is_equivalent&lt; Circle&lt; Traits &gt;, Circle&lt; Traits &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__equivalent_3_01_coefficients_3_01_c1_8_8_8_01_4_00_01_coefficients_3_06af3164a7d4e7b320b7b50fee9260a27.html">is_equivalent&lt; Coefficients&lt; C1... &gt;, Coefficients&lt; C2... &gt;, std::enable_if_t&lt; std::conjunction_v&lt; is_equivalent&lt; C1, C2 &gt;... &gt; and(sizeof...(C1) !=1)&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__equivalent_3_01_coefficients_3_01_t_01_4_00_01_coefficients_3_01_u_01_4_01_4.html">is_equivalent&lt; Coefficients&lt; T &gt;, Coefficients&lt; U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__equivalent_3_01_coefficients_3_01_t_01_4_00_01_u_01_4.html">is_equivalent&lt; Coefficients&lt; T &gt;, U &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__equivalent_3_01_distance_00_01_distance_01_4.html">is_equivalent&lt; Distance, Distance &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__equivalent_3_01_inclination_3_01_traits_01_4_00_01_inclination_3_01_traits_01_4_01_4.html">is_equivalent&lt; Inclination&lt; Traits &gt;, Inclination&lt; Traits &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__equivalent_3_01_polar_3_01_coeff1a_00_01_coeff2a_01_4_00_01_polar_3_01fc44bcc17a0c66b1ebc9e836d57a8b27.html">is_equivalent&lt; Polar&lt; Coeff1a, Coeff2a &gt;, Polar&lt; Coeff1b, Coeff2b &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__equivalent_3_01_spherical_3_01_coeff1a_00_01_coeff2a_00_01_coeff3a_01_42f2d7eddeb022f643c7733b42facdf4.html">is_equivalent&lt; Spherical&lt; Coeff1a, Coeff2a, Coeff3a &gt;, Spherical&lt; Coeff1b, Coeff2b, Coeff3b &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__equivalent_3_01_t_00_01_coefficients_3_01_u_01_4_01_4.html">is_equivalent&lt; T, Coefficients&lt; U &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___euclidean__mean.html">is_Euclidean_mean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a euclidean mean.  <a href="struct_open_kalman_1_1is___euclidean__mean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___euclidean__mean_3_01_euclidean_mean_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_Euclidean_mean&lt; EuclideanMean&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___euclidean__transformed.html">is_Euclidean_transformed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is Euclidean-transformed.  <a href="struct_open_kalman_1_1is___euclidean__transformed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___euclidean__transformed_3_01_t_00_01std_1_1enable__if__t_3_01is___eucl28a69b81c599fbcc9126873d137d60e6.html">is_Euclidean_transformed&lt; T, std::enable_if_t&lt; is_Euclidean_mean_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="A typed vector.">EuclideanMean</a> is Euclidean-transformed unless the coefficients are Axes only.  <a href="struct_open_kalman_1_1is___euclidean__transformed_3_01_t_00_01std_1_1enable__if__t_3_01is___eucl28a69b81c599fbcc9126873d137d60e6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___from_euclidean_expr.html">is_FromEuclideanExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___from_euclidean_expr_3_01_from_euclidean_expr_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_FromEuclideanExpr&lt; FromEuclideanExpr&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___gaussian__distribution.html">is_Gaussian_distribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a Gaussian distribution.  <a href="struct_open_kalman_1_1is___gaussian__distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___gaussian__distribution_3_01_gaussian_distribution_3_01_coefficients_0fe8292b8db0c264863ae87e1d36486a6.html">is_Gaussian_distribution&lt; GaussianDistribution&lt; Coefficients, MeanMatrix, CovarianceMatrix, re &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__identity.html">is_identity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is an identity matrix.  <a href="struct_open_kalman_1_1is__identity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__identity_3_01_covariance_3_01_coefficients_00_01_base_matrix_01_4_00_0dfd29cdf2cc3fdacfb3de18193492c76.html">is_identity&lt; Covariance&lt; Coefficients, BaseMatrix &gt;, std::enable_if_t&lt; not is_zero_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__identity_3_01_eigen_1_1_product_3_01_arg1_00_01_arg2_01_4_01_4.html">is_identity&lt; Eigen::Product&lt; Arg1, Arg2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product of two identity matrices is also identity.  <a href="struct_open_kalman_1_1is__identity_3_01_eigen_1_1_product_3_01_arg1_00_01_arg2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__identity_3_01_eigen_identity_3_01_arg_01_4_01_4.html">is_identity&lt; EigenIdentity&lt; Arg &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__identity_3_01_eigen_self_adjoint_matrix_3_01_base_matrix_00_01storage__triangle_01_4_01_4.html">is_identity&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__identity_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01triangle__type_01_4_01_4.html">is_identity&lt; EigenTriangularMatrix&lt; BaseMatrix, triangle_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__identity_3_01_euclidean_mean_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_identity&lt; EuclideanMean&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__identity_3_01_mean_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_identity&lt; Mean&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__identity_3_01_square_root_covariance_3_01_coefficients_00_01_base_matra956d66eee16f433ab0fdd8f8fd1a4c7.html">is_identity&lt; SquareRootCovariance&lt; Coefficients, BaseMatrix &gt;, std::enable_if_t&lt; not is_zero_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__identity_3_01_typed_matrix_3_01_row_coefficients_00_01_column_coeffici1351c24fc367b2e40898bb0170bb4510.html">is_identity&lt; TypedMatrix&lt; RowCoefficients, ColumnCoefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function.html">is_linearized_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a linearized function (with defined Jacobian and optionally Hessian functions).  <a href="struct_open_kalman_1_1is__linearized__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function_3_01const_01_t_00_01order_01_4.html">is_linearized_function&lt; const T, order &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function_3_01_linear_transformation_3_01_in_c_00_01_out_c_98852e61018a2159fe6d4ebf44cad3c4.html">is_linearized_function&lt; LinearTransformation&lt; InC, OutC, T, Ps... &gt;, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function_3_01_linear_transformation_3_01_in_c_00_01_out_c_39f5bfaa6e1f69f840238fd37aa20ca9.html">is_linearized_function&lt; LinearTransformation&lt; InC, OutC, T, Ps... &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function_3_01_t_01_6_6_00_01order_01_4.html">is_linearized_function&lt; T &amp;&amp;, order &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function_3_01_t_01_6_00_01order_01_4.html">is_linearized_function&lt; T &amp;, order &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function_3_01_t_00_010_00_01std_1_1enable__if__t_3_01not_0658e6b128af786baea8f0cff75ee54bc.html">is_linearized_function&lt; T, 0, std::enable_if_t&lt; not std::is_reference_v&lt; T &gt; and not std::is_const_v&lt; T &gt; and(std::is_member_function_pointer_v&lt; decltype(&amp;std::decay_t&lt; T &gt;::operator())&gt; or std::is_function_v&lt; T &gt;)&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function_3_01_t_00_011_00_01std_1_1enable__if__t_3_01not_08c6875afdfb25198a92283e37baf1148.html">is_linearized_function&lt; T, 1, std::enable_if_t&lt; not std::is_reference_v&lt; T &gt; and not std::is_const_v&lt; T &gt; and(std::is_member_function_pointer_v&lt; decltype(&amp;T::jacobian)&gt; and is_linearized_function_v&lt; T, 0 &gt;)&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function_3_01_t_00_012_00_01std_1_1enable__if__t_3_01not_07d0950e2644579936619658ad620d21d.html">is_linearized_function&lt; T, 2, std::enable_if_t&lt; not std::is_reference_v&lt; T &gt; and not std::is_const_v&lt; T &gt; and(std::is_member_function_pointer_v&lt; decltype(&amp;T::hessian)&gt; and is_linearized_function_v&lt; T, 1 &gt;)&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function_3_01_transformation_3_01_function_00_01_jacobian_a748c20a1a62fa1ea97c02db59d000bf.html">is_linearized_function&lt; Transformation&lt; Function, Jacobian, TaylorDerivatives... &gt;, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function_3_01_transformation_3_01_function_00_01_jacobian_73cbbf896ccb2ba830b7f370cebe21fd.html">is_linearized_function&lt; Transformation&lt; Function, Jacobian, TaylorDerivatives... &gt;, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function_3_01_transformation_3_01_function_00_01_taylor_def02777ca65020125a8046af8500cf636.html">is_linearized_function&lt; Transformation&lt; Function, TaylorDerivatives... &gt;, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__lower__triangular.html">is_lower_triangular</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a lower triangular matrix.  <a href="struct_open_kalman_1_1is__lower__triangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__lower__triangular_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01_79c2f7730b05e5caa22d7d268545f071.html">is_lower_triangular&lt; EigenTriangularMatrix&lt; BaseMatrix, TriangleType::lower &gt;, std::enable_if_t&lt; not is_diagonal_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__lower__triangular_3_01_square_root_covariance_3_01_coefficients_00_01_0a65f5c8d367b792099cfb09a05be591.html">is_lower_triangular&lt; SquareRootCovariance&lt; Coefficients, BaseMatrix &gt;, std::enable_if_t&lt; not is_diagonal_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__lower__triangular_3_01_t_00_01std_1_1enable__if__t_3_01is__diagonal__v_3_01_t_01_4_01_4_01_4.html">is_lower_triangular&lt; T, std::enable_if_t&lt; is_diagonal_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal matrices are lower-triangular.  <a href="struct_open_kalman_1_1is__lower__triangular_3_01_t_00_01std_1_1enable__if__t_3_01is__diagonal__v_3_01_t_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__mean.html">is_mean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a mean.  <a href="struct_open_kalman_1_1is__mean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__mean_3_01_mean_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_mean&lt; Mean&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__native___eigen__type.html">is_native_Eigen_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a native Eigen::MatrixBase type in Eigen3.  <a href="struct_open_kalman_1_1is__native___eigen__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__perturbation.html">is_perturbation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__prefix.html">is_prefix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether one set of coefficients is a pre-fix for another set.  <a href="struct_open_kalman_1_1is__prefix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__prefix_3_01_c_00_01_coefficients_3_01_c_00_01_c1_8_8_8_01_4_00_01std_1cc9c769d6ef69b838d920770316b552a.html">is_prefix&lt; C, Coefficients&lt; C, C1... &gt;, std::enable_if_t&lt; is_coefficient_v&lt; C &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__prefix_3_01_c1_00_01_c2_00_01std_1_1enable__if__t_3_01is__equivalent__1a844eafc9babcba683af727de47f483.html">is_prefix&lt; C1, C2, std::enable_if_t&lt; is_equivalent_v&lt; C1, C2 &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__prefix_3_01_coefficients_3_01_ca_00_01_c1_8_8_8_01_4_00_01_coefficient12ca96deaab9d40a2ae26862e25c49c2.html">is_prefix&lt; Coefficients&lt; Ca, C1... &gt;, Coefficients&lt; Cb, C2... &gt;, std::enable_if_t&lt; is_equivalent_v&lt; Ca, Cb &gt; and is_prefix_v&lt; Coefficients&lt; C1... &gt;, Coefficients&lt; C2... &gt; &gt; and not is_equivalent_v&lt; Coefficients&lt; Ca, C1... &gt;, Coefficients&lt; Cb, C2... &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__prefix_3_01_coefficients_3_4_00_01_c_00_01std_1_1enable__if__t_3_01is_de81cc06fc3a9d0db88fbb61a822e0b8.html">is_prefix&lt; Coefficients&lt;&gt;, C, std::enable_if_t&lt; is_coefficient_v&lt; C &gt; and not is_equivalent_v&lt; Coefficients&lt;&gt;, C &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__self__adjoint.html">is_self_adjoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a self-adjoint matrix.  <a href="struct_open_kalman_1_1is__self__adjoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__self__adjoint_3_01_covariance_3_01_coefficients_00_01_base_matrix_01_44f67bc1cabfc6d793bf25ea249927669.html">is_self_adjoint&lt; Covariance&lt; Coefficients, BaseMatrix &gt;, std::enable_if_t&lt; not OpenKalman::is_diagonal_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__self__adjoint_3_01_eigen_self_adjoint_matrix_3_01_base_matrix_00_01sto3beaf4d561232c1dd69200bf8fdaffef.html">is_self_adjoint&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt;, std::enable_if_t&lt; not is_diagonal_v&lt; BaseMatrix &gt; and storage_triangle !=TriangleType::diagonal &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__self__adjoint_3_01_gaussian_distribution_3_01_coefficients_00_01_mean_4bb2c3c056cb3fd176ff2fa2da508d23.html">is_self_adjoint&lt; GaussianDistribution&lt; Coefficients, MeanMatrix, CovarianceMatrix, re &gt;, std::enable_if_t&lt; not is_diagonal_v&lt; CovarianceMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__self__adjoint_3_01_t_00_01std_1_1enable__if__t_3_01is__diagonal__v_3_01_t_01_4_01_4_01_4.html">is_self_adjoint&lt; T, std::enable_if_t&lt; is_diagonal_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal matrices are self-adjoint.  <a href="struct_open_kalman_1_1is__self__adjoint_3_01_t_00_01std_1_1enable__if__t_3_01is__diagonal__v_3_01_t_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__square__root.html">is_square_root</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a Cholesky square root (e.g., <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a>).  <a href="struct_open_kalman_1_1is__square__root.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__square__root_3_01_square_root_covariance_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_square_root&lt; SquareRootCovariance&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict.html">is_strict</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an expression is strict.  <a href="struct_open_kalman_1_1is__strict.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_covariance_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_strict&lt; Covariance&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_block_3_01_xpr_type_00_01_block_rows_00_01_block1c71fa13ca0c2efb2475f3c5667855c0.html">is_strict&lt; Eigen::Block&lt; XprType, BlockRows, BlockCols, InnerPanel &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_cwise_binary_op_3_01_binary_op_00_01_lhs_type_00_01_rhs_type_01_4_01_4.html">is_strict&lt; Eigen::CwiseBinaryOp&lt; BinaryOp, LhsType, RhsType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_cwise_nullary_op_3_01_eigen_1_1internal_1_1linsp94a3265d4d5ba73ac91a76837fc66831.html">is_strict&lt; Eigen::CwiseNullaryOp&lt; Eigen::internal::linspaced_op&lt; Scalar, PacketType &gt;, PlainObjectType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_cwise_nullary_op_3_01_eigen_1_1internal_1_1scalae33ff07791169da5ea18d495df37cc3a.html">is_strict&lt; Eigen::CwiseNullaryOp&lt; Eigen::internal::scalar_constant_op&lt; Scalar &gt;, PlainObjectType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_cwise_nullary_op_3_01_eigen_1_1internal_1_1scalae1cc94c3e12ef59f26366abc9e65c583.html">is_strict&lt; Eigen::CwiseNullaryOp&lt; Eigen::internal::scalar_identity_op&lt; Scalar &gt;, PlainObjectType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_cwise_ternary_op_3_01_ternary_op_00_01_arg1_00_01_arg2_00_01_arg3_01_4_01_4.html">is_strict&lt; Eigen::CwiseTernaryOp&lt; TernaryOp, Arg1, Arg2, Arg3 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_cwise_unary_op_3_01_unary_op_00_01_xpr_type_01_4_01_4.html">is_strict&lt; Eigen::CwiseUnaryOp&lt; UnaryOp, XprType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_diagonal_3_01_matrix_type_00_01_diag_index_01_4_01_4.html">is_strict&lt; Eigen::Diagonal&lt; MatrixType, DiagIndex &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_diagonal_matrix_3_01_scalar_00_01_size_at_compilbde9a2d3c4c48f3d26fb835dbc6e04b4.html">is_strict&lt; Eigen::DiagonalMatrix&lt; Scalar, SizeAtCompileTime, MaxSizeAtCompileTime &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_diagonal_wrapper_3_01_diag_vector_type_01_4_01_4.html">is_strict&lt; Eigen::DiagonalWrapper&lt; DiagVectorType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_inverse_3_01_xpr_type_01_4_01_4.html">is_strict&lt; Eigen::Inverse&lt; XprType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_matrix_3_01_s_00_01rows_00_01cols_00_01options_0590869868e0fdc470acb8fdf4186db22.html">is_strict&lt; Eigen::Matrix&lt; S, rows, cols, options, maxrows, maxcols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_matrix_wrapper_3_01_xpr_type_01_4_01_4.html">is_strict&lt; Eigen::MatrixWrapper&lt; XprType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_permutation_matrix_3_01_size_at_compile_time_00_9fa6751004d07ba184cb696563c56ab4.html">is_strict&lt; Eigen::PermutationMatrix&lt; SizeAtCompileTime, MaxSizeAtCompileTime, StorageIndex &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_permutation_wrapper_3_01_indices_type_01_4_01_4.html">is_strict&lt; Eigen::PermutationWrapper&lt; IndicesType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_product_3_01_lhs_type_00_01_rhs_type_00_01_option_01_4_01_4.html">is_strict&lt; Eigen::Product&lt; LhsType, RhsType, Option &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_replicate_3_01_matrix_type_00_01_row_factor_00_01_col_factor_01_4_01_4.html">is_strict&lt; Eigen::Replicate&lt; MatrixType, RowFactor, ColFactor &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_reverse_3_01_matrix_type_00_01_direction_01_4_01_4.html">is_strict&lt; Eigen::Reverse&lt; MatrixType, Direction &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_select_3_01_arg1_00_01_arg2_00_01_arg3_01_4_01_4.html">is_strict&lt; Eigen::Select&lt; Arg1, Arg2, Arg3 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_self_adjoint_view_3_01_matrix_type_00_01_up_lo_01_4_01_4.html">is_strict&lt; Eigen::SelfAdjointView&lt; MatrixType, UpLo &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_transpose_3_01_matrix_type_01_4_01_4.html">is_strict&lt; Eigen::Transpose&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_triangular_view_3_01_matrix_type_00_01_mode_01_4_01_4.html">is_strict&lt; Eigen::TriangularView&lt; MatrixType, Mode &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_1_1_vector_block_3_01_vector_type_00_01_size_01_4_01_4.html">is_strict&lt; Eigen::VectorBlock&lt; VectorType, Size &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_diagonal_3_01_base_matrix_01_4_01_4.html">is_strict&lt; EigenDiagonal&lt; BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_self_adjoint_matrix_3_01_base_matrix_00_01storage__triangle_01_4_01_4.html">is_strict&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01triangle__type_01_4_01_4.html">is_strict&lt; EigenTriangularMatrix&lt; BaseMatrix, triangle_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_eigen_zero_3_01_arg_type_01_4_01_4.html">is_strict&lt; EigenZero&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_euclidean_mean_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_strict&lt; EuclideanMean&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_from_euclidean_expr_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_strict&lt; FromEuclideanExpr&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_gaussian_distribution_3_01_coefficients_00_01_mean_matrix_ebd8ea43b2261e0e9b2acbccee535121.html">is_strict&lt; GaussianDistribution&lt; Coefficients, MeanMatrix, CovarianceMatrix, re &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_mean_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_strict&lt; Mean&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_square_root_covariance_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_strict&lt; SquareRootCovariance&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_to_euclidean_expr_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_strict&lt; ToEuclideanExpr&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict_3_01_typed_matrix_3_01_row_coefficients_00_01_column_coefficients_00_01_base_matrix_01_4_01_4.html">is_strict&lt; TypedMatrix&lt; RowCoefficients, ColumnCoefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict__matrix.html">is_strict_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an expression is a strict, regular matrix.  <a href="struct_open_kalman_1_1is__strict__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__strict__matrix_3_01_eigen_1_1_matrix_3_01_s_00_01rows_00_01cols_00_01o8874814c2eef51966377bcef6c6771a9.html">is_strict_matrix&lt; Eigen::Matrix&lt; S, rows, cols, options, maxrows, maxcols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___to_euclidean_expr.html">is_ToEuclideanExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is___to_euclidean_expr_3_01_to_euclidean_expr_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_ToEuclideanExpr&lt; ToEuclideanExpr&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__triangular.html">is_triangular</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix.html">is_typed_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a typed matrix (i.e., <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a>, <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="A typed vector.">EuclideanMean</a>, or <a class="el" href="struct_open_kalman_1_1_typed_matrix.html" title="A typed matrix.">TypedMatrix</a>).  <a href="struct_open_kalman_1_1is__typed__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix_3_01_euclidean_mean_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_typed_matrix&lt; EuclideanMean&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix_3_01_mean_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_typed_matrix&lt; Mean&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix_3_01_typed_matrix_3_01_row_coefficients_00_01_column_coe57cfc14356e856f7ba37d47aa843221b.html">is_typed_matrix&lt; TypedMatrix&lt; RowCoefficients, ColumnCoefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix__base.html">is_typed_matrix_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a base for a typed matrix.  <a href="struct_open_kalman_1_1is__typed__matrix__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix__base_3_01_eigen_diagonal_3_01_base_matrix_01_4_01_4.html">is_typed_matrix_base&lt; EigenDiagonal&lt; BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix__base_3_01_eigen_self_adjoint_matrix_3_01_base_matrix_00_01storage__triangle_01_4_01_4.html">is_typed_matrix_base&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix__base_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01triangle__type_01_4_01_4.html">is_typed_matrix_base&lt; EigenTriangularMatrix&lt; BaseMatrix, triangle_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix__base_3_01_eigen_zero_3_01_base_matrix_01_4_01_4.html">is_typed_matrix_base&lt; EigenZero&lt; BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix__base_3_01_from_euclidean_expr_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_typed_matrix_base&lt; FromEuclideanExpr&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix__base_3_01_t_00_01std_1_1enable__if__t_3_01is__native___d56e0bed572a34947125fc51a6f3b47e.html">is_typed_matrix_base&lt; T, std::enable_if_t&lt; is_native_Eigen_type_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__typed__matrix__base_3_01_to_euclidean_expr_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_typed_matrix_base&lt; ToEuclideanExpr&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__upper__triangular.html">is_upper_triangular</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is an upper triangular matrix.  <a href="struct_open_kalman_1_1is__upper__triangular.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__upper__triangular_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01_1d87deb9b60a7ad4034ee2adf65c752d.html">is_upper_triangular&lt; EigenTriangularMatrix&lt; BaseMatrix, TriangleType::upper &gt;, std::enable_if_t&lt; not is_diagonal_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__upper__triangular_3_01_square_root_covariance_3_01_coefficients_00_01_1559a6dc0a3abad6454ac234a34e8111.html">is_upper_triangular&lt; SquareRootCovariance&lt; Coefficients, BaseMatrix &gt;, std::enable_if_t&lt; not is_diagonal_v&lt; BaseMatrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__upper__triangular_3_01_t_00_01std_1_1enable__if__t_3_01is__diagonal__v_3_01_t_01_4_01_4_01_4.html">is_upper_triangular&lt; T, std::enable_if_t&lt; is_diagonal_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal matrices are upper-triangular.  <a href="struct_open_kalman_1_1is__upper__triangular_3_01_t_00_01std_1_1enable__if__t_3_01is__diagonal__v_3_01_t_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__wrapped.html">is_wrapped</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the matrix is wrapped.  <a href="struct_open_kalman_1_1is__wrapped.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__wrapped_3_01_t_00_01std_1_1enable__if__t_3_01is__mean__v_3_01_t_01_4_01_4_01_4.html">is_wrapped&lt; T, std::enable_if_t&lt; is_mean_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a> is wrapped unless the coefficients are Axes only.  <a href="struct_open_kalman_1_1is__wrapped_3_01_t_00_01std_1_1enable__if__t_3_01is__mean__v_3_01_t_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero.html">is_zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a diagonal matrix.  <a href="struct_open_kalman_1_1is__zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_covariance_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_zero&lt; Covariance&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_eigen_1_1_cwise_binary_op_3_01_eigen_1_1internal_1_1scalar__6dc79861666907f9186f800e4cc21252.html">is_zero&lt; Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_difference_op&lt; typename Arg1::Scalar, typename Arg2::Scalar &gt;, Arg1, Arg2 &gt;, std::enable_if_t&lt;(is_zero_v&lt; Arg1 &gt; and is_zero_v&lt; Arg2 &gt;) or(is_identity_v&lt; Arg1 &gt; and is_identity_v&lt; Arg2 &gt;)&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_eigen_1_1_cwise_binary_op_3_01_eigen_1_1internal_1_1scalar__d5936b11bd105931db1976a3d4cab6a7.html">is_zero&lt; Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_product_op&lt; typename Arg1::Scalar, typename Arg2::Scalar &gt;, Arg1, Arg2 &gt;, std::enable_if_t&lt; is_zero_v&lt; Arg1 &gt; or is_zero_v&lt; Arg2 &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_eigen_1_1_cwise_binary_op_3_01_eigen_1_1internal_1_1scalar__f614625c035c29468b2bbd90ed568c81.html">is_zero&lt; Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_sum_op&lt; typename Arg1::Scalar, typename Arg2::Scalar &gt;, Arg1, Arg2 &gt;, std::enable_if_t&lt; is_zero_v&lt; Arg1 &gt; and is_zero_v&lt; Arg2 &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_eigen_1_1_cwise_unary_op_3_01_eigen_1_1internal_1_1scalar__od401397b92c25d1d7f64e03677f4e08c.html">is_zero&lt; Eigen::CwiseUnaryOp&lt; Eigen::internal::scalar_opposite_op&lt; typename Arg::Scalar &gt;, Arg &gt;, std::enable_if_t&lt; is_zero_v&lt; Arg &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_eigen_1_1_product_3_01_arg1_00_01_arg2_01_4_00_01std_1_1enab4133b1273327fd5aac6d2938d80f5333.html">is_zero&lt; Eigen::Product&lt; Arg1, Arg2 &gt;, std::enable_if_t&lt; is_zero_v&lt; Arg1 &gt; or is_zero_v&lt; Arg2 &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_eigen_diagonal_3_01_base_matrix_01_4_01_4.html">is_zero&lt; EigenDiagonal&lt; BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_eigen_self_adjoint_matrix_3_01_base_matrix_00_01storage__triangle_01_4_01_4.html">is_zero&lt; EigenSelfAdjointMatrix&lt; BaseMatrix, storage_triangle &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_eigen_triangular_matrix_3_01_base_matrix_00_01triangle__type_01_4_01_4.html">is_zero&lt; EigenTriangularMatrix&lt; BaseMatrix, triangle_type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_eigen_zero_3_01_base_matrix_01_4_01_4.html">is_zero&lt; EigenZero&lt; BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_euclidean_mean_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_zero&lt; EuclideanMean&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_gaussian_distribution_3_01_coefficients_00_01_mean_matrix_00ebc8dddb55fc3e729408cc470c0cb6a5.html">is_zero&lt; GaussianDistribution&lt; Coefficients, MeanMatrix, CovarianceMatrix, re &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_mean_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_zero&lt; Mean&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_square_root_covariance_3_01_coefficients_00_01_base_matrix_01_4_01_4.html">is_zero&lt; SquareRootCovariance&lt; Coefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__zero_3_01_typed_matrix_3_01_row_coefficients_00_01_column_coefficients_00_01_base_matrix_01_4_01_4.html">is_zero&lt; TypedMatrix&lt; RowCoefficients, ColumnCoefficients, BaseMatrix &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_kalman_filter.html">KalmanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using one or more statistical transforms.  <a href="struct_open_kalman_1_1_kalman_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_kalman_filter_3_01_process_transform_00_01_measurement_transform_01_4.html">KalmanFilter&lt; ProcessTransform, MeasurementTransform &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using a different statistical transform for the process and the measurement.  <a href="struct_open_kalman_1_1_kalman_filter_3_01_process_transform_00_01_measurement_transform_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_kalman_filter_3_01_transform_01_4.html">KalmanFilter&lt; Transform &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using the same transform for the process and the measurement.  <a href="struct_open_kalman_1_1_kalman_filter_3_01_transform_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_linearized_transform.html">LinearizedTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linearized transform, using a 1st or 2nd order Taylor approximation of a linear transformation.  <a href="struct_open_kalman_1_1_linearized_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_linear_transform.html">LinearTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear transformation from one statistical distribution to another.  <a href="struct_open_kalman_1_1_linear_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_linear_transformation.html">LinearTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear transformation from one single-column vector to another.  <a href="struct_open_kalman_1_1_linear_transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01const_01_v_01_4.html">MatrixTraits&lt; const V &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="struct_open_kalman_1_1_matrix_traits_3_01const_01_v_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_eigen_diagonal_3_01_arg_type_01_4_01_4.html">MatrixTraits&lt; EigenDiagonal&lt; ArgType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_eigen_self_adjoint_matrix_3_01_arg_type_00_01storage__triangle_01_4_01_4.html">MatrixTraits&lt; EigenSelfAdjointMatrix&lt; ArgType, storage_triangle &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_eigen_zero_3_01_v_01_4_01_4.html">MatrixTraits&lt; EigenZero&lt; V &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_euclidean_mean_3_01_coeffs_00_01_nested_type_01_4_01_4.html">MatrixTraits&lt; EuclideanMean&lt; Coeffs, NestedType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_from_euclidean_expr_3_01_coeffs_00_01_arg_type_01_4_01_4.html">MatrixTraits&lt; FromEuclideanExpr&lt; Coeffs, ArgType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define matrix traits.  <a href="struct_open_kalman_1_1_matrix_traits_3_01_from_euclidean_expr_3_01_coeffs_00_01_arg_type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_matrix_00_01std_1_1enable__if__t_3_01std_1_1is__same__944a322a5b62d8ca10a3f21630d4c69e.html">MatrixTraits&lt; Matrix, std::enable_if_t&lt; std::is_same_v&lt; Matrix, std::decay_t&lt; Matrix &gt; &gt; and is_native_Eigen_type_v&lt; Matrix &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_mean_3_01_coeffs_00_01_nested_type_01_4_01_4.html">MatrixTraits&lt; Mean&lt; Coeffs, NestedType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_open_kalman_1_1_eigen_triangular_matrix_3_01_arg_type_00_01triangle_01_4_01_4.html">MatrixTraits&lt; OpenKalman::EigenTriangularMatrix&lt; ArgType, triangle &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_open_kalman_1_1_typed_matrix_3_01_row_coeffs_00_01_colb1ee78fd091c2934005ae8d1dfa4cf1e.html">MatrixTraits&lt; OpenKalman::TypedMatrix&lt; RowCoeffs, ColCoeffs, NestedType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a> for <a class="el" href="struct_open_kalman_1_1_typed_matrix.html" title="A typed matrix.">TypedMatrix</a>.  <a href="struct_open_kalman_1_1_matrix_traits_3_01_open_kalman_1_1_typed_matrix_3_01_row_coeffs_00_01_colb1ee78fd091c2934005ae8d1dfa4cf1e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_to_euclidean_expr_3_01_coeffs_00_01_arg_type_01_4_01_4.html">MatrixTraits&lt; ToEuclideanExpr&lt; Coeffs, ArgType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define matrix traits.  <a href="struct_open_kalman_1_1_matrix_traits_3_01_to_euclidean_expr_3_01_coeffs_00_01_arg_type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_v_01_6_01_4.html">MatrixTraits&lt; V &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="struct_open_kalman_1_1_matrix_traits_3_01_v_01_6_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits_3_01_v_01_6_6_01_4.html">MatrixTraits&lt; V &amp;&amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  <a href="struct_open_kalman_1_1_matrix_traits_3_01_v_01_6_6_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typed vector.  <a href="struct_open_kalman_1_1_mean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_mixture_of_continuous_distributions.html">MixtureOfContinuousDistributions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_monte_carlo_transform.html">MonteCarloTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Monte Carlo transform from one Gaussian distribution to another. Uses ideas from Chan, Tony F.; Golub, Gene H.; LeVeque, Randall J. (1979), "Updating Formulae and a Pairwise Algorithm for Computing Sample Variances." Technical Report STAN-CS-79-773, Department of Computer Science, Stanford University. <a href="http://i.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf">http://i.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf</a>.  <a href="struct_open_kalman_1_1_monte_carlo_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_particle_distribution.html">ParticleDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribution of particles.  <a href="struct_open_kalman_1_1_particle_distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_particle_filter.html">ParticleFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_polar.html">Polar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_polar_3_01_circle_3_01_traits_01_4_00_01_distance_01_4.html">Polar&lt; Circle&lt; Traits &gt;, Distance &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_polar.html">Polar</a> coordinates (Angle, Radius).  <a href="struct_open_kalman_1_1_polar_3_01_circle_3_01_traits_01_4_00_01_distance_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_polar_3_01_distance_00_01_circle_3_01_traits_01_4_01_4.html">Polar&lt; Distance, Circle&lt; Traits &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_polar.html">Polar</a> coordinates (Radius, Angle).  <a href="struct_open_kalman_1_1_polar_3_01_distance_00_01_circle_3_01_traits_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_recursive_least_squares_transform.html">RecursiveLeastSquaresTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates a recursive least squares error distribution of parameters, with a forgetting factor . Useful for parameter estimation, where the parameter is expected to possibly drift over time.  <a href="struct_open_kalman_1_1_recursive_least_squares_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_sample_points_transform.html">SamplePointsTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled points transform. Compatible with unscented transform and cubature transform. As implemented in, e.g., E. Wan &amp; R. van der Merwe, "The unscented Kalman filter for nonlinear estimation," in Proc. of IEEE Symposium (AS-SPCC), pp. 153-158. See also R. van der Merwe &amp; E. Wan, "The Square-Root <a class="el" href="struct_open_kalman_1_1_unscented.html">Unscented</a> Kalman Filter for State and Parameter-Estimation in Proc. Acoustics, Speech, and Signal Processing (ICASSP'01), 2001, pp. 3461-64.  <a href="struct_open_kalman_1_1_sample_points_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_sigma_points.html">SigmaPoints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_spherical.html">Spherical</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_circle_3_01_traits1_01_4_00_01_open_kalman3f738beff7f70f07fbd0ba114750eccb.html">Spherical&lt; OpenKalman::Circle&lt; Traits1 &gt;, OpenKalman::Distance, OpenKalman::Inclination&lt; Traits2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_spherical.html">Spherical</a> coordinates (Angle, Radius, <a class="el" href="struct_open_kalman_1_1_inclination.html">Inclination</a>).  <a href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_circle_3_01_traits1_01_4_00_01_open_kalman3f738beff7f70f07fbd0ba114750eccb.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_circle_3_01_traits1_01_4_00_01_open_kalmanadd2f686585e626d75cb31eddffd30af.html">Spherical&lt; OpenKalman::Circle&lt; Traits1 &gt;, OpenKalman::Inclination&lt; Traits2 &gt;, OpenKalman::Distance &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_spherical.html">Spherical</a> coordinates (Angle, <a class="el" href="struct_open_kalman_1_1_inclination.html">Inclination</a>, Radius).  <a href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_circle_3_01_traits1_01_4_00_01_open_kalmanadd2f686585e626d75cb31eddffd30af.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_distance_00_01_open_kalman_1_1_circle_3_01c7ac4ff1b0a2dec6ea0d002f397677d6.html">Spherical&lt; OpenKalman::Distance, OpenKalman::Circle&lt; Traits1 &gt;, OpenKalman::Inclination&lt; Traits2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_spherical.html">Spherical</a> coordinates (Radius, Angle, <a class="el" href="struct_open_kalman_1_1_inclination.html">Inclination</a>).  <a href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_distance_00_01_open_kalman_1_1_circle_3_01c7ac4ff1b0a2dec6ea0d002f397677d6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_distance_00_01_open_kalman_1_1_inclination82543b8825d3ed49ccb71173c7d39f5c.html">Spherical&lt; OpenKalman::Distance, OpenKalman::Inclination&lt; Traits1 &gt;, OpenKalman::Circle&lt; Traits2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_spherical.html">Spherical</a> coordinates (Radius, <a class="el" href="struct_open_kalman_1_1_inclination.html">Inclination</a>, Angle).  <a href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_distance_00_01_open_kalman_1_1_inclination82543b8825d3ed49ccb71173c7d39f5c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_inclination_3_01_traits1_01_4_00_01_open_k1bc57d0441fa50d47ceb778fe6e53472.html">Spherical&lt; OpenKalman::Inclination&lt; Traits1 &gt;, OpenKalman::Circle&lt; Traits2 &gt;, OpenKalman::Distance &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_spherical.html">Spherical</a> coordinates (<a class="el" href="struct_open_kalman_1_1_inclination.html">Inclination</a>, Angle, Radius).  <a href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_inclination_3_01_traits1_01_4_00_01_open_k1bc57d0441fa50d47ceb778fe6e53472.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_inclination_3_01_traits1_01_4_00_01_open_k83f46481513fc64ca074048e1298d3f9.html">Spherical&lt; OpenKalman::Inclination&lt; Traits1 &gt;, OpenKalman::Distance, OpenKalman::Circle&lt; Traits2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_spherical.html">Spherical</a> coordinates (<a class="el" href="struct_open_kalman_1_1_inclination.html">Inclination</a>, Radius, Angle).  <a href="struct_open_kalman_1_1_spherical_3_01_open_kalman_1_1_inclination_3_01_traits1_01_4_00_01_open_k83f46481513fc64ca074048e1298d3f9.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_spherical_simplex.html">SphericalSimplex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_spherical_simplex_parameters.html">SphericalSimplexParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_square_root_covariance.html">SquareRootCovariance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a>, S*S.transpose() is a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a>.  <a href="struct_open_kalman_1_1_square_root_covariance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_to_euclidean_expr.html">ToEuclideanExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nested, non-Euclidean matrix.  <a href="struct_open_kalman_1_1_to_euclidean_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_transformation.html">Transformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transformation from one single-column vector to another.  <a href="struct_open_kalman_1_1_transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_transformation_3_01_func_01_4.html">Transformation&lt; Func &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_transformation_3_01_function_00_01_jacobian_func_01_4.html">Transformation&lt; Function, JacobianFunc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_transformation_3_01_function_00_01_jacobian_function_00_01_hessian_func_01_4.html">Transformation&lt; Function, JacobianFunction, HessianFunc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_transform_base.html">TransformBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base for all transforms.  <a href="struct_open_kalman_1_1_transform_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1triangle__type__of.html">triangle_type_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive TriangleType from type traits.  <a href="struct_open_kalman_1_1triangle__type__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1triangle__type__of_3_01_t_00_01std_1_1enable__if__t_3_01is__diagonal__v_3_01_t_01_4_01_4_01_4.html">triangle_type_of&lt; T, std::enable_if_t&lt; is_diagonal_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1triangle__type__of_3_01_t_00_01std_1_1enable__if__t_3_01is__lower__triangu24303d68ce8f83c843d0e939a3443038.html">triangle_type_of&lt; T, std::enable_if_t&lt; is_lower_triangular_v&lt; T &gt; and not is_diagonal_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1triangle__type__of_3_01_t_00_01std_1_1enable__if__t_3_01is__upper__triangu47f48c50a9bce83932c10a59d886861e.html">triangle_type_of&lt; T, std::enable_if_t&lt; is_upper_triangular_v&lt; T &gt; and not is_diagonal_v&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_typed_matrix.html">TypedMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typed matrix.  <a href="struct_open_kalman_1_1_typed_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_unit_wrap_traits.html">UnitWrapTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_unscented.html">Unscented</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_unscented_parameters_parameter_estimation.html">UnscentedParametersParameterEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_unscented.html">Unscented</a> parameters for use in parameter estimation.  <a href="struct_open_kalman_1_1_unscented_parameters_parameter_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_unscented_parameters_state_estimation.html">UnscentedParametersStateEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_open_kalman_1_1_unscented.html">Unscented</a> parameters for use in state estimation (the default).  <a href="struct_open_kalman_1_1_unscented_parameters_state_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_weighted_particle_distribution.html">WeightedParticleDistribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a322bd5c1958f6977b8627bceb8d6ba18"><td class="memItemLeft" align="right" valign="top"><a id="a322bd5c1958f6977b8627bceb8d6ba18"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CubatureTransform</b> = <a class="el" href="struct_open_kalman_1_1_sample_points_transform.html">SamplePointsTransform</a>&lt; <a class="el" href="struct_open_kalman_1_1_cubature_points.html">CubaturePoints</a> &gt;</td></tr>
<tr class="separator:a322bd5c1958f6977b8627bceb8d6ba18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb3984e6d92af7ead25a90f38f1d48d"><td class="memItemLeft" align="right" valign="top"><a id="aecb3984e6d92af7ead25a90f38f1d48d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UnscentedTransform</b> = <a class="el" href="struct_open_kalman_1_1_sample_points_transform.html">SamplePointsTransform</a>&lt; <a class="el" href="namespace_open_kalman.html#a8b0239f8b1168cde423e125102a257b3">UnscentedSigmaPoints</a> &gt;</td></tr>
<tr class="separator:aecb3984e6d92af7ead25a90f38f1d48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5313251ad9dffa61e697a4bd2cfc3b6"><td class="memItemLeft" align="right" valign="top"><a id="ad5313251ad9dffa61e697a4bd2cfc3b6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UnscentedTransformParameterEstimation</b> = <a class="el" href="struct_open_kalman_1_1_sample_points_transform.html">SamplePointsTransform</a>&lt; <a class="el" href="struct_open_kalman_1_1_sigma_points.html">UnscentedSigmaPointsParameterEstimation</a> &gt;</td></tr>
<tr class="separator:ad5313251ad9dffa61e697a4bd2cfc3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4e48c14c18eb62b99c005ae82255be"><td class="memItemLeft" align="right" valign="top"><a id="a7b4e48c14c18eb62b99c005ae82255be"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UnscentedSigmaPointsStateEstimation</b> = <a class="el" href="struct_open_kalman_1_1_sigma_points.html">SigmaPoints</a>&lt; <a class="el" href="struct_open_kalman_1_1_unscented.html">Unscented</a>&lt; <a class="el" href="struct_open_kalman_1_1_unscented_parameters_state_estimation.html">UnscentedParametersStateEstimation</a> &gt; &gt;</td></tr>
<tr class="separator:a7b4e48c14c18eb62b99c005ae82255be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bfcd723cacf106eeedb5b242a3c425"><td class="memItemLeft" align="right" valign="top"><a id="ac8bfcd723cacf106eeedb5b242a3c425"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UnscentedSigmaPointsParameterEstimation</b> = <a class="el" href="struct_open_kalman_1_1_sigma_points.html">SigmaPoints</a>&lt; <a class="el" href="struct_open_kalman_1_1_unscented.html">Unscented</a>&lt; <a class="el" href="struct_open_kalman_1_1_unscented_parameters_parameter_estimation.html">UnscentedParametersParameterEstimation</a> &gt; &gt;</td></tr>
<tr class="separator:ac8bfcd723cacf106eeedb5b242a3c425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0239f8b1168cde423e125102a257b3"><td class="memItemLeft" align="right" valign="top"><a id="a8b0239f8b1168cde423e125102a257b3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a8b0239f8b1168cde423e125102a257b3">UnscentedSigmaPoints</a> = <a class="el" href="struct_open_kalman_1_1_sigma_points.html">SigmaPoints</a>&lt; <a class="el" href="struct_open_kalman_1_1_unscented.html">Unscented</a>&lt;&gt; &gt;</td></tr>
<tr class="memdesc:a8b0239f8b1168cde423e125102a257b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as UnscentedSigmaPointsStateEstimation. <br /></td></tr>
<tr class="separator:a8b0239f8b1168cde423e125102a257b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4573e83439df0815982003e65a6413fb"><td class="memItemLeft" align="right" valign="top"><a id="a4573e83439df0815982003e65a6413fb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SphericalSimplexSigmaPoints</b> = <a class="el" href="struct_open_kalman_1_1_sigma_points.html">SigmaPoints</a>&lt; <a class="el" href="struct_open_kalman_1_1_spherical_simplex.html">SphericalSimplex</a>&lt;&gt; &gt;</td></tr>
<tr class="separator:a4573e83439df0815982003e65a6413fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a86c475a693e41193b426f2f36eaef"><td class="memItemLeft" align="right" valign="top"><a id="ae4a86c475a693e41193b426f2f36eaef"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Angle</b> = <a class="el" href="struct_open_kalman_1_1_circle.html">Circle</a>&lt; <a class="el" href="struct_open_kalman_1_1_angle_traits.html">AngleTraits</a> &gt;</td></tr>
<tr class="separator:ae4a86c475a693e41193b426f2f36eaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63fb5300806d7be27f3253dc3cc441a"><td class="memItemLeft" align="right" valign="top"><a id="af63fb5300806d7be27f3253dc3cc441a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AnglePositiveRadians</b> = <a class="el" href="struct_open_kalman_1_1_circle.html">Circle</a>&lt; <a class="el" href="struct_open_kalman_1_1_angle_positive_radians_traits.html">AnglePositiveRadiansTraits</a> &gt;</td></tr>
<tr class="separator:af63fb5300806d7be27f3253dc3cc441a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc17073d1ee5134980087f7264e0d5d2"><td class="memItemLeft" align="right" valign="top"><a id="afc17073d1ee5134980087f7264e0d5d2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AngleDegrees</b> = <a class="el" href="struct_open_kalman_1_1_circle.html">Circle</a>&lt; <a class="el" href="struct_open_kalman_1_1_angle_degrees_traits.html">AngleDegreesTraits</a> &gt;</td></tr>
<tr class="separator:afc17073d1ee5134980087f7264e0d5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0cfbca8631bcc99f5ad0b6f6eb6ff8c"><td class="memItemLeft" align="right" valign="top"><a id="aa0cfbca8631bcc99f5ad0b6f6eb6ff8c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UnitWrap</b> = <a class="el" href="struct_open_kalman_1_1_circle.html">Circle</a>&lt; <a class="el" href="struct_open_kalman_1_1_unit_wrap_traits.html">UnitWrapTraits</a> &gt;</td></tr>
<tr class="separator:aa0cfbca8631bcc99f5ad0b6f6eb6ff8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66c8a3d2e7e2449a727d370262995ef"><td class="memTemplParams" colspan="2">template&lt;typename C , std::size_t N&gt; </td></tr>
<tr class="memitem:ac66c8a3d2e7e2449a727d370262995ef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">Replicate</a> = typename <a class="el" href="struct_open_kalman_1_1detail_1_1_replicate_impl.html">detail::ReplicateImpl</a>&lt; C, N &gt;::type</td></tr>
<tr class="memdesc:ac66c8a3d2e7e2449a727d370262995ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Coefficients&lt;...&gt; alias in which the coefficients are C repeated N times.  <a href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">More...</a><br /></td></tr>
<tr class="separator:ac66c8a3d2e7e2449a727d370262995ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fbe21f478b7b06ac97b6eb6f5967c3"><td class="memTemplParams" colspan="2">template&lt;std::size_t size&gt; </td></tr>
<tr class="memitem:ad7fbe21f478b7b06ac97b6eb6f5967c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a> = <a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">Replicate</a>&lt; <a class="el" href="struct_open_kalman_1_1_axis.html">Axis</a>, size &gt;</td></tr>
<tr class="separator:ad7fbe21f478b7b06ac97b6eb6f5967c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee988c44ff204b5e46229d06480cba27"><td class="memItemLeft" align="right" valign="top"><a id="aee988c44ff204b5e46229d06480cba27"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>InclinationAngle</b> = <a class="el" href="struct_open_kalman_1_1_inclination.html">Inclination</a>&lt;&gt;</td></tr>
<tr class="separator:aee988c44ff204b5e46229d06480cba27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4b32a1555bfca1450b46b2d7690a0b"><td class="memTemplParams" colspan="2"><a id="a1d4b32a1555bfca1450b46b2d7690a0b"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a1d4b32a1555bfca1450b46b2d7690a0b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenIdentity</b> = Eigen::CwiseNullaryOp&lt; Eigen::internal::scalar_identity_op&lt; typename Arg::Scalar &gt;, Arg &gt;</td></tr>
<tr class="separator:a1d4b32a1555bfca1450b46b2d7690a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82c5198d9b9be12ab96f47ad0177181"><td class="memTemplParams" colspan="2"><a id="ae82c5198d9b9be12ab96f47ad0177181"></a>
template&lt;typename ... Coeffs&gt; </td></tr>
<tr class="memitem:ae82c5198d9b9be12ab96f47ad0177181"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae82c5198d9b9be12ab96f47ad0177181">Concatenate</a> = typename <a class="el" href="struct_open_kalman_1_1internal_1_1_concatenate_impl.html">internal::ConcatenateImpl</a>&lt; Coeffs... &gt;::type</td></tr>
<tr class="memdesc:ae82c5198d9b9be12ab96f47ad0177181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate any number of Coefficients&lt;...&gt; types. <br /></td></tr>
<tr class="separator:ae82c5198d9b9be12ab96f47ad0177181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195dba7167762f197716da85896f30c8"><td class="memTemplParams" colspan="2"><a id="a195dba7167762f197716da85896f30c8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a195dba7167762f197716da85896f30c8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strict_t</b> = std::conditional_t&lt; <a class="el" href="namespace_open_kalman.html#a8ca46d6e07743852f26de9ae2c12c579">is_strict_v</a>&lt; T &gt;, std::decay_t&lt; T &gt;, typename <a class="el" href="struct_open_kalman_1_1detail_1_1strict__impl.html">detail::strict_impl</a>&lt; T &gt;::type &gt;</td></tr>
<tr class="separator:a195dba7167762f197716da85896f30c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f06260c391ec78baa024610ccac1f21"><td class="memTemplParams" colspan="2"><a id="a8f06260c391ec78baa024610ccac1f21"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f06260c391ec78baa024610ccac1f21"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lvalue_or_strict_t</b> = std::conditional_t&lt; std::is_lvalue_reference_v&lt; T &gt;, std::decay_t&lt; T &gt;, strict_t&lt; T &gt; &gt;</td></tr>
<tr class="separator:a8f06260c391ec78baa024610ccac1f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd4696ba3eaa7b937937c1244a3f56f"><td class="memTemplParams" colspan="2"><a id="a4bd4696ba3eaa7b937937c1244a3f56f"></a>
template&lt;typename T , std::size_t rows = MatrixTraits&lt;T&gt;::dimension, std::size_t cols = MatrixTraits&lt;T&gt;::columns&gt; </td></tr>
<tr class="memitem:a4bd4696ba3eaa7b937937c1244a3f56f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>strict_matrix_t</b> = typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; T &gt;::template StrictMatrix&lt; rows, cols &gt;</td></tr>
<tr class="separator:a4bd4696ba3eaa7b937937c1244a3f56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab6c606169452d88f33b64e3b1ae18fa2"><td class="memItemLeft" align="right" valign="top"><a id="ab6c606169452d88f33b64e3b1ae18fa2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TriangleType</b> { <b>lower</b>, 
<b>upper</b>, 
<b>diagonal</b>
 }</td></tr>
<tr class="separator:ab6c606169452d88f33b64e3b1ae18fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9c0f47fae65bcb5d829cf317873d1497"><td class="memTemplParams" colspan="2"><a id="a9c0f47fae65bcb5d829cf317873d1497"></a>
template&lt;typename D , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; D &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9c0f47fae65bcb5d829cf317873d1497"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GaussianDistribution</b> (D &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_gaussian_distribution.html">GaussianDistribution</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_distribution_traits.html">DistributionTraits</a>&lt; D &gt;::<a class="el" href="struct_open_kalman_1_1_coefficients.html">Coefficients</a>, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_distribution_traits.html">DistributionTraits</a>&lt; D &gt;::<a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a> &gt;::BaseMatrix, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_distribution_traits.html">DistributionTraits</a>&lt; D &gt;::<a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a> &gt;::BaseMatrix &gt;</td></tr>
<tr class="separator:a9c0f47fae65bcb5d829cf317873d1497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2558a229a2cb5a29c559e011c9a99b4"><td class="memTemplParams" colspan="2"><a id="ae2558a229a2cb5a29c559e011c9a99b4"></a>
template&lt;typename M , typename C , std::enable_if_t&lt; is_typed_matrix_v&lt; M &gt; and is_covariance_v&lt; C &gt; and not is_square_root_v&lt; C &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae2558a229a2cb5a29c559e011c9a99b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GaussianDistribution</b> (M &amp;&amp;, C &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_gaussian_distribution.html">GaussianDistribution</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::RowCoefficients, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; lvalue_or_strict_t&lt; M &amp;&amp; &gt;&gt;::BaseMatrix, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; lvalue_or_strict_t&lt; C &amp;&amp; &gt;&gt;::BaseMatrix &gt;</td></tr>
<tr class="separator:ae2558a229a2cb5a29c559e011c9a99b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131455a38340a120002aca624717d3d4"><td class="memTemplParams" colspan="2"><a id="a131455a38340a120002aca624717d3d4"></a>
template&lt;typename D , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; D &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a131455a38340a120002aca624717d3d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a131455a38340a120002aca624717d3d4">make_GaussianDistribution</a> (D &amp;&amp;dist) noexcept</td></tr>
<tr class="memdesc:a131455a38340a120002aca624717d3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution from another Gaussian distribution. <br /></td></tr>
<tr class="separator:a131455a38340a120002aca624717d3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="memTemplParams" colspan="2"><a id="ac2d0c0d4d3f9bab0130dbcd6654617c0"></a>
template&lt;typename re  = std::mt19937, typename M , typename Cov , std::enable_if_t&lt; not is_coefficient_v&lt; re &gt; and(is_typed_matrix_v&lt; M &gt; or is_typed_matrix_base_v&lt; M &gt;) and(is_covariance_v&lt; Cov &gt; or is_covariance_base_v&lt; Cov &gt; or is_typed_matrix_v&lt; Cov &gt; or is_typed_matrix_base_v&lt; Cov &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac2d0c0d4d3f9bab0130dbcd6654617c0">make_GaussianDistribution</a> (M &amp;&amp;mean, Cov &amp;&amp;cov) noexcept</td></tr>
<tr class="memdesc:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution from a mean and a covariance. <br /></td></tr>
<tr class="separator:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f53ae8006d8068435df09f99c8baf0"><td class="memTemplParams" colspan="2"><a id="a87f53ae8006d8068435df09f99c8baf0"></a>
template&lt;typename Coefficients , typename re  = std::mt19937, typename M , typename Cov , std::enable_if_t&lt; is_coefficient_v&lt; Coefficients &gt; and is_typed_matrix_base_v&lt; M &gt; and(is_covariance_base_v&lt; Cov &gt; or is_typed_matrix_base_v&lt; Cov &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a87f53ae8006d8068435df09f99c8baf0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a87f53ae8006d8068435df09f99c8baf0">make_GaussianDistribution</a> (M &amp;&amp;mean, Cov &amp;&amp;cov) noexcept</td></tr>
<tr class="memdesc:a87f53ae8006d8068435df09f99c8baf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution from a typed matrix base and a covariance base or regular matrix for the covariance. <br /></td></tr>
<tr class="separator:a87f53ae8006d8068435df09f99c8baf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a419b046972de2b566cc220dcae618"><td class="memTemplParams" colspan="2"><a id="a30a419b046972de2b566cc220dcae618"></a>
template&lt;typename M , typename Cov , typename re  = std::mt19937, std::enable_if_t&lt;(is_typed_matrix_v&lt; M &gt; or is_typed_matrix_base_v&lt; M &gt;) and(is_covariance_v&lt; Cov &gt; or is_covariance_base_v&lt; Cov &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a30a419b046972de2b566cc220dcae618"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a30a419b046972de2b566cc220dcae618">make_GaussianDistribution</a> ()</td></tr>
<tr class="memdesc:a30a419b046972de2b566cc220dcae618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default Gaussian distribution from a typed matrix (or typed matrix base) and a covariance (or covariance base). <br /></td></tr>
<tr class="separator:a30a419b046972de2b566cc220dcae618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c01a83c83d3a23aafb59dcd527daed1"><td class="memTemplParams" colspan="2"><a id="a8c01a83c83d3a23aafb59dcd527daed1"></a>
template&lt;typename Coefficients , typename M , typename Cov , typename re  = std::mt19937, std::enable_if_t&lt; is_typed_matrix_base_v&lt; M &gt; and is_covariance_base_v&lt; Cov &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8c01a83c83d3a23aafb59dcd527daed1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a8c01a83c83d3a23aafb59dcd527daed1">make_GaussianDistribution</a> ()</td></tr>
<tr class="memdesc:a8c01a83c83d3a23aafb59dcd527daed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default Gaussian distribution from a typed matrix base and a covariance base or regular matrix for the covariance. <br /></td></tr>
<tr class="separator:a8c01a83c83d3a23aafb59dcd527daed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06416145fb07066d8620327b26da68a1"><td class="memTemplParams" colspan="2"><a id="a06416145fb07066d8620327b26da68a1"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a06416145fb07066d8620327b26da68a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mean</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a06416145fb07066d8620327b26da68a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55818aac415b765460df8ed27ed0d984"><td class="memTemplParams" colspan="2"><a id="a55818aac415b765460df8ed27ed0d984"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a55818aac415b765460df8ed27ed0d984"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>covariance</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a55818aac415b765460df8ed27ed0d984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0641e84ff6f6105215fe70acc0896277"><td class="memTemplParams" colspan="2"><a id="a0641e84ff6f6105215fe70acc0896277"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Arg &gt; and not is_Cholesky_v&lt; Arg &gt; and not is_diagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0641e84ff6f6105215fe70acc0896277"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_Cholesky</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a0641e84ff6f6105215fe70acc0896277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c544e1f5e268ea657d3895746468c91"><td class="memTemplParams" colspan="2"><a id="a6c544e1f5e268ea657d3895746468c91"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Arg &gt; and is_Cholesky_v&lt; Arg &gt; and not is_diagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6c544e1f5e268ea657d3895746468c91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_Cholesky</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a6c544e1f5e268ea657d3895746468c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd8f48a0e8423e7f1db724d834e5375"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0fd8f48a0e8423e7f1db724d834e5375"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0fd8f48a0e8423e7f1db724d834e5375">strict</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a0fd8f48a0e8423e7f1db724d834e5375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to strict version of the distribution.  <a href="namespace_open_kalman.html#a0fd8f48a0e8423e7f1db724d834e5375">More...</a><br /></td></tr>
<tr class="separator:a0fd8f48a0e8423e7f1db724d834e5375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f06f7fc72648cedfd49327fa17ac75"><td class="memTemplParams" colspan="2"><a id="a20f06f7fc72648cedfd49327fa17ac75"></a>
template&lt;typename D , typename ... Ds, std::enable_if_t&lt; std::conjunction_v&lt; is_Gaussian_distribution&lt; D &gt;, is_Gaussian_distribution&lt; Ds &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a20f06f7fc72648cedfd49327fa17ac75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>concatenate</b> (const D &amp;d, const Ds &amp;... ds)</td></tr>
<tr class="separator:a20f06f7fc72648cedfd49327fa17ac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="memTemplParams" colspan="2"><a id="a6656a830ae8f0446ec8f3bfe5159a90f"></a>
template&lt;typename ... Cs, typename D , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; D &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6656a830ae8f0446ec8f3bfe5159a90f">split</a> (D &amp;&amp;d) noexcept</td></tr>
<tr class="memdesc:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split distribution. <br /></td></tr>
<tr class="separator:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b12ec95de2bc68ab2b3115873d36e6"><td class="memTemplParams" colspan="2"><a id="a74b12ec95de2bc68ab2b3115873d36e6"></a>
template&lt;typename Dist , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Dist &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a74b12ec95de2bc68ab2b3115873d36e6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const Dist &amp;d)</td></tr>
<tr class="separator:a74b12ec95de2bc68ab2b3115873d36e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189f804de633e1696b5ea798571632c6"><td class="memTemplParams" colspan="2"><a id="a189f804de633e1696b5ea798571632c6"></a>
template&lt;typename Dist1 , typename Dist2 , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Dist1 &gt; and is_Gaussian_distribution_v&lt; Dist2 &gt; and is_equivalent_v&lt; typename DistributionTraits&lt; Dist1 &gt;::Coefficients, typename DistributionTraits&lt; Dist2 &gt;::Coefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a189f804de633e1696b5ea798571632c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const Dist1 &amp;d1, const Dist2 &amp;d2)</td></tr>
<tr class="separator:a189f804de633e1696b5ea798571632c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708c180a99179c17769a15d282d4cf97"><td class="memTemplParams" colspan="2"><a id="a708c180a99179c17769a15d282d4cf97"></a>
template&lt;typename Dist1 , typename Dist2 , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Dist1 &gt; and is_Gaussian_distribution_v&lt; Dist2 &gt; and is_equivalent_v&lt; typename DistributionTraits&lt; Dist1 &gt;::Coefficients, typename DistributionTraits&lt; Dist2 &gt;::Coefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a708c180a99179c17769a15d282d4cf97"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const Dist1 &amp;d1, const Dist2 &amp;d2)</td></tr>
<tr class="separator:a708c180a99179c17769a15d282d4cf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3371aaf35876aee1bc583ef48d123617"><td class="memTemplParams" colspan="2"><a id="a3371aaf35876aee1bc583ef48d123617"></a>
template&lt;typename A , typename D , std::enable_if_t&lt; is_typed_matrix_v&lt; A &gt; and is_Gaussian_distribution_v&lt; D &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3371aaf35876aee1bc583ef48d123617"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const A &amp;a, const D &amp;d)</td></tr>
<tr class="separator:a3371aaf35876aee1bc583ef48d123617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf93273a761823f98487e018bf9cc55b"><td class="memTemplParams" colspan="2"><a id="aaf93273a761823f98487e018bf9cc55b"></a>
template&lt;typename Dist , typename S , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Dist &gt; and std::is_convertible_v&lt; S, typename DistributionTraits&lt; Dist &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aaf93273a761823f98487e018bf9cc55b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (Dist &amp;&amp;d, const S s)</td></tr>
<tr class="separator:aaf93273a761823f98487e018bf9cc55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3aa9d1579cf96946a65a7dfd9ad315"><td class="memTemplParams" colspan="2"><a id="a3a3aa9d1579cf96946a65a7dfd9ad315"></a>
template&lt;typename Dist , typename S , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Dist &gt; and std::is_convertible_v&lt; S, typename DistributionTraits&lt; Dist &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3a3aa9d1579cf96946a65a7dfd9ad315"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const S s, Dist &amp;&amp;d)</td></tr>
<tr class="separator:a3a3aa9d1579cf96946a65a7dfd9ad315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da67807e9ed9ade59482260747bc809"><td class="memTemplParams" colspan="2"><a id="a2da67807e9ed9ade59482260747bc809"></a>
template&lt;typename Dist , typename S , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Dist &gt; and std::is_convertible_v&lt; S, typename DistributionTraits&lt; Dist &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2da67807e9ed9ade59482260747bc809"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (Dist &amp;&amp;d, const S s)</td></tr>
<tr class="separator:a2da67807e9ed9ade59482260747bc809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6c1ea30e81f7795fcf0fd773807887"><td class="memTemplParams" colspan="2"><a id="aec6c1ea30e81f7795fcf0fd773807887"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:aec6c1ea30e81f7795fcf0fd773807887"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>KalmanFilter</b> (P &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_kalman_filter.html">KalmanFilter</a>&lt; P &gt;</td></tr>
<tr class="separator:aec6c1ea30e81f7795fcf0fd773807887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5203529b2d7c88e224b48a320bbc7e7b"><td class="memTemplParams" colspan="2"><a id="a5203529b2d7c88e224b48a320bbc7e7b"></a>
template&lt;typename P , typename M &gt; </td></tr>
<tr class="memitem:a5203529b2d7c88e224b48a320bbc7e7b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>KalmanFilter</b> (P &amp;&amp;, M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_kalman_filter.html">KalmanFilter</a>&lt; P, M &gt;</td></tr>
<tr class="separator:a5203529b2d7c88e224b48a320bbc7e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memTemplParams" colspan="2"><a id="a82c83df8efb22e49dd3e6f5ea119caef"></a>
template&lt;typename OutputCoefficients , typename In , typename ... Perturbations&gt; </td></tr>
<tr class="memitem:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a82c83df8efb22e49dd3e6f5ea119caef">zero_hessian</a> ()</td></tr>
<tr class="memdesc:a82c83df8efb22e49dd3e6f5ea119caef"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple of zero-filled arrays of Hessian matrices, based on the input and each perturbation term. <br /></td></tr>
<tr class="separator:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memTemplParams" colspan="2"><a id="ac32f98e2f9ea9d21f58ac57b49ee011e"></a>
template&lt;typename OutputCoefficients , typename In , typename ... Perturbations&gt; </td></tr>
<tr class="memitem:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac32f98e2f9ea9d21f58ac57b49ee011e">zero_hessian</a> (In &amp;&amp;, Perturbations &amp;&amp;...)</td></tr>
<tr class="memdesc:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple of zero-filled arrays of Hessian matrices, based on the input and each perturbation term. <br /></td></tr>
<tr class="separator:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9934a0fa27adfaf949d994695a13b6af"><td class="memTemplParams" colspan="2">template&lt;typename Trans , typename InDelta , typename ... PsDelta&gt; </td></tr>
<tr class="memitem:a9934a0fa27adfaf949d994695a13b6af"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a9934a0fa27adfaf949d994695a13b6af">FiniteDifferenceLinearization</a> (Trans &amp;&amp;, InDelta &amp;&amp;, PsDelta &amp;&amp;...) -&gt; <a class="el" href="struct_open_kalman_1_1_finite_difference_linearization.html">FiniteDifferenceLinearization</a>&lt; Trans, InDelta, PsDelta... &gt;</td></tr>
<tr class="separator:a9934a0fa27adfaf949d994695a13b6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc054fe071ff633de39c78cb306a8819"><td class="memTemplParams" colspan="2"><a id="adc054fe071ff633de39c78cb306a8819"></a>
template&lt;typename T , typename ... Ps, std::enable_if_t&lt; std::conjunction_v&lt; is_typed_matrix_base&lt; T &gt;, is_typed_matrix_base&lt; Ps &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adc054fe071ff633de39c78cb306a8819"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LinearTransformation</b> (T &amp;&amp;, Ps &amp;&amp;...) -&gt; <a class="el" href="struct_open_kalman_1_1_linear_transformation.html">LinearTransformation</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; T &gt;::columns &gt;, <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; T &gt;::dimension &gt;, strict_t&lt; std::decay_t&lt; T &gt;&gt;, strict_t&lt; std::decay_t&lt; Ps &gt;&gt;... &gt;</td></tr>
<tr class="separator:adc054fe071ff633de39c78cb306a8819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd655dfd0d89b3b12ece39ab953e061"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename... TaylorDerivatives&gt; </td></tr>
<tr class="memitem:abbd655dfd0d89b3b12ece39ab953e061"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#abbd655dfd0d89b3b12ece39ab953e061">Transformation</a> (Function &amp;&amp;, TaylorDerivatives &amp;&amp;...) -&gt; <a class="el" href="struct_open_kalman_1_1_transformation.html">Transformation</a>&lt; Function, TaylorDerivatives... &gt;</td></tr>
<tr class="separator:abbd655dfd0d89b3b12ece39ab953e061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98098102f472923f49b098c25d822621"><td class="memTemplParams" colspan="2"><a id="a98098102f472923f49b098c25d822621"></a>
template&lt;typename Function , std::enable_if_t&lt; is_linearized_function_v&lt; Function, 0 &gt; and not is_linearized_function_v&lt; Function, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a98098102f472923f49b098c25d822621"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Transformation</b> (Function &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_transformation.html">Transformation</a>&lt; Function &gt;</td></tr>
<tr class="separator:a98098102f472923f49b098c25d822621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcaeb1f9fe73f713397b37d3209e817"><td class="memTemplParams" colspan="2"><a id="a6bcaeb1f9fe73f713397b37d3209e817"></a>
template&lt;typename Function , typename... TaylorDerivatives, std::enable_if_t&lt; not is_linearized_function_v&lt; Function, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6bcaeb1f9fe73f713397b37d3209e817"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6bcaeb1f9fe73f713397b37d3209e817">make_Transformation</a> (const Function &amp;f, const TaylorDerivatives &amp;...ds)</td></tr>
<tr class="memdesc:a6bcaeb1f9fe73f713397b37d3209e817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_transformation.html" title="A transformation from one single-column vector to another.">Transformation</a> from a transformation function (and optionally one or more Taylor series derivatives). <br /></td></tr>
<tr class="separator:a6bcaeb1f9fe73f713397b37d3209e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f9155e6a8c211c128af8bdc3f02c14"><td class="memTemplParams" colspan="2">template&lt;typename Function , std::enable_if_t&lt; is_linearized_function_v&lt; Function, 1 &gt; and not is_linearized_function_v&lt; Function, 2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a05f9155e6a8c211c128af8bdc3f02c14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a05f9155e6a8c211c128af8bdc3f02c14">make_Transformation</a> (const Function &amp;f)</td></tr>
<tr class="separator:a05f9155e6a8c211c128af8bdc3f02c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1cc44ce0298dc05a5202d388fd80b4"><td class="memTemplParams" colspan="2"><a id="aea1cc44ce0298dc05a5202d388fd80b4"></a>
template&lt;typename M , std::enable_if_t&lt; is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aea1cc44ce0298dc05a5202d388fd80b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Covariance</b> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::<a class="el" href="struct_open_kalman_1_1_coefficients.html">Coefficients</a>, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::BaseMatrix &gt;</td></tr>
<tr class="separator:aea1cc44ce0298dc05a5202d388fd80b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d3283c4f337ddbb389c2c32eb733d0"><td class="memTemplParams" colspan="2"><a id="a52d3283c4f337ddbb389c2c32eb733d0"></a>
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; is_covariance_base_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a52d3283c4f337ddbb389c2c32eb733d0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a52d3283c4f337ddbb389c2c32eb733d0">make_Covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a52d3283c4f337ddbb389c2c32eb733d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> based on a covariance base. <br /></td></tr>
<tr class="separator:a52d3283c4f337ddbb389c2c32eb733d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f85ede5a341f9abd89ee0f2f9a40a7"><td class="memTemplParams" colspan="2">template&lt;typename V , std::enable_if_t&lt; is_typed_matrix_base_v&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab8f85ede5a341f9abd89ee0f2f9a40a7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab8f85ede5a341f9abd89ee0f2f9a40a7">EuclideanMean</a> (V &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::dimension &gt;, lvalue_or_strict_t&lt; V &gt;&gt;</td></tr>
<tr class="memdesc:ab8f85ede5a341f9abd89ee0f2f9a40a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a typed matrix base, assuming axex-only coefficients.  <a href="namespace_open_kalman.html#ab8f85ede5a341f9abd89ee0f2f9a40a7">More...</a><br /></td></tr>
<tr class="separator:ab8f85ede5a341f9abd89ee0f2f9a40a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22c591186451d81c00ec226ad8202ba"><td class="memTemplParams" colspan="2"><a id="ad22c591186451d81c00ec226ad8202ba"></a>
template&lt;typename Coefficients  = void, typename V , std::enable_if_t&lt; is_typed_matrix_base_v&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad22c591186451d81c00ec226ad8202ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad22c591186451d81c00ec226ad8202ba">make_EuclideanMean</a> (V &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:ad22c591186451d81c00ec226ad8202ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="A typed vector.">EuclideanMean</a> object from a regular matrix object. <br /></td></tr>
<tr class="separator:ad22c591186451d81c00ec226ad8202ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e0758ea101ac6ede7671f52cbea55f"><td class="memTemplParams" colspan="2"><a id="ad8e0758ea101ac6ede7671f52cbea55f"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_typed_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad8e0758ea101ac6ede7671f52cbea55f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad8e0758ea101ac6ede7671f52cbea55f">make_EuclideanMean</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:ad8e0758ea101ac6ede7671f52cbea55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="A typed vector.">EuclideanMean</a> object from another typed matrix. <br /></td></tr>
<tr class="separator:ad8e0758ea101ac6ede7671f52cbea55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424efb87916c1d803a9df5361832302f"><td class="memTemplParams" colspan="2"><a id="a424efb87916c1d803a9df5361832302f"></a>
template&lt;typename Coefficients , typename V , std::enable_if_t&lt; is_typed_matrix_base_v&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a424efb87916c1d803a9df5361832302f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a424efb87916c1d803a9df5361832302f">make_EuclideanMean</a> ()</td></tr>
<tr class="memdesc:a424efb87916c1d803a9df5361832302f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, strict <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="A typed vector.">EuclideanMean</a>. <br /></td></tr>
<tr class="separator:a424efb87916c1d803a9df5361832302f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dea01ff3fd278f4ce27110a97f82a9e"><td class="memTemplParams" colspan="2"><a id="a3dea01ff3fd278f4ce27110a97f82a9e"></a>
template&lt;typename V , std::enable_if_t&lt; is_typed_matrix_base_v&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3dea01ff3fd278f4ce27110a97f82a9e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3dea01ff3fd278f4ce27110a97f82a9e">make_EuclideanMean</a> ()</td></tr>
<tr class="memdesc:a3dea01ff3fd278f4ce27110a97f82a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, strict <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="A typed vector.">EuclideanMean</a> with axis coefficients. <br /></td></tr>
<tr class="separator:a3dea01ff3fd278f4ce27110a97f82a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc31742e92d82b2c519c73f2657e3da5"><td class="memTemplParams" colspan="2">template&lt;typename V , std::enable_if_t&lt; is_typed_matrix_base_v&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afc31742e92d82b2c519c73f2657e3da5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#afc31742e92d82b2c519c73f2657e3da5">Mean</a> (V &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::dimension &gt;, lvalue_or_strict_t&lt; V &gt;&gt;</td></tr>
<tr class="memdesc:afc31742e92d82b2c519c73f2657e3da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a typed matrix base, assuming axis-only coefficients.  <a href="namespace_open_kalman.html#afc31742e92d82b2c519c73f2657e3da5">More...</a><br /></td></tr>
<tr class="separator:afc31742e92d82b2c519c73f2657e3da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ee11f07d4530a8da89d250b607aab7"><td class="memTemplParams" colspan="2"><a id="a86ee11f07d4530a8da89d250b607aab7"></a>
template&lt;typename Coefficients  = void, typename Arg , std::enable_if_t&lt; is_typed_matrix_base_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a86ee11f07d4530a8da89d250b607aab7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a86ee11f07d4530a8da89d250b607aab7">make_Mean</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a86ee11f07d4530a8da89d250b607aab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a> object from a typed matrix base. <br /></td></tr>
<tr class="separator:a86ee11f07d4530a8da89d250b607aab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88aacd6c919b5705475648c8ea649ac"><td class="memTemplParams" colspan="2"><a id="ae88aacd6c919b5705475648c8ea649ac"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_typed_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae88aacd6c919b5705475648c8ea649ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae88aacd6c919b5705475648c8ea649ac">make_Mean</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:ae88aacd6c919b5705475648c8ea649ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a> object from another typed matrix. <br /></td></tr>
<tr class="separator:ae88aacd6c919b5705475648c8ea649ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d9f78119f294a28cbc977a226059a8"><td class="memTemplParams" colspan="2"><a id="a60d9f78119f294a28cbc977a226059a8"></a>
template&lt;typename Coefficients , typename V , std::enable_if_t&lt; is_typed_matrix_base_v&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a60d9f78119f294a28cbc977a226059a8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a60d9f78119f294a28cbc977a226059a8">make_Mean</a> ()</td></tr>
<tr class="memdesc:a60d9f78119f294a28cbc977a226059a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, strict <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a>. <br /></td></tr>
<tr class="separator:a60d9f78119f294a28cbc977a226059a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9766593abe8b3190d4b3aa3214281d4e"><td class="memTemplParams" colspan="2"><a id="a9766593abe8b3190d4b3aa3214281d4e"></a>
template&lt;typename V , std::enable_if_t&lt; is_typed_matrix_base_v&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9766593abe8b3190d4b3aa3214281d4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a9766593abe8b3190d4b3aa3214281d4e">make_Mean</a> ()</td></tr>
<tr class="memdesc:a9766593abe8b3190d4b3aa3214281d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, strict <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a>, with axis coefficients. <br /></td></tr>
<tr class="separator:a9766593abe8b3190d4b3aa3214281d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0b1c6d47b91401897387608c3c00c2"><td class="memTemplParams" colspan="2"><a id="a0f0b1c6d47b91401897387608c3c00c2"></a>
template&lt;typename M , std::enable_if_t&lt; is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0f0b1c6d47b91401897387608c3c00c2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SquareRootCovariance</b> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html">SquareRootCovariance</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::<a class="el" href="struct_open_kalman_1_1_coefficients.html">Coefficients</a>, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::BaseMatrix &gt;</td></tr>
<tr class="separator:a0f0b1c6d47b91401897387608c3c00c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daf48d137598221358d944511ffd3e7"><td class="memTemplParams" colspan="2"><a id="a9daf48d137598221358d944511ffd3e7"></a>
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; is_covariance_base_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9daf48d137598221358d944511ffd3e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a9daf48d137598221358d944511ffd3e7">make_SquareRootCovariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a9daf48d137598221358d944511ffd3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a> based on a covariance base. <br /></td></tr>
<tr class="separator:a9daf48d137598221358d944511ffd3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f518c7693bc4ec06b235339f9e1029f"><td class="memTemplParams" colspan="2"><a id="a6f518c7693bc4ec06b235339f9e1029f"></a>
template&lt;typename M , std::enable_if_t&lt; is_typed_matrix_base_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6f518c7693bc4ec06b235339f9e1029f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6f518c7693bc4ec06b235339f9e1029f">TypedMatrix</a> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_typed_matrix.html">TypedMatrix</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::columns &gt;, lvalue_or_strict_t&lt; M &gt;&gt;</td></tr>
<tr class="memdesc:a6f518c7693bc4ec06b235339f9e1029f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce parameter types from a typed matrix base. <br /></td></tr>
<tr class="separator:a6f518c7693bc4ec06b235339f9e1029f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24079444a9ad2d5a5d7aa189ad2de7f1"><td class="memTemplParams" colspan="2">template&lt;typename V , std::enable_if_t&lt; is_typed_matrix_v&lt; V &gt; and not is_Euclidean_transformed_v&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a24079444a9ad2d5a5d7aa189ad2de7f1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a24079444a9ad2d5a5d7aa189ad2de7f1">TypedMatrix</a> (V &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_typed_matrix.html">TypedMatrix</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::RowCoefficients, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::ColumnCoefficients, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::BaseMatrix &gt;</td></tr>
<tr class="memdesc:a24079444a9ad2d5a5d7aa189ad2de7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a non-Euclidean-transformed typed matrix.  <a href="namespace_open_kalman.html#a24079444a9ad2d5a5d7aa189ad2de7f1">More...</a><br /></td></tr>
<tr class="separator:a24079444a9ad2d5a5d7aa189ad2de7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae3ed78cfec5ef17d8f3599f722c42f"><td class="memTemplParams" colspan="2"><a id="acae3ed78cfec5ef17d8f3599f722c42f"></a>
template&lt;typename RowCoefficients  = void, typename ColumnCoefficients  = void, typename M , std::enable_if_t&lt; is_typed_matrix_base_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acae3ed78cfec5ef17d8f3599f722c42f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#acae3ed78cfec5ef17d8f3599f722c42f">make_Matrix</a> (M &amp;&amp;arg)</td></tr>
<tr class="memdesc:acae3ed78cfec5ef17d8f3599f722c42f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_typed_matrix.html" title="A typed matrix.">TypedMatrix</a> object from a typed matrix base. <br /></td></tr>
<tr class="separator:acae3ed78cfec5ef17d8f3599f722c42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df6a3953f9fbb692107bc671f61fa2b"><td class="memTemplParams" colspan="2"><a id="a0df6a3953f9fbb692107bc671f61fa2b"></a>
template&lt;typename M , std::enable_if_t&lt; is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0df6a3953f9fbb692107bc671f61fa2b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0df6a3953f9fbb692107bc671f61fa2b">make_Matrix</a> (M &amp;&amp;arg)</td></tr>
<tr class="memdesc:a0df6a3953f9fbb692107bc671f61fa2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_typed_matrix.html" title="A typed matrix.">TypedMatrix</a> object from a covariance object. <br /></td></tr>
<tr class="separator:a0df6a3953f9fbb692107bc671f61fa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579cdf886f00b425f5601f89ad2ef0b2"><td class="memTemplParams" colspan="2"><a id="a579cdf886f00b425f5601f89ad2ef0b2"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_typed_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a579cdf886f00b425f5601f89ad2ef0b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a579cdf886f00b425f5601f89ad2ef0b2">make_Matrix</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a579cdf886f00b425f5601f89ad2ef0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_typed_matrix.html" title="A typed matrix.">TypedMatrix</a> object from another typed matrix. <br /></td></tr>
<tr class="separator:a579cdf886f00b425f5601f89ad2ef0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5fd44ee4d1fd33c26dc54b2d1f308a"><td class="memTemplParams" colspan="2"><a id="a1c5fd44ee4d1fd33c26dc54b2d1f308a"></a>
template&lt;typename RowCoefficients , typename ColumnCoefficients , typename M , std::enable_if_t&lt; is_typed_matrix_base_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1c5fd44ee4d1fd33c26dc54b2d1f308a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1c5fd44ee4d1fd33c26dc54b2d1f308a">make_Matrix</a> ()</td></tr>
<tr class="memdesc:a1c5fd44ee4d1fd33c26dc54b2d1f308a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, strict <a class="el" href="struct_open_kalman_1_1_typed_matrix.html" title="A typed matrix.">TypedMatrix</a> object. <br /></td></tr>
<tr class="separator:a1c5fd44ee4d1fd33c26dc54b2d1f308a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15bfdf51e47efa584b977aa3526e792"><td class="memTemplParams" colspan="2"><a id="ab15bfdf51e47efa584b977aa3526e792"></a>
template&lt;typename M , std::enable_if_t&lt; is_typed_matrix_base_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab15bfdf51e47efa584b977aa3526e792"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab15bfdf51e47efa584b977aa3526e792">make_Matrix</a> ()</td></tr>
<tr class="memdesc:ab15bfdf51e47efa584b977aa3526e792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, strict <a class="el" href="struct_open_kalman_1_1_typed_matrix.html" title="A typed matrix.">TypedMatrix</a> object with axis coefficients. <br /></td></tr>
<tr class="separator:ab15bfdf51e47efa584b977aa3526e792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099d9cd1a01a8d47b47baee12df7f826"><td class="memTemplParams" colspan="2"><a id="a099d9cd1a01a8d47b47baee12df7f826"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_native_Eigen_type_v&lt; Arg &gt; and is_diagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a099d9cd1a01a8d47b47baee12df7f826"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cholesky_square</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a099d9cd1a01a8d47b47baee12df7f826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56db63a1fbd3c44d96b53c90ce84827"><td class="memTemplParams" colspan="2"><a id="ae56db63a1fbd3c44d96b53c90ce84827"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_native_Eigen_type_v&lt; Arg &gt; and is_diagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae56db63a1fbd3c44d96b53c90ce84827"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cholesky_factor</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:ae56db63a1fbd3c44d96b53c90ce84827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a064421a61eff48763f1422de088d57"><td class="memTemplParams" colspan="2"><a id="a7a064421a61eff48763f1422de088d57"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7a064421a61eff48763f1422de088d57"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cholesky_square</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a7a064421a61eff48763f1422de088d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36529509c97a861d360f2557a7862f49"><td class="memTemplParams" colspan="2"><a id="a36529509c97a861d360f2557a7862f49"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a36529509c97a861d360f2557a7862f49"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cholesky_factor</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a36529509c97a861d360f2557a7862f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee5f445abea0bb8da6ecfebf70604cc"><td class="memTemplParams" colspan="2"><a id="acee5f445abea0bb8da6ecfebf70604cc"></a>
template&lt;TriangleType triangle_type, typename Arg , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acee5f445abea0bb8da6ecfebf70604cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cholesky_factor</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:acee5f445abea0bb8da6ecfebf70604cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c3e7a580f7b33adcb134e0693d1666"><td class="memTemplParams" colspan="2"><a id="a65c3e7a580f7b33adcb134e0693d1666"></a>
template&lt;typename M , std::enable_if_t&lt; is_Eigen_matrix_v&lt; M &gt; and MatrixTraits&lt; M &gt;::columns==1, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a65c3e7a580f7b33adcb134e0693d1666"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenDiagonal</b> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_eigen_diagonal.html">EigenDiagonal</a>&lt; lvalue_or_strict_t&lt; M &gt;&gt;</td></tr>
<tr class="separator:a65c3e7a580f7b33adcb134e0693d1666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af489ba35a748539a486d949d1e320a"><td class="memTemplParams" colspan="2"><a id="a7af489ba35a748539a486d949d1e320a"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_zero_v&lt; Arg &gt; and(MatrixTraits&lt; Arg &gt;::columns &gt; 1) and MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7af489ba35a748539a486d949d1e320a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenDiagonal</b> (const Arg &amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_eigen_diagonal.html">EigenDiagonal</a>&lt; <a class="el" href="struct_open_kalman_1_1_eigen_zero.html">EigenZero</a>&lt; Eigen::Matrix&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; Arg &gt;::Scalar, <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; Arg &gt;::dimension, 1 &gt;&gt;&gt;</td></tr>
<tr class="separator:a7af489ba35a748539a486d949d1e320a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a2632cc4d427298877ea3955cfce2c"><td class="memTemplParams" colspan="2"><a id="a04a2632cc4d427298877ea3955cfce2c"></a>
template&lt;typename ... Args, std::enable_if_t&lt; std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a04a2632cc4d427298877ea3955cfce2c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenDiagonal</b> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_eigen_diagonal.html">EigenDiagonal</a>&lt; Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, sizeof...(Args), 1 &gt;&gt;</td></tr>
<tr class="separator:a04a2632cc4d427298877ea3955cfce2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea672e235a5477e34b1d664a1f37a900"><td class="memTemplParams" colspan="2"><a id="aea672e235a5477e34b1d664a1f37a900"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aea672e235a5477e34b1d664a1f37a900"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>base_matrix</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:aea672e235a5477e34b1d664a1f37a900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7584426788ef75adc2a88adefe949c49"><td class="memTemplParams" colspan="2"><a id="a7584426788ef75adc2a88adefe949c49"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7584426788ef75adc2a88adefe949c49"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a7584426788ef75adc2a88adefe949c49">strict</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a7584426788ef75adc2a88adefe949c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to strict version. <br /></td></tr>
<tr class="separator:a7584426788ef75adc2a88adefe949c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2014602c8e816ba4909a8cc351ddbf9a"><td class="memTemplParams" colspan="2"><a id="a2014602c8e816ba4909a8cc351ddbf9a"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2014602c8e816ba4909a8cc351ddbf9a"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a2014602c8e816ba4909a8cc351ddbf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab536922d609de701e0e633c25694eb14"><td class="memTemplParams" colspan="2"><a id="ab536922d609de701e0e633c25694eb14"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab536922d609de701e0e633c25694eb14"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adjoint</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:ab536922d609de701e0e633c25694eb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d15f831673c20ed3bfd363a2df21b28"><td class="memTemplParams" colspan="2"><a id="a9d15f831673c20ed3bfd363a2df21b28"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9d15f831673c20ed3bfd363a2df21b28"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>determinant</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a9d15f831673c20ed3bfd363a2df21b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc11a35860348b1b517cf8487f38ced"><td class="memTemplParams" colspan="2"><a id="afdc11a35860348b1b517cf8487f38ced"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afdc11a35860348b1b517cf8487f38ced"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trace</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:afdc11a35860348b1b517cf8487f38ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6501b0326494338970fe168bb6e56bb"><td class="memTemplParams" colspan="2"><a id="ae6501b0326494338970fe168bb6e56bb"></a>
template&lt;typename Arg , typename U , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and is_EigenDiagonal_v&lt; U &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae6501b0326494338970fe168bb6e56bb"><td class="memTemplItemLeft" align="right" valign="top">Arg &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rank_update</b> (Arg &amp;arg, const U &amp;u, const typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; Arg &gt;::Scalar alpha=1)</td></tr>
<tr class="separator:ae6501b0326494338970fe168bb6e56bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1126f899f1afed2fcd08e28ea34d93d7"><td class="memTemplParams" colspan="2"><a id="a1126f899f1afed2fcd08e28ea34d93d7"></a>
template&lt;typename Arg , typename U , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and is_EigenDiagonal_v&lt; U &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1126f899f1afed2fcd08e28ea34d93d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rank_update</b> (const Arg &amp;arg, const U &amp;u, const typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; Arg &gt;::Scalar alpha=1)</td></tr>
<tr class="separator:a1126f899f1afed2fcd08e28ea34d93d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad508289e902f8099b14dad0890c64795"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , std::enable_if_t&lt; is_EigenDiagonal_v&lt; A &gt;, int &gt;  = 0, std::enable_if_t&lt; is_Eigen_matrix_v&lt; B &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad508289e902f8099b14dad0890c64795"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad508289e902f8099b14dad0890c64795">solve</a> (const A &amp;a, const B &amp;b)</td></tr>
<tr class="memdesc:ad508289e902f8099b14dad0890c64795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the equation AX = B for X. A is a diagonal matrix.  <a href="namespace_open_kalman.html#ad508289e902f8099b14dad0890c64795">More...</a><br /></td></tr>
<tr class="separator:ad508289e902f8099b14dad0890c64795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64ea73d28077cecfc217139a9d77813"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af64ea73d28077cecfc217139a9d77813"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af64ea73d28077cecfc217139a9d77813">reduce_columns</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:af64ea73d28077cecfc217139a9d77813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a column vector from a diagnoal matrix. (Same as base_matrix()).  <a href="namespace_open_kalman.html#af64ea73d28077cecfc217139a9d77813">More...</a><br /></td></tr>
<tr class="separator:af64ea73d28077cecfc217139a9d77813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6c57d62908d98416bcaed87375964c"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; is_EigenDiagonal_v&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2b6c57d62908d98416bcaed87375964c"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2b6c57d62908d98416bcaed87375964c">LQ_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="memdesc:a2b6c57d62908d98416bcaed87375964c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an LQ decomposition. Since it is diagonal, it returns the matrix unchanged.  <a href="namespace_open_kalman.html#a2b6c57d62908d98416bcaed87375964c">More...</a><br /></td></tr>
<tr class="separator:a2b6c57d62908d98416bcaed87375964c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ae142f488e2f8e68a657b091ed195d"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; is_EigenDiagonal_v&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a11ae142f488e2f8e68a657b091ed195d"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a11ae142f488e2f8e68a657b091ed195d">QR_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="memdesc:a11ae142f488e2f8e68a657b091ed195d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a QR decomposition. Since it is diagonal, it returns the matrix unchanged.  <a href="namespace_open_kalman.html#a11ae142f488e2f8e68a657b091ed195d">More...</a><br /></td></tr>
<tr class="separator:a11ae142f488e2f8e68a657b091ed195d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cbaa34feefd5e3535dbf988122b7b2"><td class="memTemplParams" colspan="2">template&lt;typename V , typename ... Vs, std::enable_if_t&lt; std::conjunction_v&lt; is_EigenDiagonal&lt; V &gt;, is_EigenDiagonal&lt; Vs &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab1cbaa34feefd5e3535dbf988122b7b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab1cbaa34feefd5e3535dbf988122b7b2">concatenate</a> (V &amp;&amp;v, Vs &amp;&amp;... vs)</td></tr>
<tr class="memdesc:ab1cbaa34feefd5e3535dbf988122b7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate diagonally.  <a href="namespace_open_kalman.html#ab1cbaa34feefd5e3535dbf988122b7b2">More...</a><br /></td></tr>
<tr class="separator:ab1cbaa34feefd5e3535dbf988122b7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0315b7e1603e75b425629b5604e470b2"><td class="memTemplParams" colspan="2">template&lt;typename V , typename ... Vs, std::enable_if_t&lt; std::conjunction_v&lt; is_EigenDiagonal&lt; V &gt;, is_EigenDiagonal&lt; Vs &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0315b7e1603e75b425629b5604e470b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0315b7e1603e75b425629b5604e470b2">concatenate_diagonal</a> (V &amp;&amp;v, Vs &amp;&amp;... vs)</td></tr>
<tr class="memdesc:a0315b7e1603e75b425629b5604e470b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate diagonally.  <a href="namespace_open_kalman.html#a0315b7e1603e75b425629b5604e470b2">More...</a><br /></td></tr>
<tr class="separator:a0315b7e1603e75b425629b5604e470b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed81d91202d9b998733a3be06de9910"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and(is_element_gettable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 1 &gt; or is_element_gettable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 2 &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7ed81d91202d9b998733a3be06de9910"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a7ed81d91202d9b998733a3be06de9910">get_element</a> (Arg &amp;&amp;arg, const std::size_t i)</td></tr>
<tr class="memdesc:a7ed81d91202d9b998733a3be06de9910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i) of diagonal matrix arg.  <a href="namespace_open_kalman.html#a7ed81d91202d9b998733a3be06de9910">More...</a><br /></td></tr>
<tr class="separator:a7ed81d91202d9b998733a3be06de9910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9f83dc120f7424fe949f401344960e"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and(is_element_gettable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 1 &gt; or is_element_gettable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 2 &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aab9f83dc120f7424fe949f401344960e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aab9f83dc120f7424fe949f401344960e">get_element</a> (Arg &amp;&amp;arg, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:aab9f83dc120f7424fe949f401344960e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i, j) of diagonal matrix arg.  <a href="namespace_open_kalman.html#aab9f83dc120f7424fe949f401344960e">More...</a><br /></td></tr>
<tr class="separator:aab9f83dc120f7424fe949f401344960e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a86339bc79fa01578464985b73e03a5"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and(is_element_settable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 1 &gt; or is_element_settable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 2 &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1a86339bc79fa01578464985b73e03a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1a86339bc79fa01578464985b73e03a5">set_element</a> (Arg &amp;arg, const Scalar s, const std::size_t i)</td></tr>
<tr class="memdesc:a1a86339bc79fa01578464985b73e03a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i) of matrix arg to s.  <a href="namespace_open_kalman.html#a1a86339bc79fa01578464985b73e03a5">More...</a><br /></td></tr>
<tr class="separator:a1a86339bc79fa01578464985b73e03a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d576e04f45d8081c586f69f8b7f96f"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and(is_element_settable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 1 &gt; or is_element_settable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 2 &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab5d576e04f45d8081c586f69f8b7f96f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab5d576e04f45d8081c586f69f8b7f96f">set_element</a> (Arg &amp;arg, const Scalar s, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:ab5d576e04f45d8081c586f69f8b7f96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i, j) of matrix arg to s.  <a href="namespace_open_kalman.html#ab5d576e04f45d8081c586f69f8b7f96f">More...</a><br /></td></tr>
<tr class="separator:ab5d576e04f45d8081c586f69f8b7f96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9397fe69e16f2338a5c5cd664510c6"><td class="memTemplParams" colspan="2"><a id="a4e9397fe69e16f2338a5c5cd664510c6"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg1 &gt; and is_EigenDiagonal_v&lt; Arg2 &gt; and not is_zero_v&lt; Arg1 &gt; and not is_zero_v&lt; Arg2 &gt; and not is_identity_v&lt; Arg1 &gt; and not is_identity_v&lt; Arg2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4e9397fe69e16f2338a5c5cd664510c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (Arg1 &amp;&amp;arg1, Arg2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a4e9397fe69e16f2338a5c5cd664510c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dc097a8ab1edb54efc24071cccb68a"><td class="memTemplParams" colspan="2"><a id="ac2dc097a8ab1edb54efc24071cccb68a"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt;(is_EigenDiagonal_v&lt; Arg1 &gt; and is_zero_v&lt; Arg2 &gt;) or(is_zero_v&lt; Arg1 &gt; and is_EigenDiagonal_v&lt; Arg2 &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac2dc097a8ab1edb54efc24071cccb68a"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac2dc097a8ab1edb54efc24071cccb68a">operator+</a> (Arg1 &amp;&amp;arg1, Arg2 &amp;&amp;arg2)</td></tr>
<tr class="memdesc:ac2dc097a8ab1edb54efc24071cccb68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two covariance types or one covariance type and one compatible typed matrix. <br /></td></tr>
<tr class="separator:ac2dc097a8ab1edb54efc24071cccb68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28061776261951e70f069482736e521c"><td class="memTemplParams" colspan="2"><a id="a28061776261951e70f069482736e521c"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg1 &gt; and is_EigenDiagonal_v&lt; Arg2 &gt; and not is_zero_v&lt; Arg1 &gt; and not is_zero_v&lt; Arg2 &gt; and not is_identity_v&lt; Arg1 &gt; and not is_identity_v&lt; Arg2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a28061776261951e70f069482736e521c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (Arg1 &amp;&amp;arg1, Arg2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a28061776261951e70f069482736e521c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da8b8930aaa180daa6782f7b243ea63"><td class="memTemplParams" colspan="2"><a id="a1da8b8930aaa180daa6782f7b243ea63"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt;(is_EigenDiagonal_v&lt; Arg1 &gt; and is_zero_v&lt; Arg2 &gt;) or(is_zero_v&lt; Arg1 &gt; and is_EigenDiagonal_v&lt; Arg2 &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1da8b8930aaa180daa6782f7b243ea63"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1da8b8930aaa180daa6782f7b243ea63">operator-</a> (Arg1 &amp;&amp;arg1, Arg2 &amp;&amp;arg2)</td></tr>
<tr class="memdesc:a1da8b8930aaa180daa6782f7b243ea63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two covariance types, or one covariance type and one compatible typed matrix. <br /></td></tr>
<tr class="separator:a1da8b8930aaa180daa6782f7b243ea63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7248d93153eec1730c6a8cb2d2a782"><td class="memTemplParams" colspan="2"><a id="a5e7248d93153eec1730c6a8cb2d2a782"></a>
template&lt;typename Arg , typename S , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; Arg &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5e7248d93153eec1730c6a8cb2d2a782"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (Arg &amp;&amp;arg, const S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>)</td></tr>
<tr class="separator:a5e7248d93153eec1730c6a8cb2d2a782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79b41c62504454167ce017e6d70d04a"><td class="memTemplParams" colspan="2"><a id="ae79b41c62504454167ce017e6d70d04a"></a>
template&lt;typename Arg , typename S , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; Arg &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae79b41c62504454167ce017e6d70d04a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>, Arg &amp;&amp;arg)</td></tr>
<tr class="separator:ae79b41c62504454167ce017e6d70d04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0610fbaac7eeff7cb31f747292c524a"><td class="memTemplParams" colspan="2"><a id="ab0610fbaac7eeff7cb31f747292c524a"></a>
template&lt;typename Arg , typename S , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; Arg &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab0610fbaac7eeff7cb31f747292c524a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (Arg &amp;&amp;arg, const S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>)</td></tr>
<tr class="separator:ab0610fbaac7eeff7cb31f747292c524a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae083771ca9d07f3b77549f13c088a093"><td class="memTemplParams" colspan="2"><a id="ae083771ca9d07f3b77549f13c088a093"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg1 &gt; and is_EigenDiagonal_v&lt; Arg2 &gt; and not is_zero_v&lt; Arg1 &gt; and not is_zero_v&lt; Arg2 &gt; and not is_identity_v&lt; Arg1 &gt; and not is_identity_v&lt; Arg2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae083771ca9d07f3b77549f13c088a093"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (Arg1 &amp;&amp;arg1, Arg2 &amp;&amp;arg2)</td></tr>
<tr class="separator:ae083771ca9d07f3b77549f13c088a093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8f99371e3f22ae56f03a8b5ea4bca3"><td class="memTemplParams" colspan="2"><a id="a9c8f99371e3f22ae56f03a8b5ea4bca3"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt;(is_EigenDiagonal_v&lt; Arg1 &gt; and is_zero_v&lt; Arg2 &gt;) or(is_zero_v&lt; Arg1 &gt; and is_EigenDiagonal_v&lt; Arg2 &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9c8f99371e3f22ae56f03a8b5ea4bca3"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a9c8f99371e3f22ae56f03a8b5ea4bca3">operator*</a> (Arg1 &amp;&amp;arg1, Arg2 &amp;&amp;arg2) noexcept</td></tr>
<tr class="memdesc:a9c8f99371e3f22ae56f03a8b5ea4bca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two covariance types. <br /></td></tr>
<tr class="separator:a9c8f99371e3f22ae56f03a8b5ea4bca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb1694f36bc28cc132de9c6243a51eb"><td class="memTemplParams" colspan="2"><a id="aadb1694f36bc28cc132de9c6243a51eb"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aadb1694f36bc28cc132de9c6243a51eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:aadb1694f36bc28cc132de9c6243a51eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b797c590b3e19ce373b02f7237e4bb1"><td class="memTemplParams" colspan="2"><a id="a4b797c590b3e19ce373b02f7237e4bb1"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4b797c590b3e19ce373b02f7237e4bb1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4b797c590b3e19ce373b02f7237e4bb1">Mean</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; sizeof...(Args)&gt;, Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, sizeof...(Args), 1 &gt;&gt;</td></tr>
<tr class="memdesc:a4b797c590b3e19ce373b02f7237e4bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, deduce a single-column Euclidean mean. <br /></td></tr>
<tr class="separator:a4b797c590b3e19ce373b02f7237e4bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c3ad32035befe46cb88c138592e8db"><td class="memTemplParams" colspan="2"><a id="a16c3ad32035befe46cb88c138592e8db"></a>
template&lt;typename Coefficients , typename ... Args, std::enable_if_t&lt; not std::is_arithmetic_v&lt; Coefficients &gt; and(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a16c3ad32035befe46cb88c138592e8db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a16c3ad32035befe46cb88c138592e8db">make_Mean</a> (Args ... args)</td></tr>
<tr class="memdesc:a16c3ad32035befe46cb88c138592e8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a> from a list of coefficients, if <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> types are known. <br /></td></tr>
<tr class="separator:a16c3ad32035befe46cb88c138592e8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846c7add28e0e83d26f2dd07d25da878"><td class="memTemplParams" colspan="2"><a id="a846c7add28e0e83d26f2dd07d25da878"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a846c7add28e0e83d26f2dd07d25da878"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a846c7add28e0e83d26f2dd07d25da878">make_Mean</a> (Args ... args)</td></tr>
<tr class="memdesc:a846c7add28e0e83d26f2dd07d25da878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a> from a list of coefficients, assuming that <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> types are all <a class="el" href="struct_open_kalman_1_1_axis.html">Axis</a>. <br /></td></tr>
<tr class="separator:a846c7add28e0e83d26f2dd07d25da878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e02b3a161b8eb2b62089cc62c1754a5"><td class="memTemplParams" colspan="2"><a id="a7e02b3a161b8eb2b62089cc62c1754a5"></a>
template&lt;typename Scalar , typename Coefficients , std::size_t cols = 1, std::enable_if_t&lt; std::is_arithmetic_v&lt; Scalar &gt;, int &gt;  = 0, std::enable_if_t&lt; not std::is_arithmetic_v&lt; Coefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7e02b3a161b8eb2b62089cc62c1754a5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a7e02b3a161b8eb2b62089cc62c1754a5">make_Mean</a> ()</td></tr>
<tr class="memdesc:a7e02b3a161b8eb2b62089cc62c1754a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default Eigen3 <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a>, based on a Scalar type, a set of <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a>, and a number of columns. <br /></td></tr>
<tr class="separator:a7e02b3a161b8eb2b62089cc62c1754a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65062e66add59281b5b366a0344a1437"><td class="memTemplParams" colspan="2"><a id="a65062e66add59281b5b366a0344a1437"></a>
template&lt;typename RowCoefficients , typename ColumnCoefficients  = RowCoefficients, typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a65062e66add59281b5b366a0344a1437"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a65062e66add59281b5b366a0344a1437">make_Matrix</a> (Args ... args)</td></tr>
<tr class="memdesc:a65062e66add59281b5b366a0344a1437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a> from a list of coefficients. <br /></td></tr>
<tr class="separator:a65062e66add59281b5b366a0344a1437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588cc45b33442c2d91445a95dbaa5f0f"><td class="memTemplParams" colspan="2"><a id="a588cc45b33442c2d91445a95dbaa5f0f"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a588cc45b33442c2d91445a95dbaa5f0f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a588cc45b33442c2d91445a95dbaa5f0f">make_Matrix</a> (Args ... args)</td></tr>
<tr class="memdesc:a588cc45b33442c2d91445a95dbaa5f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a> from a list of coefficients. <br /></td></tr>
<tr class="separator:a588cc45b33442c2d91445a95dbaa5f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bde5fdb8261b2248c1f43014a72c011"><td class="memTemplParams" colspan="2"><a id="a6bde5fdb8261b2248c1f43014a72c011"></a>
template&lt;typename Scalar , typename RowCoefficients , typename ColumnCoefficients  = RowCoefficients, std::enable_if_t&lt; std::is_arithmetic_v&lt; Scalar &gt;, int &gt;  = 0, std::enable_if_t&lt; not std::is_arithmetic_v&lt; RowCoefficients &gt;, int &gt;  = 0, std::enable_if_t&lt; not std::is_arithmetic_v&lt; ColumnCoefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6bde5fdb8261b2248c1f43014a72c011"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6bde5fdb8261b2248c1f43014a72c011">make_Matrix</a> ()</td></tr>
<tr class="memdesc:a6bde5fdb8261b2248c1f43014a72c011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a> from a Scalar type and one or two sets of <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a>. <br /></td></tr>
<tr class="separator:a6bde5fdb8261b2248c1f43014a72c011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299661af360b08bf64b104c3376f9126"><td class="memTemplParams" colspan="2"><a id="a299661af360b08bf64b104c3376f9126"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a299661af360b08bf64b104c3376f9126"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a299661af360b08bf64b104c3376f9126">EuclideanMean</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">OpenKalman::Axes</a>&lt; sizeof...(Args)&gt;, Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, sizeof...(Args), 1 &gt;&gt;</td></tr>
<tr class="memdesc:a299661af360b08bf64b104c3376f9126"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, construct a single-column Euclidean mean. <br /></td></tr>
<tr class="separator:a299661af360b08bf64b104c3376f9126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8438d66bae40995bdb4351f1cab7a0"><td class="memTemplParams" colspan="2"><a id="a2a8438d66bae40995bdb4351f1cab7a0"></a>
template&lt;typename Coefficients , typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2a8438d66bae40995bdb4351f1cab7a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2a8438d66bae40995bdb4351f1cab7a0">make_EuclideanMean</a> (Args ... args) noexcept</td></tr>
<tr class="memdesc:a2a8438d66bae40995bdb4351f1cab7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make Euclidean mean from a list of coefficients. <br /></td></tr>
<tr class="separator:a2a8438d66bae40995bdb4351f1cab7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871fd785d07663c978d7601c385813ef"><td class="memTemplParams" colspan="2"><a id="a871fd785d07663c978d7601c385813ef"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a871fd785d07663c978d7601c385813ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a871fd785d07663c978d7601c385813ef">make_EuclideanMean</a> (Args ... args) noexcept</td></tr>
<tr class="memdesc:a871fd785d07663c978d7601c385813ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="struct_open_kalman_1_1_mean.html" title="A typed vector.">Mean</a> from a list of coefficients. <br /></td></tr>
<tr class="separator:a871fd785d07663c978d7601c385813ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0187d24e47080daffb1064beefaba707"><td class="memTemplParams" colspan="2"><a id="a0187d24e47080daffb1064beefaba707"></a>
template&lt;typename Scalar , typename Coefficients , std::size_t cols = 1, std::enable_if_t&lt; std::is_arithmetic_v&lt; Scalar &gt;, int &gt;  = 0, std::enable_if_t&lt; not std::is_arithmetic_v&lt; Coefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0187d24e47080daffb1064beefaba707"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0187d24e47080daffb1064beefaba707">make_EuclideanMean</a> ()</td></tr>
<tr class="memdesc:a0187d24e47080daffb1064beefaba707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make strict <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="A typed vector.">EuclideanMean</a> from a Scalar type, a set of <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a>, and a number of columns. <br /></td></tr>
<tr class="separator:a0187d24e47080daffb1064beefaba707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b910ecc32d7d7350080b57f8eafd300"><td class="memTemplParams" colspan="2"><a id="a2b910ecc32d7d7350080b57f8eafd300"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2b910ecc32d7d7350080b57f8eafd300"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2b910ecc32d7d7350080b57f8eafd300">Covariance</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; internal::constexpr_sqrt(sizeof...(Args))&gt;, <a class="el" href="struct_open_kalman_1_1_eigen_self_adjoint_matrix.html">EigenSelfAdjointMatrix</a>&lt; Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, internal::constexpr_sqrt(sizeof...(Args)), internal::constexpr_sqrt(sizeof...(Args))&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a2b910ecc32d7d7350080b57f8eafd300"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, derive a square, self-adjoint matrix. <br /></td></tr>
<tr class="separator:a2b910ecc32d7d7350080b57f8eafd300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773cf4e126d6964b9ffd37d666b56fe2"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; or is_EigenDiagonal_v&lt; Arg &gt; or is_EigenSelfAdjointMatrix_v&lt; Arg &gt; or is_EigenTriangularMatrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a773cf4e126d6964b9ffd37d666b56fe2"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a773cf4e126d6964b9ffd37d666b56fe2">strict_matrix</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a773cf4e126d6964b9ffd37d666b56fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to strict version of the matrix.  <a href="namespace_open_kalman.html#a773cf4e126d6964b9ffd37d666b56fe2">More...</a><br /></td></tr>
<tr class="separator:a773cf4e126d6964b9ffd37d666b56fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6248f13f1f0e31095d0012b4fba489fb"><td class="memTemplParams" colspan="2"><a id="a6248f13f1f0e31095d0012b4fba489fb"></a>
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6248f13f1f0e31095d0012b4fba489fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_Euclidean</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a6248f13f1f0e31095d0012b4fba489fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5adfd6b31112377b5e01770fd1fa6b9"><td class="memTemplParams" colspan="2"><a id="ac5adfd6b31112377b5e01770fd1fa6b9"></a>
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac5adfd6b31112377b5e01770fd1fa6b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_Euclidean</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:ac5adfd6b31112377b5e01770fd1fa6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53512a5b7aa44f6146dfcc267c0596fd"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a53512a5b7aa44f6146dfcc267c0596fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a53512a5b7aa44f6146dfcc267c0596fd">wrap_angles</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a53512a5b7aa44f6146dfcc267c0596fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b6735e2c5cb8088a905ad6641c87c5"><td class="memTemplParams" colspan="2"><a id="a63b6735e2c5cb8088a905ad6641c87c5"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_native_Eigen_type_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a63b6735e2c5cb8088a905ad6641c87c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_diagonal</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a63b6735e2c5cb8088a905ad6641c87c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee351667e13c16299dbbeadc383083a"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; is_native_Eigen_type_v&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aaee351667e13c16299dbbeadc383083a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aaee351667e13c16299dbbeadc383083a">LQ_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:aaee351667e13c16299dbbeadc383083a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8bc52340ab01395a4aba7470d13d29"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; is_native_Eigen_type_v&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6c8bc52340ab01395a4aba7470d13d29"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6c8bc52340ab01395a4aba7470d13d29">QR_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:a6c8bc52340ab01395a4aba7470d13d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07f38b9b803ce7be54501d6899eebb1"><td class="memTemplParams" colspan="2">template&lt;typename V , typename ... Vs, std::enable_if_t&lt; std::conjunction_v&lt; std::disjunction&lt; is_Eigen_matrix&lt; V &gt;, is_EigenSelfAdjointMatrix&lt; V &gt;, is_EigenTriangularMatrix&lt; V &gt;, is_EigenDiagonal&lt; V &gt;, is_FromEuclideanExpr&lt; V &gt;&gt;, std::disjunction&lt; is_Eigen_matrix&lt; Vs &gt;, is_EigenSelfAdjointMatrix&lt; Vs &gt;, is_EigenTriangularMatrix&lt; Vs &gt;, is_EigenDiagonal&lt; Vs &gt;, is_FromEuclideanExpr&lt; V &gt;&gt;... &gt; and not std::conjunction_v&lt; is_FromEuclideanExpr&lt; V &gt;, is_FromEuclideanExpr&lt; Vs &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac07f38b9b803ce7be54501d6899eebb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac07f38b9b803ce7be54501d6899eebb1">concatenate_vertical</a> (V &amp;&amp;v, Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:ac07f38b9b803ce7be54501d6899eebb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more Eigen::MatrixBase objects vertically.  <a href="namespace_open_kalman.html#ac07f38b9b803ce7be54501d6899eebb1">More...</a><br /></td></tr>
<tr class="separator:ac07f38b9b803ce7be54501d6899eebb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c5157500f9c2c2018697ce9fd276d5"><td class="memTemplParams" colspan="2">template&lt;typename V , typename ... Vs, std::enable_if_t&lt; std::conjunction_v&lt; std::disjunction&lt; is_Eigen_matrix&lt; V &gt;, is_EigenSelfAdjointMatrix&lt; V &gt;, is_EigenTriangularMatrix&lt; V &gt;, is_EigenDiagonal&lt; V &gt;, is_FromEuclideanExpr&lt; V &gt;&gt;, std::disjunction&lt; is_Eigen_matrix&lt; Vs &gt;, is_EigenSelfAdjointMatrix&lt; Vs &gt;, is_EigenTriangularMatrix&lt; Vs &gt;, is_EigenDiagonal&lt; Vs &gt;, is_FromEuclideanExpr&lt; Vs &gt;&gt;... &gt; and not std::conjunction_v&lt; is_FromEuclideanExpr&lt; V &gt;, is_FromEuclideanExpr&lt; Vs &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac3c5157500f9c2c2018697ce9fd276d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac3c5157500f9c2c2018697ce9fd276d5">concatenate_horizontal</a> (V &amp;&amp;v, Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:ac3c5157500f9c2c2018697ce9fd276d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more Eigen::MatrixBase objects horizontally.  <a href="namespace_open_kalman.html#ac3c5157500f9c2c2018697ce9fd276d5">More...</a><br /></td></tr>
<tr class="separator:ac3c5157500f9c2c2018697ce9fd276d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2742abeb205f5ed2e4d92ebb579329a7"><td class="memTemplParams" colspan="2">template&lt;typename F , bool euclidean, typename RC , typename... RCs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2742abeb205f5ed2e4d92ebb579329a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2742abeb205f5ed2e4d92ebb579329a7">split_vertical</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a2742abeb205f5ed2e4d92ebb579329a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620f0997bfd5cc822af4d33d52313f4d"><td class="memTemplParams" colspan="2">template&lt;typename F  = internal::default_split_function, bool euclidean = false, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a620f0997bfd5cc822af4d33d52313f4d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a620f0997bfd5cc822af4d33d52313f4d">split_vertical</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a620f0997bfd5cc822af4d33d52313f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a matrix vertically (case in which there is no split).  <a href="namespace_open_kalman.html#a620f0997bfd5cc822af4d33d52313f4d">More...</a><br /></td></tr>
<tr class="separator:a620f0997bfd5cc822af4d33d52313f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0038e7aa690a366121acc4c2c807075"><td class="memTemplParams" colspan="2">template&lt;typename F , typename RC , typename... RCs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and not is_coefficient_v&lt; F &gt; and std::conjunction_v&lt; is_coefficient&lt; RC &gt;, is_coefficient&lt; RCs &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae0038e7aa690a366121acc4c2c807075"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae0038e7aa690a366121acc4c2c807075">split_vertical</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:ae0038e7aa690a366121acc4c2c807075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into one or more Euclidean expressions vertically.  <a href="namespace_open_kalman.html#ae0038e7aa690a366121acc4c2c807075">More...</a><br /></td></tr>
<tr class="separator:ae0038e7aa690a366121acc4c2c807075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ade2c818a6ac726e63817f86ed1b071"><td class="memTemplParams" colspan="2">template&lt;typename F , typename CC , typename... CCs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and not is_coefficient_v&lt; F &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9ade2c818a6ac726e63817f86ed1b071"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a9ade2c818a6ac726e63817f86ed1b071">split_horizontal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a9ade2c818a6ac726e63817f86ed1b071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864237f3b06bf93ceaffbf1d992b19f2"><td class="memTemplParams" colspan="2">template&lt;typename F  = internal::default_split_function, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a864237f3b06bf93ceaffbf1d992b19f2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a864237f3b06bf93ceaffbf1d992b19f2">split_horizontal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a864237f3b06bf93ceaffbf1d992b19f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a matrix horizontally (case in which there is no split).  <a href="namespace_open_kalman.html#a864237f3b06bf93ceaffbf1d992b19f2">More...</a><br /></td></tr>
<tr class="separator:a864237f3b06bf93ceaffbf1d992b19f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719b02c283269c9d08d634559a20b7dc"><td class="memTemplParams" colspan="2">template&lt;typename CC , typename... CCs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and is_coefficient_v&lt; CC &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a719b02c283269c9d08d634559a20b7dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a719b02c283269c9d08d634559a20b7dc">split_horizontal</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a719b02c283269c9d08d634559a20b7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a self-adjoint, triangular, or diagonal matrix horizontally, returning a regular matrix.  <a href="namespace_open_kalman.html#a719b02c283269c9d08d634559a20b7dc">More...</a><br /></td></tr>
<tr class="separator:a719b02c283269c9d08d634559a20b7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15b73be3f7afa907872a4c65359e71f"><td class="memTemplParams" colspan="2">template&lt;typename F , bool euclidean, typename C , typename... Cs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac15b73be3f7afa907872a4c65359e71f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac15b73be3f7afa907872a4c65359e71f">split_diagonal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:ac15b73be3f7afa907872a4c65359e71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a63cbe9ff790107682a6fefd2006e8d"><td class="memTemplParams" colspan="2">template&lt;typename F  = internal::default_split_function, bool euclidean = false, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and not is_coefficient_v&lt; F &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0a63cbe9ff790107682a6fefd2006e8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0a63cbe9ff790107682a6fefd2006e8d">split_diagonal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a0a63cbe9ff790107682a6fefd2006e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a matrix vertically (case in which there is no split).  <a href="namespace_open_kalman.html#a0a63cbe9ff790107682a6fefd2006e8d">More...</a><br /></td></tr>
<tr class="separator:a0a63cbe9ff790107682a6fefd2006e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa80d0137de848614c73a2bdc6a65fdd"><td class="memTemplParams" colspan="2">template&lt;typename F , typename C , typename... Cs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and not is_coefficient_v&lt; F &gt; and std::conjunction_v&lt; is_coefficient&lt; C &gt;, is_coefficient&lt; Cs &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aaa80d0137de848614c73a2bdc6a65fdd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aaa80d0137de848614c73a2bdc6a65fdd">split_diagonal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:aaa80d0137de848614c73a2bdc6a65fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into one or more Euclidean expressions diagonally. The valuated expression must be square.  <a href="namespace_open_kalman.html#aaa80d0137de848614c73a2bdc6a65fdd">More...</a><br /></td></tr>
<tr class="separator:aaa80d0137de848614c73a2bdc6a65fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439099c89e7a6522dc675be7b1fdfe0c"><td class="memTemplParams" colspan="2"><a id="a439099c89e7a6522dc675be7b1fdfe0c"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_native_Eigen_type_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a439099c89e7a6522dc675be7b1fdfe0c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a439099c89e7a6522dc675be7b1fdfe0c">get_element</a> (const Arg &amp;arg, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:a439099c89e7a6522dc675be7b1fdfe0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i, j) of matrix arg. <br /></td></tr>
<tr class="separator:a439099c89e7a6522dc675be7b1fdfe0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa328d5db66dccad29698234879f4d63e"><td class="memTemplParams" colspan="2"><a id="aa328d5db66dccad29698234879f4d63e"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_native_Eigen_type_v&lt; Arg &gt; and MatrixTraits&lt; Arg &gt;::columns==1, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa328d5db66dccad29698234879f4d63e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aa328d5db66dccad29698234879f4d63e">get_element</a> (const Arg &amp;arg, const std::size_t i)</td></tr>
<tr class="memdesc:aa328d5db66dccad29698234879f4d63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i) of one-column matrix arg. <br /></td></tr>
<tr class="separator:aa328d5db66dccad29698234879f4d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cf22b04919ddaac53d9296aa77be2d"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; is_native_Eigen_type_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a38cf22b04919ddaac53d9296aa77be2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a38cf22b04919ddaac53d9296aa77be2d">column</a> (Arg &amp;&amp;arg, const std::size_t index)</td></tr>
<tr class="memdesc:a38cf22b04919ddaac53d9296aa77be2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column <code>index</code> of Arg.  <a href="namespace_open_kalman.html#a38cf22b04919ddaac53d9296aa77be2d">More...</a><br /></td></tr>
<tr class="separator:a38cf22b04919ddaac53d9296aa77be2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="memTemplParams" colspan="2"><a id="a6e7e42a6fae7659f1f67c68979ba9a95"></a>
template&lt;size_t index, typename Arg , std::enable_if_t&lt; is_native_Eigen_type_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6e7e42a6fae7659f1f67c68979ba9a95">column</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column <code>index</code> of Arg. Constexpr index version. <br /></td></tr>
<tr class="separator:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5815ed4167eb12e5f6c0ba16ea941e8f"><td class="memTemplParams" colspan="2"><a id="a5815ed4167eb12e5f6c0ba16ea941e8f"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and std::is_void_v&lt; std::invoke_result_t&lt; Function, std::decay_t&lt; decltype(column(std::declval&lt; Arg &gt;(), 0))&gt; &amp; &gt;&gt; , int &gt; </td></tr>
<tr class="memitem:a5815ed4167eb12e5f6c0ba16ea941e8f"><td class="memTemplItemLeft" align="right" valign="top">Arg &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_columnwise</b> (Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:a5815ed4167eb12e5f6c0ba16ea941e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac99e230059968583a5d4fa00f635a1a"><td class="memTemplParams" colspan="2"><a id="aac99e230059968583a5d4fa00f635a1a"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and not std::is_void_v&lt; std::invoke_result_t&lt; Function, std::decay_t&lt; decltype(column(std::declval&lt; Arg &gt;(), 0))&gt; &amp;&amp; &gt;&gt; , int &gt; </td></tr>
<tr class="memitem:aac99e230059968583a5d4fa00f635a1a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_columnwise</b> (const Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:aac99e230059968583a5d4fa00f635a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf692f460af0aba79c4724f055071756"><td class="memTemplParams" colspan="2"><a id="adf692f460af0aba79c4724f055071756"></a>
template&lt;std::size_t count, typename Function , std::enable_if_t&lt; is_Eigen_matrix_v&lt; std::invoke_result_t&lt; Function &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adf692f460af0aba79c4724f055071756"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_columnwise</b> (const Function &amp;f)</td></tr>
<tr class="separator:adf692f460af0aba79c4724f055071756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc74b68192a9f74d29cd4b224c9ecc6"><td class="memTemplParams" colspan="2"><a id="a4cc74b68192a9f74d29cd4b224c9ecc6"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and std::is_void_v&lt; std::invoke_result_t&lt; Function, std::decay_t&lt; typename MatrixTraits&lt; Arg &gt;::Scalar &gt; &amp; &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4cc74b68192a9f74d29cd4b224c9ecc6"><td class="memTemplItemLeft" align="right" valign="top">Arg &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_coefficientwise</b> (Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:a4cc74b68192a9f74d29cd4b224c9ecc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8c307ca3e471cb3f8fc12cc2abbc60"><td class="memTemplParams" colspan="2"><a id="acd8c307ca3e471cb3f8fc12cc2abbc60"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and std::is_convertible_v&lt; std::invoke_result_t&lt; Function, std::decay_t&lt; typename MatrixTraits&lt; Arg &gt;::Scalar &gt;&gt;, typename MatrixTraits&lt; Arg &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acd8c307ca3e471cb3f8fc12cc2abbc60"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_coefficientwise</b> (const Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:acd8c307ca3e471cb3f8fc12cc2abbc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68507e2002b9a9516a8a11359d051e9e"><td class="memTemplParams" colspan="2"><a id="a68507e2002b9a9516a8a11359d051e9e"></a>
template&lt;std::size_t rows, std::size_t columns, typename Function , std::enable_if_t&lt; std::is_arithmetic_v&lt; std::invoke_result_t&lt; Function &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a68507e2002b9a9516a8a11359d051e9e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_coefficientwise</b> (const Function &amp;f)</td></tr>
<tr class="separator:a68507e2002b9a9516a8a11359d051e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5aa50cd3446c27bc08deacb3456b2d"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , template&lt; typename &gt; typename distribution_type = std::normal_distribution, typename random_number_engine  = std::mt19937, typename... Params, std::enable_if_t&lt; is_Eigen_matrix_v&lt; ReturnType &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3a5aa50cd3446c27bc08deacb3456b2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3a5aa50cd3446c27bc08deacb3456b2d">randomize</a> (Params &amp;&amp;...params)</td></tr>
<tr class="separator:a3a5aa50cd3446c27bc08deacb3456b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b3e2053f3bc33e8c1524e1386e7ff3"><td class="memTemplParams" colspan="2"><a id="a03b3e2053f3bc33e8c1524e1386e7ff3"></a>
template&lt;typename M , std::enable_if_t&lt; is_Eigen_matrix_v&lt; M &gt; or is_EigenDiagonal_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a03b3e2053f3bc33e8c1524e1386e7ff3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenSelfAdjointMatrix</b> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_eigen_self_adjoint_matrix.html">EigenSelfAdjointMatrix</a>&lt; lvalue_or_strict_t&lt; M &gt;, TriangleType::lower &gt;</td></tr>
<tr class="separator:a03b3e2053f3bc33e8c1524e1386e7ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde43f6273e1d6f93a41c9c2001b2c31"><td class="memTemplParams" colspan="2"><a id="afde43f6273e1d6f93a41c9c2001b2c31"></a>
template&lt;typename Arg , unsigned int UpLo&gt; </td></tr>
<tr class="memitem:afde43f6273e1d6f93a41c9c2001b2c31"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenSelfAdjointMatrix</b> (Eigen::SelfAdjointView&lt; Arg, UpLo &gt; &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_eigen_self_adjoint_matrix.html">EigenSelfAdjointMatrix</a>&lt; Arg, UpLo &amp;Eigen::Upper ? TriangleType::upper :TriangleType::lower &gt;</td></tr>
<tr class="separator:afde43f6273e1d6f93a41c9c2001b2c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e41a53de258785d99b3bce7fde2aa32"><td class="memTemplParams" colspan="2"><a id="a8e41a53de258785d99b3bce7fde2aa32"></a>
template&lt;typename ... Args, std::enable_if_t&lt; std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8e41a53de258785d99b3bce7fde2aa32"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a8e41a53de258785d99b3bce7fde2aa32">EigenSelfAdjointMatrix</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_eigen_self_adjoint_matrix.html">EigenSelfAdjointMatrix</a>&lt; Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, internal::constexpr_sqrt(sizeof...(Args)), internal::constexpr_sqrt(sizeof...(Args))&gt;, TriangleType::lower &gt;</td></tr>
<tr class="memdesc:a8e41a53de258785d99b3bce7fde2aa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, deduce a square, self-adjoint matrix. <br /></td></tr>
<tr class="separator:a8e41a53de258785d99b3bce7fde2aa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20346a99b9c6154cfa010224768a9ce3"><td class="memTemplParams" colspan="2"><a id="a20346a99b9c6154cfa010224768a9ce3"></a>
template&lt;TriangleType t = TriangleType::lower, typename M , std::enable_if_t&lt; is_Eigen_matrix_v&lt; M &gt; or is_EigenDiagonal_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a20346a99b9c6154cfa010224768a9ce3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_EigenSelfAdjointMatrix</b> (M &amp;&amp;m)</td></tr>
<tr class="separator:a20346a99b9c6154cfa010224768a9ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340f9e27d6a05b024d287756840cdb5b"><td class="memTemplParams" colspan="2"><a id="a340f9e27d6a05b024d287756840cdb5b"></a>
template&lt;typename M , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a340f9e27d6a05b024d287756840cdb5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_EigenSelfAdjointMatrix</b> (M &amp;&amp;m)</td></tr>
<tr class="separator:a340f9e27d6a05b024d287756840cdb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6780e3e0c9d865701497e29582d0d63d"><td class="memTemplParams" colspan="2"><a id="a6780e3e0c9d865701497e29582d0d63d"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6780e3e0c9d865701497e29582d0d63d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a6780e3e0c9d865701497e29582d0d63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d69614cb80588075406801ae0a8c398"><td class="memTemplParams" colspan="2"><a id="a6d69614cb80588075406801ae0a8c398"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6d69614cb80588075406801ae0a8c398"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adjoint</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a6d69614cb80588075406801ae0a8c398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d12c21618fa40c9195f01ac20ae203"><td class="memTemplParams" colspan="2"><a id="ad1d12c21618fa40c9195f01ac20ae203"></a>
template&lt;typename Arg , typename U , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg &gt; and(is_Eigen_matrix_v&lt; U &gt; or is_EigenTriangularMatrix_v&lt; U &gt; or is_EigenSelfAdjointMatrix_v&lt; U &gt; or is_EigenDiagonal_v&lt; U &gt; or is_FromEuclideanExpr_v&lt; U &gt; or is_ToEuclideanExpr_v&lt; U &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad1d12c21618fa40c9195f01ac20ae203"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rank_update</b> (Arg &amp;&amp;arg, const U &amp;u, const typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; Arg &gt;::Scalar alpha=1)</td></tr>
<tr class="separator:ad1d12c21618fa40c9195f01ac20ae203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6f25c9190e4658793bb610b179bbc9"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0e6f25c9190e4658793bb610b179bbc9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0e6f25c9190e4658793bb610b179bbc9">LQ_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:a0e6f25c9190e4658793bb610b179bbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c9b539547601ae4b033c3ffe425b5b"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae8c9b539547601ae4b033c3ffe425b5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae8c9b539547601ae4b033c3ffe425b5b">QR_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:ae8c9b539547601ae4b033c3ffe425b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e994dba50da74188614b2df30e9302f"><td class="memTemplParams" colspan="2"><a id="a1e994dba50da74188614b2df30e9302f"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg1 &gt;, int &gt;  = 0, std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1e994dba50da74188614b2df30e9302f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (Arg1 &amp;&amp;arg1, Arg2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a1e994dba50da74188614b2df30e9302f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa836ef851d8f3d67cf0d69dfe43a1ff"><td class="memTemplParams" colspan="2"><a id="afa836ef851d8f3d67cf0d69dfe43a1ff"></a>
template&lt;typename Arg , typename S , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg &gt;, int &gt;  = 0, std::enable_if_t&lt; std::is_convertible_v&lt; S, typename MatrixTraits&lt; Arg &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afa836ef851d8f3d67cf0d69dfe43a1ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (Arg &amp;&amp;arg, const S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>)</td></tr>
<tr class="separator:afa836ef851d8f3d67cf0d69dfe43a1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004119c163e602a5d22645f8cf6f5f74"><td class="memTemplParams" colspan="2"><a id="a004119c163e602a5d22645f8cf6f5f74"></a>
template&lt;typename Arg , typename S , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg &gt;, int &gt;  = 0, std::enable_if_t&lt; std::is_convertible_v&lt; S, typename MatrixTraits&lt; Arg &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a004119c163e602a5d22645f8cf6f5f74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>, Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a004119c163e602a5d22645f8cf6f5f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0304d4313027caa5bdbf7d312f929b1"><td class="memTemplParams" colspan="2"><a id="aa0304d4313027caa5bdbf7d312f929b1"></a>
template&lt;typename Arg , typename S , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg &gt;, int &gt;  = 0, std::enable_if_t&lt; std::is_convertible_v&lt; S, typename MatrixTraits&lt; Arg &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa0304d4313027caa5bdbf7d312f929b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (Arg &amp;&amp;arg, const S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>)</td></tr>
<tr class="separator:aa0304d4313027caa5bdbf7d312f929b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a31fb9bea1198ea3250da91a6ce58b0"><td class="memTemplParams" colspan="2"><a id="a4a31fb9bea1198ea3250da91a6ce58b0"></a>
template&lt;typename A , typename B , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; A &gt; or is_EigenTriangularMatrix_v&lt; A &gt;, int &gt;  = 0, std::enable_if_t&lt; is_Eigen_matrix_v&lt; B &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4a31fb9bea1198ea3250da91a6ce58b0"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>solve</b> (A &amp;&amp;a, B &amp;&amp;b)</td></tr>
<tr class="separator:a4a31fb9bea1198ea3250da91a6ce58b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596d0d8ec72e25fb9c5efb90d65ad126"><td class="memTemplParams" colspan="2"><a id="a596d0d8ec72e25fb9c5efb90d65ad126"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg &gt; or is_EigenTriangularMatrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a596d0d8ec72e25fb9c5efb90d65ad126"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce_columns</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a596d0d8ec72e25fb9c5efb90d65ad126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02034b9c631ff6e206820af08cc7e1b"><td class="memTemplParams" colspan="2">template&lt;typename ... Cs, typename Arg , std::enable_if_t&lt;(is_EigenSelfAdjointMatrix_v&lt; Arg &gt; or is_EigenTriangularMatrix_v&lt; Arg &gt; or is_EigenDiagonal_v&lt; Arg &gt;) and std::conjunction_v&lt; is_coefficient&lt; Cs &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab02034b9c631ff6e206820af08cc7e1b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab02034b9c631ff6e206820af08cc7e1b">split_diagonal</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:ab02034b9c631ff6e206820af08cc7e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a self-adjoint, triangular, or diagonal matrix diagonally.  <a href="namespace_open_kalman.html#ab02034b9c631ff6e206820af08cc7e1b">More...</a><br /></td></tr>
<tr class="separator:ab02034b9c631ff6e206820af08cc7e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa562124c539af400938c39532e7b57a1"><td class="memTemplParams" colspan="2">template&lt;typename ... Cs, typename Arg , std::enable_if_t&lt;(is_EigenSelfAdjointMatrix_v&lt; Arg &gt; or is_EigenTriangularMatrix_v&lt; Arg &gt; or is_EigenDiagonal_v&lt; Arg &gt;) and std::conjunction_v&lt; is_coefficient&lt; Cs &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa562124c539af400938c39532e7b57a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aa562124c539af400938c39532e7b57a1">split_vertical</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:aa562124c539af400938c39532e7b57a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a self-adjoint, triangular, or diagonal matrix diagonally.  <a href="namespace_open_kalman.html#aa562124c539af400938c39532e7b57a1">More...</a><br /></td></tr>
<tr class="separator:aa562124c539af400938c39532e7b57a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203fdef518a6b51c72dc60d8d3274543"><td class="memTemplParams" colspan="2"><a id="a203fdef518a6b51c72dc60d8d3274543"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg &gt; or is_EigenTriangularMatrix_v&lt; Arg &gt; or is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a203fdef518a6b51c72dc60d8d3274543"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_columnwise</b> (Arg &amp;&amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:a203fdef518a6b51c72dc60d8d3274543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2416ba939328801e4b2bf65f3baa855"><td class="memTemplParams" colspan="2"><a id="ad2416ba939328801e4b2bf65f3baa855"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; Arg &gt; or is_EigenTriangularMatrix_v&lt; Arg &gt; or is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad2416ba939328801e4b2bf65f3baa855"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_coefficientwise</b> (Arg &amp;&amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:ad2416ba939328801e4b2bf65f3baa855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15684eb3652485d019597e458a7a002c"><td class="memTemplParams" colspan="2"><a id="a15684eb3652485d019597e458a7a002c"></a>
template&lt;typename M , std::enable_if_t&lt; is_Eigen_matrix_v&lt; M &gt; or is_EigenDiagonal_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a15684eb3652485d019597e458a7a002c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenTriangularMatrix</b> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_eigen_triangular_matrix.html">EigenTriangularMatrix</a>&lt; lvalue_or_strict_t&lt; M &gt;, TriangleType::lower &gt;</td></tr>
<tr class="separator:a15684eb3652485d019597e458a7a002c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa248b07f0de8f68fb3dc0aea1e5dcfe3"><td class="memTemplParams" colspan="2"><a id="aa248b07f0de8f68fb3dc0aea1e5dcfe3"></a>
template&lt;typename Arg , unsigned int UpLo&gt; </td></tr>
<tr class="memitem:aa248b07f0de8f68fb3dc0aea1e5dcfe3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenTriangularMatrix</b> (const Eigen::TriangularView&lt; Arg, UpLo &gt; &amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_eigen_triangular_matrix.html">EigenTriangularMatrix</a>&lt; Arg, UpLo &amp;Eigen::Upper ? TriangleType::upper :TriangleType::lower &gt;</td></tr>
<tr class="separator:aa248b07f0de8f68fb3dc0aea1e5dcfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c4320a6d078ab6746ccd109c9b9521"><td class="memTemplParams" colspan="2"><a id="a87c4320a6d078ab6746ccd109c9b9521"></a>
template&lt;typename ... Args, std::enable_if_t&lt; std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a87c4320a6d078ab6746ccd109c9b9521"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a87c4320a6d078ab6746ccd109c9b9521">EigenTriangularMatrix</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_eigen_triangular_matrix.html">EigenTriangularMatrix</a>&lt; Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, internal::constexpr_sqrt(sizeof...(Args)), internal::constexpr_sqrt(sizeof...(Args))&gt;, TriangleType::lower &gt;</td></tr>
<tr class="memdesc:a87c4320a6d078ab6746ccd109c9b9521"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, deduce a square, lower triangular matrix. <br /></td></tr>
<tr class="separator:a87c4320a6d078ab6746ccd109c9b9521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85241f879d6376793d6bbe364e0b9023"><td class="memTemplParams" colspan="2"><a id="a85241f879d6376793d6bbe364e0b9023"></a>
template&lt;TriangleType t = TriangleType::lower, typename M , std::enable_if_t&lt; is_Eigen_matrix_v&lt; M &gt; or is_EigenDiagonal_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a85241f879d6376793d6bbe364e0b9023"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_EigenTriangularMatrix</b> (M &amp;&amp;m)</td></tr>
<tr class="separator:a85241f879d6376793d6bbe364e0b9023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc817632f41722c825f5ad1e955cd32"><td class="memTemplParams" colspan="2"><a id="accc817632f41722c825f5ad1e955cd32"></a>
template&lt;typename M , std::enable_if_t&lt; is_EigenTriangularMatrix_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:accc817632f41722c825f5ad1e955cd32"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_EigenTriangularMatrix</b> (M &amp;&amp;m)</td></tr>
<tr class="separator:accc817632f41722c825f5ad1e955cd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e51532ed67c9b8cb6efa5b291b23820"><td class="memTemplParams" colspan="2"><a id="a1e51532ed67c9b8cb6efa5b291b23820"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenTriangularMatrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1e51532ed67c9b8cb6efa5b291b23820"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a1e51532ed67c9b8cb6efa5b291b23820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81650bf4c9ff48d2f5917305fce29828"><td class="memTemplParams" colspan="2"><a id="a81650bf4c9ff48d2f5917305fce29828"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenTriangularMatrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a81650bf4c9ff48d2f5917305fce29828"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adjoint</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a81650bf4c9ff48d2f5917305fce29828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d80f06446226aedba4b88fe3bc9429"><td class="memTemplParams" colspan="2"><a id="a32d80f06446226aedba4b88fe3bc9429"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenZero_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a32d80f06446226aedba4b88fe3bc9429"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>determinant</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a32d80f06446226aedba4b88fe3bc9429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adb366aaf6237565dba6d2673b42dcf"><td class="memTemplParams" colspan="2"><a id="a9adb366aaf6237565dba6d2673b42dcf"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenZero_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9adb366aaf6237565dba6d2673b42dcf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trace</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a9adb366aaf6237565dba6d2673b42dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c9a8bd6540c347ca9139c795fb55fd"><td class="memTemplParams" colspan="2"><a id="ab6c9a8bd6540c347ca9139c795fb55fd"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenZero_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab6c9a8bd6540c347ca9139c795fb55fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab6c9a8bd6540c347ca9139c795fb55fd">get_element</a> (const Arg &amp;, const std::size_t, const std::size_t)</td></tr>
<tr class="memdesc:ab6c9a8bd6540c347ca9139c795fb55fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element of a <a class="el" href="struct_open_kalman_1_1_eigen_zero.html">EigenZero</a> matrix. Always 0. <br /></td></tr>
<tr class="separator:ab6c9a8bd6540c347ca9139c795fb55fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbffa6db68dfb470e01bee5b2a1ba068"><td class="memTemplParams" colspan="2"><a id="acbffa6db68dfb470e01bee5b2a1ba068"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_EigenZero_v&lt; Arg &gt; and MatrixTraits&lt; Arg &gt;::columns==1, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acbffa6db68dfb470e01bee5b2a1ba068"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#acbffa6db68dfb470e01bee5b2a1ba068">get_element</a> (const Arg &amp;, const std::size_t)</td></tr>
<tr class="memdesc:acbffa6db68dfb470e01bee5b2a1ba068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element of a one-column <a class="el" href="struct_open_kalman_1_1_eigen_zero.html">EigenZero</a> matrix. Always 0. <br /></td></tr>
<tr class="separator:acbffa6db68dfb470e01bee5b2a1ba068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2de8012e92c061ccf85c60b036d8af"><td class="memTemplParams" colspan="2"><a id="a6d2de8012e92c061ccf85c60b036d8af"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt;(OpenKalman::is_zero_v&lt; Arg1 &gt; and OpenKalman::is_Eigen_matrix_v&lt; Arg2 &gt;) or(OpenKalman::is_Eigen_matrix_v&lt; Arg1 &gt; and OpenKalman::is_zero_v&lt; Arg2 &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6d2de8012e92c061ccf85c60b036d8af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const Arg1 &amp;arg1, const Arg2 &amp;arg2)</td></tr>
<tr class="separator:a6d2de8012e92c061ccf85c60b036d8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c28942113ef1bacaefcb504f2a2bc6b"><td class="memTemplParams" colspan="2"><a id="a5c28942113ef1bacaefcb504f2a2bc6b"></a>
template&lt;typename Arg , std::enable_if_t&lt; OpenKalman::is_EigenZero_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5c28942113ef1bacaefcb504f2a2bc6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a5c28942113ef1bacaefcb504f2a2bc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94023ee812f40709ac61cdd392d105f3"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; is_FromEuclideanExpr_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a94023ee812f40709ac61cdd392d105f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a94023ee812f40709ac61cdd392d105f3">to_Euclidean</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a94023ee812f40709ac61cdd392d105f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b41be5ac82018f99a2e06e2ea391e6"><td class="memTemplParams" colspan="2"><a id="ab8b41be5ac82018f99a2e06e2ea391e6"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_ToEuclideanExpr_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab8b41be5ac82018f99a2e06e2ea391e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_Euclidean</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:ab8b41be5ac82018f99a2e06e2ea391e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d68d378015402b26f87dc9de25a32ff"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , std::enable_if_t&lt; is_ToEuclideanExpr_v&lt; A &gt; or is_FromEuclideanExpr_v&lt; A &gt;, int &gt;  = 0, std::enable_if_t&lt; is_Eigen_matrix_v&lt; B &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6d68d378015402b26f87dc9de25a32ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6d68d378015402b26f87dc9de25a32ff">solve</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept</td></tr>
<tr class="memdesc:a6d68d378015402b26f87dc9de25a32ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a x = b for x (A is a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a>, B is a vector type).  <a href="namespace_open_kalman.html#a6d68d378015402b26f87dc9de25a32ff">More...</a><br /></td></tr>
<tr class="separator:a6d68d378015402b26f87dc9de25a32ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbcdf62b61946701b83f882023bb301"><td class="memTemplParams" colspan="2"><a id="abbbcdf62b61946701b83f882023bb301"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_ToEuclideanExpr_v&lt; Arg &gt; or is_FromEuclideanExpr_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:abbbcdf62b61946701b83f882023bb301"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>column</b> (Arg &amp;&amp;arg, const std::size_t index)</td></tr>
<tr class="separator:abbbcdf62b61946701b83f882023bb301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee64f1834343ba3a68d3c7384f151065"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_ToEuclideanExpr_v&lt; Arg &gt; or is_FromEuclideanExpr_v&lt; Arg &gt;, int &gt;  = 0, std::enable_if_t&lt; std::is_void_v&lt; std::invoke_result_t&lt; Function, decltype(column(std::declval&lt; Arg &amp; &gt;(), 0))&amp; &gt;&gt; , int &gt; </td></tr>
<tr class="memitem:aee64f1834343ba3a68d3c7384f151065"><td class="memTemplItemLeft" align="right" valign="top">Arg &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aee64f1834343ba3a68d3c7384f151065">apply_columnwise</a> (Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:aee64f1834343ba3a68d3c7384f151065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640b7b2128b6977ef213141b052908e3"><td class="memTemplParams" colspan="2"><a id="a640b7b2128b6977ef213141b052908e3"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_ToEuclideanExpr_v&lt; Arg &gt; or is_FromEuclideanExpr_v&lt; Arg &gt;, int &gt;  = 0, std::enable_if_t&lt; not std::is_void_v&lt; std::invoke_result_t&lt; Function, std::decay_t&lt; decltype(column(std::declval&lt; const Arg &amp; &gt;(), 0))&gt; &amp;&amp; &gt;&gt; , int &gt; </td></tr>
<tr class="memitem:a640b7b2128b6977ef213141b052908e3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_columnwise</b> (const Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:a640b7b2128b6977ef213141b052908e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e7180576122447f062fbf9a1047a9e"><td class="memTemplParams" colspan="2"><a id="a82e7180576122447f062fbf9a1047a9e"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_ToEuclideanExpr_v&lt; Arg &gt; or is_FromEuclideanExpr_v&lt; Arg &gt;, int &gt;  = 0, std::enable_if_t&lt; std::is_arithmetic_v&lt; std::invoke_result_t&lt; Function, std::decay_t&lt; typename MatrixTraits&lt; Arg &gt;::Scalar &gt; &amp;&amp; &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a82e7180576122447f062fbf9a1047a9e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_coefficientwise</b> (const Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:a82e7180576122447f062fbf9a1047a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74300da0388f3c6092a9c6ab0c73ce8a"><td class="memTemplParams" colspan="2"><a id="a74300da0388f3c6092a9c6ab0c73ce8a"></a>
template&lt;typename M , std::enable_if_t&lt; is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a74300da0388f3c6092a9c6ab0c73ce8a"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>base_matrix</b> (M &amp;&amp;m) noexcept</td></tr>
<tr class="separator:a74300da0388f3c6092a9c6ab0c73ce8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579e1ec33564b5e46be63b872b9aad5f"><td class="memTemplParams" colspan="2"><a id="a579e1ec33564b5e46be63b872b9aad5f"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_covariance_v&lt; Arg &gt; and not is_square_root_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a579e1ec33564b5e46be63b872b9aad5f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>square_root</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a579e1ec33564b5e46be63b872b9aad5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206fbe83e03311e2b265a5d28bf0eec9"><td class="memTemplParams" colspan="2"><a id="a206fbe83e03311e2b265a5d28bf0eec9"></a>
template&lt;typename Arg , std::enable_if_t&lt; is_covariance_v&lt; Arg &gt; and is_square_root_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a206fbe83e03311e2b265a5d28bf0eec9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>square</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a206fbe83e03311e2b265a5d28bf0eec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="memTemplParams" colspan="2"><a id="a82c47a34ff6b7584fb93a6ede9db6a12"></a>
template&lt;typename M , typename ... Ms, std::enable_if_t&lt; std::conjunction_v&lt; is_covariance&lt; M &gt;, is_covariance&lt; Ms &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a82c47a34ff6b7584fb93a6ede9db6a12">concatenate</a> (M &amp;&amp;m, Ms &amp;&amp;... mN) noexcept</td></tr>
<tr class="memdesc:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a> objects diagonally. <br /></td></tr>
<tr class="separator:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf46841af75eee02bfd52c1708831b7"><td class="memTemplParams" colspan="2">template&lt;typename ... Cs, typename M , std::enable_if_t&lt; is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2bf46841af75eee02bfd52c1708831b7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2bf46841af75eee02bfd52c1708831b7">split_diagonal</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a2bf46841af75eee02bfd52c1708831b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a> diagonally.  <a href="namespace_open_kalman.html#a2bf46841af75eee02bfd52c1708831b7">More...</a><br /></td></tr>
<tr class="separator:a2bf46841af75eee02bfd52c1708831b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dba71f80c4270929d21e416f1c8739"><td class="memTemplParams" colspan="2">template&lt;typename ... Cs, typename M , std::enable_if_t&lt; is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a68dba71f80c4270929d21e416f1c8739"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a68dba71f80c4270929d21e416f1c8739">split_vertical</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a68dba71f80c4270929d21e416f1c8739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a> vertically. Result is a tuple of typed matrices.  <a href="namespace_open_kalman.html#a68dba71f80c4270929d21e416f1c8739">More...</a><br /></td></tr>
<tr class="separator:a68dba71f80c4270929d21e416f1c8739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313e2b8a742da23f4623c6bc4c295d5b"><td class="memTemplParams" colspan="2">template&lt;typename ... Cs, typename M , std::enable_if_t&lt; is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a313e2b8a742da23f4623c6bc4c295d5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a313e2b8a742da23f4623c6bc4c295d5b">split_horizontal</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a313e2b8a742da23f4623c6bc4c295d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a> vertically. Result is a tuple of typed matrices.  <a href="namespace_open_kalman.html#a313e2b8a742da23f4623c6bc4c295d5b">More...</a><br /></td></tr>
<tr class="separator:a313e2b8a742da23f4623c6bc4c295d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f7c6166aa7f40f7170a79bc1a116eb"><td class="memTemplParams" colspan="2"><a id="a11f7c6166aa7f40f7170a79bc1a116eb"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_covariance_v&lt; Arg &gt; and is_typed_matrix_v&lt; std::invoke_result_t&lt; Function, std::decay_t&lt; decltype(column&lt; 0 &gt;(std::declval&lt; Arg &gt;()))&gt;&gt; , int &gt; </td></tr>
<tr class="memitem:a11f7c6166aa7f40f7170a79bc1a116eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_columnwise</b> (Arg &amp;&amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:a11f7c6166aa7f40f7170a79bc1a116eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfb08272538904db9518f9b60e563a6"><td class="memTemplParams" colspan="2"><a id="a0bfb08272538904db9518f9b60e563a6"></a>
template&lt;typename Cov , std::enable_if_t&lt; is_covariance_v&lt; Cov &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0bfb08272538904db9518f9b60e563a6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const Cov &amp;c)</td></tr>
<tr class="separator:a0bfb08272538904db9518f9b60e563a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0fb0ebb64b857004cc5967e75bcf40"><td class="memTemplParams" colspan="2"><a id="abf0fb0ebb64b857004cc5967e75bcf40"></a>
template&lt;typename M , typename Cov , std::enable_if_t&lt; is_typed_matrix_v&lt; M &gt; and is_covariance_v&lt; Cov &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:abf0fb0ebb64b857004cc5967e75bcf40"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#abf0fb0ebb64b857004cc5967e75bcf40">operator*</a> (M &amp;&amp;m, Cov &amp;&amp;cov) noexcept</td></tr>
<tr class="memdesc:abf0fb0ebb64b857004cc5967e75bcf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a typed matrix by a compatible covariance. <br /></td></tr>
<tr class="separator:abf0fb0ebb64b857004cc5967e75bcf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78212f67c3e24b3314a2c11a5c58e4b"><td class="memTemplParams" colspan="2"><a id="ae78212f67c3e24b3314a2c11a5c58e4b"></a>
template&lt;typename Cov , typename M , std::enable_if_t&lt; is_covariance_v&lt; Cov &gt; and is_typed_matrix_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae78212f67c3e24b3314a2c11a5c58e4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae78212f67c3e24b3314a2c11a5c58e4b">operator*</a> (Cov &amp;&amp;cov, M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:ae78212f67c3e24b3314a2c11a5c58e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a covariance type by a typed matrix. If the typed matrix is a mean, the result is wrapped. <br /></td></tr>
<tr class="separator:ae78212f67c3e24b3314a2c11a5c58e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f6010166be08b5ded8fd65f108da49"><td class="memTemplParams" colspan="2"><a id="a85f6010166be08b5ded8fd65f108da49"></a>
template&lt;typename M , typename S , std::enable_if_t&lt; is_covariance_v&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a85f6010166be08b5ded8fd65f108da49"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a85f6010166be08b5ded8fd65f108da49">operator*</a> (M &amp;&amp;m, const S s) noexcept</td></tr>
<tr class="memdesc:a85f6010166be08b5ded8fd65f108da49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a covariance type by a scalar. <br /></td></tr>
<tr class="separator:a85f6010166be08b5ded8fd65f108da49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b95d4c1f3025e4b8b4ca458641f0cf"><td class="memTemplParams" colspan="2"><a id="a45b95d4c1f3025e4b8b4ca458641f0cf"></a>
template&lt;typename S , typename M , std::enable_if_t&lt; std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt; and is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a45b95d4c1f3025e4b8b4ca458641f0cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a45b95d4c1f3025e4b8b4ca458641f0cf">operator*</a> (const S s, M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a45b95d4c1f3025e4b8b4ca458641f0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a scalar by a self-adjoint-type covariance type. <br /></td></tr>
<tr class="separator:a45b95d4c1f3025e4b8b4ca458641f0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a6ba1e817ff8e11542c4b7c9782246"><td class="memTemplParams" colspan="2"><a id="a06a6ba1e817ff8e11542c4b7c9782246"></a>
template&lt;typename M , typename S , std::enable_if_t&lt; is_covariance_v&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a06a6ba1e817ff8e11542c4b7c9782246"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a06a6ba1e817ff8e11542c4b7c9782246">operator/</a> (M &amp;&amp;m, const S s)</td></tr>
<tr class="memdesc:a06a6ba1e817ff8e11542c4b7c9782246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a self-adjoint-type covariance type by a scalar. <br /></td></tr>
<tr class="separator:a06a6ba1e817ff8e11542c4b7c9782246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415939aa93212817bac5ee06a0630e04"><td class="memTemplParams" colspan="2"><a id="a415939aa93212817bac5ee06a0630e04"></a>
template&lt;typename M , std::enable_if_t&lt; is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a415939aa93212817bac5ee06a0630e04"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a415939aa93212817bac5ee06a0630e04">operator-</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a415939aa93212817bac5ee06a0630e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate a covariance. <br /></td></tr>
<tr class="separator:a415939aa93212817bac5ee06a0630e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e153bf91d3852a2e8e3b1a4d0fc15a"><td class="memTemplParams" colspan="2"><a id="a25e153bf91d3852a2e8e3b1a4d0fc15a"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt; is_covariance_v&lt; Arg1 &gt; and is_covariance_v&lt; Arg2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a25e153bf91d3852a2e8e3b1a4d0fc15a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a25e153bf91d3852a2e8e3b1a4d0fc15a">operator==</a> (Arg1 &amp;&amp;arg1, Arg2 &amp;&amp;arg2)</td></tr>
<tr class="memdesc:a25e153bf91d3852a2e8e3b1a4d0fc15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a25e153bf91d3852a2e8e3b1a4d0fc15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="memTemplParams" colspan="2"><a id="ac245a6153e8c8dee4c412d9a86e70b9b"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; is_covariance_v&lt; V1 &gt; and is_covariance_v&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac245a6153e8c8dee4c412d9a86e70b9b">operator!=</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f2335ea8a758c0b229c54cadc27aa1"><td class="memTemplParams" colspan="2">template&lt;typename M , typename S , std::enable_if_t&lt; is_covariance_v&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a77f2335ea8a758c0b229c54cadc27aa1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a> (M &amp;&amp;m, const S s)</td></tr>
<tr class="separator:a77f2335ea8a758c0b229c54cadc27aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f44bd141f1e2b9b65432a633d9180e2"><td class="memTemplParams" colspan="2">template&lt;typename M , typename S , std::enable_if_t&lt; is_covariance_v&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6f44bd141f1e2b9b65432a633d9180e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6f44bd141f1e2b9b65432a633d9180e2">inverse_scale</a> (M &amp;&amp;m, const S s)</td></tr>
<tr class="separator:a6f44bd141f1e2b9b65432a633d9180e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be486e53ad3cb44d7ea46c4201f4ce5"><td class="memTemplParams" colspan="2">template&lt;typename M , typename A , std::enable_if_t&lt; is_covariance_v&lt; M &gt; and is_typed_matrix_v&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3be486e53ad3cb44d7ea46c4201f4ce5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3be486e53ad3cb44d7ea46c4201f4ce5">scale</a> (M &amp;&amp;m, A &amp;&amp;a)</td></tr>
<tr class="separator:a3be486e53ad3cb44d7ea46c4201f4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16f5d48f74dec8a73700b18a26e94b3"><td class="memTemplParams" colspan="2"><a id="ae16f5d48f74dec8a73700b18a26e94b3"></a>
template&lt;typename ... Vs, std::enable_if_t&lt; std::conjunction_v&lt; is_typed_matrix&lt; Vs &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae16f5d48f74dec8a73700b18a26e94b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae16f5d48f74dec8a73700b18a26e94b3">concatenate</a> (Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:ae16f5d48f74dec8a73700b18a26e94b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more typed matrices vertically. (Synonym for concatenate_vertical.) <br /></td></tr>
<tr class="separator:ae16f5d48f74dec8a73700b18a26e94b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa5df002cc4298b5debd50b238e2e94"><td class="memTemplParams" colspan="2"><a id="a3fa5df002cc4298b5debd50b238e2e94"></a>
template&lt;size_t index, typename Arg , std::enable_if_t&lt; is_typed_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3fa5df002cc4298b5debd50b238e2e94"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>column</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a3fa5df002cc4298b5debd50b238e2e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6061f14653c56ed7cc68b2615d5e3717"><td class="memTemplParams" colspan="2"><a id="a6061f14653c56ed7cc68b2615d5e3717"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_typed_matrix_v&lt; Arg &gt;, int &gt;  = 0, std::enable_if_t&lt; std::is_void_v&lt; std::invoke_result_t&lt; Function, std::decay_t&lt; typename MatrixTraits&lt; Arg &gt;::Scalar &gt; &amp; &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6061f14653c56ed7cc68b2615d5e3717"><td class="memTemplItemLeft" align="right" valign="top">Arg &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_coefficientwise</b> (Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:a6061f14653c56ed7cc68b2615d5e3717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545052d9d62e60171a20c7704d65b1a0"><td class="memTemplParams" colspan="2"><a id="a545052d9d62e60171a20c7704d65b1a0"></a>
template&lt;typename V , std::enable_if_t&lt; is_typed_matrix_v&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a545052d9d62e60171a20c7704d65b1a0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a545052d9d62e60171a20c7704d65b1a0">operator&lt;&lt;</a> (std::ostream &amp;os, const V &amp;v)</td></tr>
<tr class="memdesc:a545052d9d62e60171a20c7704d65b1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the vector to a stream. <br /></td></tr>
<tr class="separator:a545052d9d62e60171a20c7704d65b1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039f354d5cd736da949ab03453e8e7ec"><td class="memTemplParams" colspan="2"><a id="a039f354d5cd736da949ab03453e8e7ec"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; is_typed_matrix_v&lt; V1 &gt; and is_typed_matrix_v&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a039f354d5cd736da949ab03453e8e7ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a039f354d5cd736da949ab03453e8e7ec">operator+</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a039f354d5cd736da949ab03453e8e7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two typed matrices. If the operands are of different types, the result will be a regular typed matrix. <br /></td></tr>
<tr class="separator:a039f354d5cd736da949ab03453e8e7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e926152518ac5b9857395881d6495f7"><td class="memTemplParams" colspan="2"><a id="a2e926152518ac5b9857395881d6495f7"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; is_typed_matrix_v&lt; V1 &gt; and is_typed_matrix_v&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2e926152518ac5b9857395881d6495f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2e926152518ac5b9857395881d6495f7">operator-</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a2e926152518ac5b9857395881d6495f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two typed matrices. The result is a regular typed matrix unless both operands are <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="A typed vector.">EuclideanMean</a>. <br /></td></tr>
<tr class="separator:a2e926152518ac5b9857395881d6495f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb8155162764262a5f0ecdb8b893eba"><td class="memTemplParams" colspan="2"><a id="a3cb8155162764262a5f0ecdb8b893eba"></a>
template&lt;typename V , typename S , std::enable_if_t&lt; is_typed_matrix_v&lt; V &gt;, int &gt;  = 0, std::enable_if_t&lt; std::is_convertible_v&lt; S, const typename MatrixTraits&lt; V &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3cb8155162764262a5f0ecdb8b893eba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3cb8155162764262a5f0ecdb8b893eba">operator*</a> (V &amp;&amp;v, S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>)</td></tr>
<tr class="memdesc:a3cb8155162764262a5f0ecdb8b893eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a typed matrix by a scalar. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:a3cb8155162764262a5f0ecdb8b893eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d674852dccaeb05bc1e62662f29c66"><td class="memTemplParams" colspan="2"><a id="ae4d674852dccaeb05bc1e62662f29c66"></a>
template&lt;typename V , typename S , std::enable_if_t&lt; is_typed_matrix_v&lt; V &gt;, int &gt;  = 0, std::enable_if_t&lt; std::is_convertible_v&lt; S, const typename MatrixTraits&lt; V &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae4d674852dccaeb05bc1e62662f29c66"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae4d674852dccaeb05bc1e62662f29c66">operator*</a> (S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>, V &amp;&amp;v)</td></tr>
<tr class="memdesc:ae4d674852dccaeb05bc1e62662f29c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a scalar by a typed matrix. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:ae4d674852dccaeb05bc1e62662f29c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af801ad51053cd6bc864438eb226d8c20"><td class="memTemplParams" colspan="2"><a id="af801ad51053cd6bc864438eb226d8c20"></a>
template&lt;typename V , typename S , std::enable_if_t&lt; is_typed_matrix_v&lt; V &gt;, int &gt;  = 0, std::enable_if_t&lt; std::is_convertible_v&lt; S, const typename MatrixTraits&lt; V &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af801ad51053cd6bc864438eb226d8c20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af801ad51053cd6bc864438eb226d8c20">operator/</a> (V &amp;&amp;v, S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>)</td></tr>
<tr class="memdesc:af801ad51053cd6bc864438eb226d8c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a typed matrix by a scalar. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:af801ad51053cd6bc864438eb226d8c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51481c7e308adfcf8f33c4891f35618"><td class="memTemplParams" colspan="2"><a id="ae51481c7e308adfcf8f33c4891f35618"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; is_typed_matrix_v&lt; V1 &gt; and is_typed_matrix_v&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae51481c7e308adfcf8f33c4891f35618"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae51481c7e308adfcf8f33c4891f35618">operator*</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:ae51481c7e308adfcf8f33c4891f35618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a typed matrix by another typed matrix. The result is a regular typed matrix unless the first operand is <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="A typed vector.">EuclideanMean</a>. <br /></td></tr>
<tr class="separator:ae51481c7e308adfcf8f33c4891f35618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eaac6005b36334fa28a5c223cbe545"><td class="memTemplParams" colspan="2"><a id="a08eaac6005b36334fa28a5c223cbe545"></a>
template&lt;typename V , std::enable_if_t&lt; is_typed_matrix_v&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a08eaac6005b36334fa28a5c223cbe545"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a08eaac6005b36334fa28a5c223cbe545">operator-</a> (V &amp;&amp;v)</td></tr>
<tr class="memdesc:a08eaac6005b36334fa28a5c223cbe545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate a vector object. The result is a regular typed matrix unless the operand is <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="A typed vector.">EuclideanMean</a>. <br /></td></tr>
<tr class="separator:a08eaac6005b36334fa28a5c223cbe545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba759789716e968b7d516cfc2c2efe8"><td class="memTemplParams" colspan="2"><a id="a5ba759789716e968b7d516cfc2c2efe8"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; is_typed_matrix_v&lt; V1 &gt; and is_typed_matrix_v&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5ba759789716e968b7d516cfc2c2efe8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5ba759789716e968b7d516cfc2c2efe8">operator==</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a5ba759789716e968b7d516cfc2c2efe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a5ba759789716e968b7d516cfc2c2efe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac012d357f1dc0a72d7a6fb43d0169998"><td class="memTemplParams" colspan="2"><a id="ac012d357f1dc0a72d7a6fb43d0169998"></a>
template&lt;typename T , std::size_t order&gt; </td></tr>
<tr class="memitem:ac012d357f1dc0a72d7a6fb43d0169998"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac012d357f1dc0a72d7a6fb43d0169998">is_linearized_function_v</a> = <a class="el" href="struct_open_kalman_1_1is__linearized__function.html">is_linearized_function</a>&lt;T, order&gt;::value</td></tr>
<tr class="memdesc:ac012d357f1dc0a72d7a6fb43d0169998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__linearized__function.html" title="Whether an object is a linearized function (with defined Jacobian and optionally Hessian functions).">is_linearized_function</a>. <br /></td></tr>
<tr class="separator:ac012d357f1dc0a72d7a6fb43d0169998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac7f227b2f13e813d6e60695f05b004"><td class="memTemplParams" colspan="2"><a id="a5ac7f227b2f13e813d6e60695f05b004"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ac7f227b2f13e813d6e60695f05b004"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5ac7f227b2f13e813d6e60695f05b004">is_perturbation_v</a> = <a class="el" href="struct_open_kalman_1_1is__perturbation.html">is_perturbation</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a5ac7f227b2f13e813d6e60695f05b004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__perturbation.html">is_perturbation</a>. <br /></td></tr>
<tr class="separator:a5ac7f227b2f13e813d6e60695f05b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22f3a6e7696ddcaf38e145481bea266"><td class="memTemplParams" colspan="2"><a id="af22f3a6e7696ddcaf38e145481bea266"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af22f3a6e7696ddcaf38e145481bea266"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_ToEuclideanExpr_v</b> = <a class="el" href="struct_open_kalman_1_1is___to_euclidean_expr.html">is_ToEuclideanExpr</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af22f3a6e7696ddcaf38e145481bea266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4929c1093d2867abc4c2e2e832b271a2"><td class="memTemplParams" colspan="2"><a id="a4929c1093d2867abc4c2e2e832b271a2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4929c1093d2867abc4c2e2e832b271a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_FromEuclideanExpr_v</b> = <a class="el" href="struct_open_kalman_1_1is___from_euclidean_expr.html">is_FromEuclideanExpr</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a4929c1093d2867abc4c2e2e832b271a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79f97a6962f0df87606161acd613ffe"><td class="memTemplParams" colspan="2"><a id="ad79f97a6962f0df87606161acd613ffe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad79f97a6962f0df87606161acd613ffe"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_EigenSelfAdjointMatrix_v</b> = <a class="el" href="struct_open_kalman_1_1is___eigen_self_adjoint_matrix.html">is_EigenSelfAdjointMatrix</a>&lt;T&gt;::value</td></tr>
<tr class="separator:ad79f97a6962f0df87606161acd613ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea9daa394123fa571a19f95ba80ae76"><td class="memTemplParams" colspan="2"><a id="a8ea9daa394123fa571a19f95ba80ae76"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ea9daa394123fa571a19f95ba80ae76"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_Eigen_upper_storage_triangle_v</b> = <a class="el" href="struct_open_kalman_1_1is___eigen__upper__storage__triangle.html">is_Eigen_upper_storage_triangle</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a8ea9daa394123fa571a19f95ba80ae76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4826ccc0043ab9e6416c3660609326b"><td class="memTemplParams" colspan="2"><a id="af4826ccc0043ab9e6416c3660609326b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4826ccc0043ab9e6416c3660609326b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_Eigen_lower_storage_triangle_v</b> = <a class="el" href="struct_open_kalman_1_1is___eigen__lower__storage__triangle.html">is_Eigen_lower_storage_triangle</a>&lt;T&gt;::value</td></tr>
<tr class="separator:af4826ccc0043ab9e6416c3660609326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5733481c10365fd756153c9e432e6ab7"><td class="memTemplParams" colspan="2"><a id="a5733481c10365fd756153c9e432e6ab7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5733481c10365fd756153c9e432e6ab7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_EigenTriangularMatrix_v</b> = <a class="el" href="struct_open_kalman_1_1is___eigen_triangular_matrix.html">is_EigenTriangularMatrix</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a5733481c10365fd756153c9e432e6ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd0682b843738414ec2086b852b6076"><td class="memTemplParams" colspan="2"><a id="afcd0682b843738414ec2086b852b6076"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afcd0682b843738414ec2086b852b6076"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_EigenDiagonal_v</b> = <a class="el" href="struct_open_kalman_1_1is___eigen_diagonal.html">is_EigenDiagonal</a>&lt;T&gt;::value</td></tr>
<tr class="separator:afcd0682b843738414ec2086b852b6076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe98ed096b9954e74ea72117988236d"><td class="memTemplParams" colspan="2"><a id="acbe98ed096b9954e74ea72117988236d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbe98ed096b9954e74ea72117988236d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_EigenZero_v</b> = <a class="el" href="struct_open_kalman_1_1is___eigen_zero.html">is_EigenZero</a>&lt;T&gt;::value</td></tr>
<tr class="separator:acbe98ed096b9954e74ea72117988236d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88af45c11a7159c14e3c846b16f6095"><td class="memTemplParams" colspan="2"><a id="aa88af45c11a7159c14e3c846b16f6095"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa88af45c11a7159c14e3c846b16f6095"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aa88af45c11a7159c14e3c846b16f6095">is_native_Eigen_type_v</a> = <a class="el" href="struct_open_kalman_1_1is__native___eigen__type.html">is_native_Eigen_type</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:aa88af45c11a7159c14e3c846b16f6095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__native___eigen__type.html" title="Whether an object is a native Eigen::MatrixBase type in Eigen3.">is_native_Eigen_type</a>. <br /></td></tr>
<tr class="separator:aa88af45c11a7159c14e3c846b16f6095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34687663d6329761261117d7dac276f9"><td class="memTemplParams" colspan="2"><a id="a34687663d6329761261117d7dac276f9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34687663d6329761261117d7dac276f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a34687663d6329761261117d7dac276f9">is_Eigen_matrix_v</a> = <a class="el" href="struct_open_kalman_1_1is___eigen__matrix.html">is_Eigen_matrix</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a34687663d6329761261117d7dac276f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__native___eigen__type.html" title="Whether an object is a native Eigen::MatrixBase type in Eigen3.">is_native_Eigen_type</a>. <br /></td></tr>
<tr class="separator:a34687663d6329761261117d7dac276f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f14dd9b245097248c05633a97fcbf0"><td class="memTemplParams" colspan="2"><a id="a38f14dd9b245097248c05633a97fcbf0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38f14dd9b245097248c05633a97fcbf0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a38f14dd9b245097248c05633a97fcbf0">is_covariance_v</a> = <a class="el" href="struct_open_kalman_1_1is__covariance.html">is_covariance</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a38f14dd9b245097248c05633a97fcbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__covariance.html" title="Whether an object is a Covariance or SquareRootCovariance.">is_covariance</a>. <br /></td></tr>
<tr class="separator:a38f14dd9b245097248c05633a97fcbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3289a58a68b4d5400aba5fbd62c558"><td class="memTemplParams" colspan="2"><a id="aba3289a58a68b4d5400aba5fbd62c558"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba3289a58a68b4d5400aba5fbd62c558"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aba3289a58a68b4d5400aba5fbd62c558">is_square_root_v</a> = <a class="el" href="struct_open_kalman_1_1is__square__root.html">is_square_root</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:aba3289a58a68b4d5400aba5fbd62c558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__square__root.html" title="Whether an object is a Cholesky square root (e.g., SquareRootCovariance).">is_square_root</a>. <br /></td></tr>
<tr class="separator:aba3289a58a68b4d5400aba5fbd62c558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d466317c8760276457a7bbe2ac2a0d1"><td class="memTemplParams" colspan="2"><a id="a7d466317c8760276457a7bbe2ac2a0d1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d466317c8760276457a7bbe2ac2a0d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a7d466317c8760276457a7bbe2ac2a0d1">is_zero_v</a> = <a class="el" href="struct_open_kalman_1_1is__zero.html">is_zero</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a7d466317c8760276457a7bbe2ac2a0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__zero.html" title="Whether an object is a diagonal matrix.">is_zero</a>. <br /></td></tr>
<tr class="separator:a7d466317c8760276457a7bbe2ac2a0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2551dce0fb8227babd07a6ca2ab4fc1b"><td class="memTemplParams" colspan="2"><a id="a2551dce0fb8227babd07a6ca2ab4fc1b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2551dce0fb8227babd07a6ca2ab4fc1b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2551dce0fb8227babd07a6ca2ab4fc1b">is_identity_v</a> = <a class="el" href="struct_open_kalman_1_1is__identity.html">is_identity</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a2551dce0fb8227babd07a6ca2ab4fc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__identity.html" title="Whether an object is an identity matrix.">is_identity</a>. <br /></td></tr>
<tr class="separator:a2551dce0fb8227babd07a6ca2ab4fc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06025b1bcd2a832956991f9506b3697b"><td class="memTemplParams" colspan="2"><a id="a06025b1bcd2a832956991f9506b3697b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06025b1bcd2a832956991f9506b3697b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a06025b1bcd2a832956991f9506b3697b">is_1by1_v</a> = <a class="el" href="struct_open_kalman_1_1is__1by1.html">is_1by1</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a06025b1bcd2a832956991f9506b3697b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__1by1.html" title="Whether an object is a 1-by-1 matrix.">is_1by1</a>. <br /></td></tr>
<tr class="separator:a06025b1bcd2a832956991f9506b3697b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe71958460e7f475c0d2784bbb6e067"><td class="memTemplParams" colspan="2"><a id="afbe71958460e7f475c0d2784bbb6e067"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afbe71958460e7f475c0d2784bbb6e067"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#afbe71958460e7f475c0d2784bbb6e067">is_diagonal_v</a> = <a class="el" href="struct_open_kalman_1_1is__diagonal.html">is_diagonal</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:afbe71958460e7f475c0d2784bbb6e067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__diagonal.html" title="Whether an object is a diagonal matrix.">is_diagonal</a>. <br /></td></tr>
<tr class="separator:afbe71958460e7f475c0d2784bbb6e067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0f53ce0548023d9fac14cff090d2c6"><td class="memTemplParams" colspan="2"><a id="a7d0f53ce0548023d9fac14cff090d2c6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d0f53ce0548023d9fac14cff090d2c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a7d0f53ce0548023d9fac14cff090d2c6">is_Cholesky_v</a> = <a class="el" href="struct_open_kalman_1_1is___cholesky.html">is_Cholesky</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a7d0f53ce0548023d9fac14cff090d2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is___cholesky.html" title="Whether a covariance is in the form of a Cholesky decomposition.">is_Cholesky</a>. <br /></td></tr>
<tr class="separator:a7d0f53ce0548023d9fac14cff090d2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ecc9bc5f0194930dac587418ac4146"><td class="memTemplParams" colspan="2"><a id="ac5ecc9bc5f0194930dac587418ac4146"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5ecc9bc5f0194930dac587418ac4146"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac5ecc9bc5f0194930dac587418ac4146">is_self_adjoint_v</a> = <a class="el" href="struct_open_kalman_1_1is__self__adjoint.html">is_self_adjoint</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ac5ecc9bc5f0194930dac587418ac4146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__self__adjoint.html" title="Whether an object is a self-adjoint matrix.">is_self_adjoint</a>. <br /></td></tr>
<tr class="separator:ac5ecc9bc5f0194930dac587418ac4146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ffa8c3873633154894acb884b52e29"><td class="memTemplParams" colspan="2"><a id="a79ffa8c3873633154894acb884b52e29"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79ffa8c3873633154894acb884b52e29"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a79ffa8c3873633154894acb884b52e29">is_lower_triangular_v</a> = <a class="el" href="struct_open_kalman_1_1is__lower__triangular.html">is_lower_triangular</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a79ffa8c3873633154894acb884b52e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__lower__triangular.html" title="Whether an object is a lower triangular matrix.">is_lower_triangular</a>. <br /></td></tr>
<tr class="separator:a79ffa8c3873633154894acb884b52e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3610ff5e19b29f39e826572a55ee540d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3610ff5e19b29f39e826572a55ee540d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3610ff5e19b29f39e826572a55ee540d">is_upper_triangular_v</a> = <a class="el" href="struct_open_kalman_1_1is__upper__triangular.html">is_upper_triangular</a>&lt;T&gt;::value</td></tr>
<tr class="separator:a3610ff5e19b29f39e826572a55ee540d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45920e2d1d284dd3f2da3ced8174c1e"><td class="memTemplParams" colspan="2"><a id="ab45920e2d1d284dd3f2da3ced8174c1e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab45920e2d1d284dd3f2da3ced8174c1e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab45920e2d1d284dd3f2da3ced8174c1e">is_triangular_v</a> = <a class="el" href="struct_open_kalman_1_1is__triangular.html">is_triangular</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ab45920e2d1d284dd3f2da3ced8174c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__triangular.html">is_triangular</a>. <br /></td></tr>
<tr class="separator:ab45920e2d1d284dd3f2da3ced8174c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5072438f6668460f4165de1dff1467b"><td class="memTemplParams" colspan="2"><a id="aa5072438f6668460f4165de1dff1467b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5072438f6668460f4165de1dff1467b"><td class="memTemplItemLeft" align="right" valign="top">constexpr TriangleType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aa5072438f6668460f4165de1dff1467b">triangle_type_of_v</a> = <a class="el" href="struct_open_kalman_1_1triangle__type__of.html">triangle_type_of</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:aa5072438f6668460f4165de1dff1467b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__triangular.html">is_triangular</a>. <br /></td></tr>
<tr class="separator:aa5072438f6668460f4165de1dff1467b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775d8e46567c0f777b7d0198f43aa69d"><td class="memTemplParams" colspan="2"><a id="a775d8e46567c0f777b7d0198f43aa69d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a775d8e46567c0f777b7d0198f43aa69d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a775d8e46567c0f777b7d0198f43aa69d">is_covariance_base_v</a> = <a class="el" href="struct_open_kalman_1_1is__covariance__base.html">is_covariance_base</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a775d8e46567c0f777b7d0198f43aa69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__covariance__base.html" title="Whether an object is a base for Covariance or SquareRootCovariance.">is_covariance_base</a>. <br /></td></tr>
<tr class="separator:a775d8e46567c0f777b7d0198f43aa69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e03586e53b9e764c2074bdd9c51a134"><td class="memTemplParams" colspan="2"><a id="a9e03586e53b9e764c2074bdd9c51a134"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e03586e53b9e764c2074bdd9c51a134"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a9e03586e53b9e764c2074bdd9c51a134">is_typed_matrix_v</a> = <a class="el" href="struct_open_kalman_1_1is__typed__matrix.html">is_typed_matrix</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a9e03586e53b9e764c2074bdd9c51a134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__covariance__base.html" title="Whether an object is a base for Covariance or SquareRootCovariance.">is_covariance_base</a>. <br /></td></tr>
<tr class="separator:a9e03586e53b9e764c2074bdd9c51a134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fc73423872b3d036550f56ba8e296b"><td class="memTemplParams" colspan="2"><a id="af1fc73423872b3d036550f56ba8e296b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1fc73423872b3d036550f56ba8e296b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af1fc73423872b3d036550f56ba8e296b">is_mean_v</a> = <a class="el" href="struct_open_kalman_1_1is__mean.html">is_mean</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:af1fc73423872b3d036550f56ba8e296b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__mean.html" title="Whether an object is a mean.">is_mean</a>. <br /></td></tr>
<tr class="separator:af1fc73423872b3d036550f56ba8e296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd11554da5d5f82604ccf793a27cfea"><td class="memTemplParams" colspan="2"><a id="a5fd11554da5d5f82604ccf793a27cfea"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fd11554da5d5f82604ccf793a27cfea"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5fd11554da5d5f82604ccf793a27cfea">is_Euclidean_mean_v</a> = <a class="el" href="struct_open_kalman_1_1is___euclidean__mean.html">is_Euclidean_mean</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a5fd11554da5d5f82604ccf793a27cfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is___euclidean__mean.html" title="Whether an object is a euclidean mean.">is_Euclidean_mean</a>. <br /></td></tr>
<tr class="separator:a5fd11554da5d5f82604ccf793a27cfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fac98064c57cd32112e3e4dc5f3f3dd"><td class="memTemplParams" colspan="2"><a id="a2fac98064c57cd32112e3e4dc5f3f3dd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2fac98064c57cd32112e3e4dc5f3f3dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2fac98064c57cd32112e3e4dc5f3f3dd">is_Euclidean_transformed_v</a> = <a class="el" href="struct_open_kalman_1_1is___euclidean__transformed.html">is_Euclidean_transformed</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a2fac98064c57cd32112e3e4dc5f3f3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__covariance__base.html" title="Whether an object is a base for Covariance or SquareRootCovariance.">is_covariance_base</a>. <br /></td></tr>
<tr class="separator:a2fac98064c57cd32112e3e4dc5f3f3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add73c6d5e7c382c0b9549644e2048f7a"><td class="memTemplParams" colspan="2"><a id="add73c6d5e7c382c0b9549644e2048f7a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:add73c6d5e7c382c0b9549644e2048f7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#add73c6d5e7c382c0b9549644e2048f7a">is_wrapped_v</a> = <a class="el" href="struct_open_kalman_1_1is__wrapped.html">is_wrapped</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:add73c6d5e7c382c0b9549644e2048f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__wrapped.html" title="Whether the matrix is wrapped.">is_wrapped</a>. <br /></td></tr>
<tr class="separator:add73c6d5e7c382c0b9549644e2048f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ee59ad9ad7a08b0eb7066c7cc68ad7"><td class="memTemplParams" colspan="2"><a id="ab4ee59ad9ad7a08b0eb7066c7cc68ad7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4ee59ad9ad7a08b0eb7066c7cc68ad7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab4ee59ad9ad7a08b0eb7066c7cc68ad7">is_column_vector_v</a> = <a class="el" href="struct_open_kalman_1_1is__column__vector.html">is_column_vector</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ab4ee59ad9ad7a08b0eb7066c7cc68ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__column__vector.html" title="Whether the matrix is a column vector or set of column vectors.">is_column_vector</a>. <br /></td></tr>
<tr class="separator:ab4ee59ad9ad7a08b0eb7066c7cc68ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754c05e716861ea1d636946b36feb8e2"><td class="memTemplParams" colspan="2"><a id="a754c05e716861ea1d636946b36feb8e2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a754c05e716861ea1d636946b36feb8e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a754c05e716861ea1d636946b36feb8e2">is_typed_matrix_base_v</a> = <a class="el" href="struct_open_kalman_1_1is__typed__matrix__base.html">is_typed_matrix_base</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a754c05e716861ea1d636946b36feb8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__typed__matrix__base.html" title="Whether an object is a base for a typed matrix.">is_typed_matrix_base</a>. <br /></td></tr>
<tr class="separator:a754c05e716861ea1d636946b36feb8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43324e2c8150e2f60a592d0bb65deba5"><td class="memTemplParams" colspan="2"><a id="a43324e2c8150e2f60a592d0bb65deba5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43324e2c8150e2f60a592d0bb65deba5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a43324e2c8150e2f60a592d0bb65deba5">is_coefficient_v</a> = <a class="el" href="struct_open_kalman_1_1is__coefficient.html">is_coefficient</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a43324e2c8150e2f60a592d0bb65deba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__coefficient.html" title="Whether an object is a coefficient.">is_coefficient</a>. <br /></td></tr>
<tr class="separator:a43324e2c8150e2f60a592d0bb65deba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa2cbcfc7c7857ad2a9696ea74571f3"><td class="memTemplParams" colspan="2"><a id="a1fa2cbcfc7c7857ad2a9696ea74571f3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fa2cbcfc7c7857ad2a9696ea74571f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1fa2cbcfc7c7857ad2a9696ea74571f3">is_composite_coefficient_v</a> = <a class="el" href="struct_open_kalman_1_1is__composite__coefficient.html">is_composite_coefficient</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a1fa2cbcfc7c7857ad2a9696ea74571f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__composite__coefficient.html" title="Whether an object is a composite coefficient.">is_composite_coefficient</a>. <br /></td></tr>
<tr class="separator:a1fa2cbcfc7c7857ad2a9696ea74571f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a6ca66f215de077344f7a377d31916"><td class="memTemplParams" colspan="2"><a id="ac7a6ca66f215de077344f7a377d31916"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac7a6ca66f215de077344f7a377d31916"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac7a6ca66f215de077344f7a377d31916">is_equivalent_v</a> = <a class="el" href="struct_open_kalman_1_1is__equivalent.html">is_equivalent</a>&lt;T, U&gt;::value</td></tr>
<tr class="memdesc:ac7a6ca66f215de077344f7a377d31916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__equivalent.html" title="Whether coefficients are equivalent.">is_equivalent</a>. <br /></td></tr>
<tr class="separator:ac7a6ca66f215de077344f7a377d31916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa9a45809848c4f30ca40ebe31ce220"><td class="memTemplParams" colspan="2"><a id="a4fa9a45809848c4f30ca40ebe31ce220"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4fa9a45809848c4f30ca40ebe31ce220"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4fa9a45809848c4f30ca40ebe31ce220">is_prefix_v</a> = <a class="el" href="struct_open_kalman_1_1is__prefix.html">is_prefix</a>&lt;T, U&gt;::value</td></tr>
<tr class="memdesc:a4fa9a45809848c4f30ca40ebe31ce220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__prefix.html" title="Whether one set of coefficients is a pre-fix for another set.">is_prefix</a>. <br /></td></tr>
<tr class="separator:a4fa9a45809848c4f30ca40ebe31ce220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558c6ff673d2eae82329bfb58d2e8077"><td class="memTemplParams" colspan="2"><a id="a558c6ff673d2eae82329bfb58d2e8077"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a558c6ff673d2eae82329bfb58d2e8077"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a558c6ff673d2eae82329bfb58d2e8077">is_distribution_v</a> = <a class="el" href="struct_open_kalman_1_1is__distribution.html">is_distribution</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a558c6ff673d2eae82329bfb58d2e8077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__distribution.html" title="Whether an object is a distribution.">is_distribution</a>. <br /></td></tr>
<tr class="separator:a558c6ff673d2eae82329bfb58d2e8077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59ffb4b5b4d60a03b207c74512f7ada"><td class="memTemplParams" colspan="2"><a id="ab59ffb4b5b4d60a03b207c74512f7ada"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab59ffb4b5b4d60a03b207c74512f7ada"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab59ffb4b5b4d60a03b207c74512f7ada">is_Gaussian_distribution_v</a> = <a class="el" href="struct_open_kalman_1_1is___gaussian__distribution.html">is_Gaussian_distribution</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:ab59ffb4b5b4d60a03b207c74512f7ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is___gaussian__distribution.html" title="Whether an object is a Gaussian distribution.">is_Gaussian_distribution</a>. <br /></td></tr>
<tr class="separator:ab59ffb4b5b4d60a03b207c74512f7ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca46d6e07743852f26de9ae2c12c579"><td class="memTemplParams" colspan="2"><a id="a8ca46d6e07743852f26de9ae2c12c579"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ca46d6e07743852f26de9ae2c12c579"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a8ca46d6e07743852f26de9ae2c12c579">is_strict_v</a> = <a class="el" href="struct_open_kalman_1_1is__strict.html">is_strict</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a8ca46d6e07743852f26de9ae2c12c579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__strict.html" title="Whether an expression is strict.">is_strict</a>. <br /></td></tr>
<tr class="separator:a8ca46d6e07743852f26de9ae2c12c579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb616523cadd20695189f33414d6ccbf"><td class="memTemplParams" colspan="2"><a id="afb616523cadd20695189f33414d6ccbf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb616523cadd20695189f33414d6ccbf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#afb616523cadd20695189f33414d6ccbf">is_strict_matrix_v</a> = <a class="el" href="struct_open_kalman_1_1is__strict__matrix.html">is_strict_matrix</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:afb616523cadd20695189f33414d6ccbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__strict.html" title="Whether an expression is strict.">is_strict</a>. <br /></td></tr>
<tr class="separator:afb616523cadd20695189f33414d6ccbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeebeca933312a9d3a431802596a75e7"><td class="memTemplParams" colspan="2"><a id="abeebeca933312a9d3a431802596a75e7"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:abeebeca933312a9d3a431802596a75e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#abeebeca933312a9d3a431802596a75e7">is_element_gettable_v</a> = <a class="el" href="struct_open_kalman_1_1is__element__gettable.html">is_element_gettable</a>&lt;T, N&gt;::value</td></tr>
<tr class="memdesc:abeebeca933312a9d3a431802596a75e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__element__gettable.html" title="Whether an object has elements that can be retrieved with N indices.">is_element_gettable</a>. <br /></td></tr>
<tr class="separator:abeebeca933312a9d3a431802596a75e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82790d6c4705dacce49d15c1ab38346"><td class="memTemplParams" colspan="2"><a id="ad82790d6c4705dacce49d15c1ab38346"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ad82790d6c4705dacce49d15c1ab38346"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad82790d6c4705dacce49d15c1ab38346">is_element_settable_v</a> = <a class="el" href="struct_open_kalman_1_1is__element__settable.html">is_element_settable</a>&lt;T, N&gt;::value</td></tr>
<tr class="memdesc:ad82790d6c4705dacce49d15c1ab38346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__element__settable.html" title="Whether an object has elements that can be set with N indices.">is_element_settable</a>. <br /></td></tr>
<tr class="separator:ad82790d6c4705dacce49d15c1ab38346"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace for all OpenKalman-specific classes and methods. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad7fbe21f478b7b06ac97b6eb6f5967c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fbe21f478b7b06ac97b6eb6f5967c3">&#9670;&nbsp;</a></span>Axes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">OpenKalman::Axes</a> = typedef <a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">Replicate</a>&lt;<a class="el" href="struct_open_kalman_1_1_axis.html">Axis</a>, size&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for a set of <a class="el" href="struct_open_kalman_1_1_axis.html">Axis</a> coefficients of a given size. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">size</td><td>The number of Axes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_coefficients_8h_source.html#l00257">257</a> of file <a class="el" href="_coefficients_8h_source.html">Coefficients.h</a>.</p>

</div>
</div>
<a id="ac66c8a3d2e7e2449a727d370262995ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66c8a3d2e7e2449a727d370262995ef">&#9670;&nbsp;</a></span>Replicate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">OpenKalman::Replicate</a> = typedef typename <a class="el" href="struct_open_kalman_1_1detail_1_1_replicate_impl.html">detail::ReplicateImpl</a>&lt;C, N&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a Coefficients&lt;...&gt; alias in which the coefficients are C repeated N times. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The coefficient to be repeated. </td></tr>
    <tr><td class="paramname">N</td><td>The number of times to repeat coefficient C. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_coefficients_8h_source.html#l00250">250</a> of file <a class="el" href="_coefficients_8h_source.html">Coefficients.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aee64f1834343ba3a68d3c7384f151065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee64f1834343ba3a68d3c7384f151065">&#9670;&nbsp;</a></span>apply_columnwise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Function , std::enable_if_t&lt; is_ToEuclideanExpr_v&lt; Arg &gt; or is_FromEuclideanExpr_v&lt; Arg &gt;, int &gt;  = 0, std::enable_if_t&lt; std::is_void_v&lt; std::invoke_result_t&lt; Function, decltype(column(std::declval&lt; Arg &amp; &gt;(), 0))&amp; &gt;&gt; , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Arg &amp; OpenKalman::apply_columnwise </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@TODO Make it so this function can accept any typed matrix with identically-typed columns.</p>
<p>@TODO Make it so this function can accept any typed matrix with identically-typed columns.</p>

<p class="definition">Definition at line <a class="el" href="_euclidean_expr_overloads_8h_source.html#l00643">643</a> of file <a class="el" href="_euclidean_expr_overloads_8h_source.html">EuclideanExprOverloads.h</a>.</p>

</div>
</div>
<a id="a38cf22b04919ddaac53d9296aa77be2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cf22b04919ddaac53d9296aa77be2d">&#9670;&nbsp;</a></span>column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; is_native_Eigen_type_v&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::column </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return column <code>index</code> of Arg. </p>
<p>@TODO Make it so this function can accept any typed matrix with identically-typed columns.</p>
<p>@TODO Make it so this function can accept any typed matrix with identically-typed columns.</p>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00686">686</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="ab1cbaa34feefd5e3535dbf988122b7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cbaa34feefd5e3535dbf988122b7b2">&#9670;&nbsp;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename ... Vs, std::enable_if_t&lt; std::conjunction_v&lt; is_EigenDiagonal&lt; V &gt;, is_EigenDiagonal&lt; Vs &gt;... &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::concatenate </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate diagonally. </p>
<p>Concatenate diagonally if the arguments are all self-adjoint or all triangular, and of the same type.</p>
<p>Concatenate diagonally if arguments are a heterogeneous mix upper and lower-storage self-adjoint. The result will have the storage type of the first matrix. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_diagonal_8h_source.html#l00474">474</a> of file <a class="el" href="_eigen_diagonal_8h_source.html">EigenDiagonal.h</a>.</p>

</div>
</div>
<a id="a0315b7e1603e75b425629b5604e470b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0315b7e1603e75b425629b5604e470b2">&#9670;&nbsp;</a></span>concatenate_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename ... Vs, std::enable_if_t&lt; std::conjunction_v&lt; is_EigenDiagonal&lt; V &gt;, is_EigenDiagonal&lt; Vs &gt;... &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::concatenate_diagonal </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate diagonally. </p>
<p>Concatenate one or more typed matrices diagonally.</p>
<p>Concatenate one or more Eigen::MatrixBase objects diagonally. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_diagonal_8h_source.html#l00491">491</a> of file <a class="el" href="_eigen_diagonal_8h_source.html">EigenDiagonal.h</a>.</p>

</div>
</div>
<a id="ac3c5157500f9c2c2018697ce9fd276d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c5157500f9c2c2018697ce9fd276d5">&#9670;&nbsp;</a></span>concatenate_horizontal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename ... Vs, std::enable_if_t&lt; std::conjunction_v&lt; std::disjunction&lt; is_Eigen_matrix&lt; V &gt;, is_EigenSelfAdjointMatrix&lt; V &gt;, is_EigenTriangularMatrix&lt; V &gt;, is_EigenDiagonal&lt; V &gt;, is_FromEuclideanExpr&lt; V &gt;&gt;, std::disjunction&lt; is_Eigen_matrix&lt; Vs &gt;, is_EigenSelfAdjointMatrix&lt; Vs &gt;, is_EigenTriangularMatrix&lt; Vs &gt;, is_EigenDiagonal&lt; Vs &gt;, is_FromEuclideanExpr&lt; Vs &gt;&gt;... &gt; and not std::conjunction_v&lt; is_FromEuclideanExpr&lt; V &gt;, is_FromEuclideanExpr&lt; Vs &gt;... &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::concatenate_horizontal </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate one or more Eigen::MatrixBase objects horizontally. </p>
<p>Concatenate one or more matrix objects vertically.</p>
<p>Concatenate one or more EuclideanExpr objects horizontally. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00309">309</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="ac07f38b9b803ce7be54501d6899eebb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07f38b9b803ce7be54501d6899eebb1">&#9670;&nbsp;</a></span>concatenate_vertical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename ... Vs, std::enable_if_t&lt; std::conjunction_v&lt; std::disjunction&lt; is_Eigen_matrix&lt; V &gt;, is_EigenSelfAdjointMatrix&lt; V &gt;, is_EigenTriangularMatrix&lt; V &gt;, is_EigenDiagonal&lt; V &gt;, is_FromEuclideanExpr&lt; V &gt;&gt;, std::disjunction&lt; is_Eigen_matrix&lt; Vs &gt;, is_EigenSelfAdjointMatrix&lt; Vs &gt;, is_EigenTriangularMatrix&lt; Vs &gt;, is_EigenDiagonal&lt; Vs &gt;, is_FromEuclideanExpr&lt; V &gt;&gt;... &gt; and not std::conjunction_v&lt; is_FromEuclideanExpr&lt; V &gt;, is_FromEuclideanExpr&lt; Vs &gt;... &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::concatenate_vertical </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Concatenate one or more Eigen::MatrixBase objects vertically. </p>
<p>Concatenate one or more typed matrices objects vertically.</p>
<p>Concatenate one or more EuclideanExpr objects vertically. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00281">281</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="ab8f85ede5a341f9abd89ee0f2f9a40a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f85ede5a341f9abd89ee0f2f9a40a7">&#9670;&nbsp;</a></span>EuclideanMean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , std::enable_if_t&lt; is_typed_matrix_base_v&lt; V &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">OpenKalman::EuclideanMean</a> </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::dimension &gt;, lvalue_or_strict_t&lt; V &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce template parameters from a typed matrix base, assuming axex-only coefficients. </p>
<p>Deduce template parameters from a non-Euclidean-transformed typed matrix.</p>
<p>Deduce template parameters from a Euclidean-transformed typed matrix. </p>

</div>
</div>
<a id="a9934a0fa27adfaf949d994695a13b6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9934a0fa27adfaf949d994695a13b6af">&#9670;&nbsp;</a></span>FiniteDifferenceLinearization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Trans , typename InDelta , typename ... PsDelta&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_finite_difference_linearization.html">OpenKalman::FiniteDifferenceLinearization</a> </td>
          <td>(</td>
          <td class="paramtype">Trans &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InDelta &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PsDelta &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="struct_open_kalman_1_1_finite_difference_linearization.html">FiniteDifferenceLinearization</a>&lt; Trans, InDelta, PsDelta... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deduction guide </p>

</div>
</div>
<a id="a7ed81d91202d9b998733a3be06de9910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed81d91202d9b998733a3be06de9910">&#9670;&nbsp;</a></span>get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and(is_element_gettable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 1 &gt; or is_element_gettable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 2 &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::get_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get element (i) of diagonal matrix arg. </p>
<p>Get element (i) of a typed matrix.</p>
<p>Get element (i) of a covariance matrix.</p>
<p>Get element (i) of FromEuclideanExpr(ToEuclideanExpr) matrix.</p>
<p>Get element (i) of one-column <a class="el" href="struct_open_kalman_1_1_to_euclidean_expr.html" title="A nested, non-Euclidean matrix.">ToEuclideanExpr</a> or <a class="el" href="struct_open_kalman_1_1_from_euclidean_expr.html">FromEuclideanExpr</a> matrix arg.</p>
<p>Get element (i) of diagonal self-adjoint or triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_diagonal_8h_source.html#l00505">505</a> of file <a class="el" href="_eigen_diagonal_8h_source.html">EigenDiagonal.h</a>.</p>

</div>
</div>
<a id="aab9f83dc120f7424fe949f401344960e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9f83dc120f7424fe949f401344960e">&#9670;&nbsp;</a></span>get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and(is_element_gettable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 1 &gt; or is_element_gettable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 2 &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::get_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get element (i, j) of diagonal matrix arg. </p>
<p>Get element (i, j) of a typed matrix.</p>
<p>Get element (i, j) of a covariance matrix.</p>
<p>Get element (i, j) of FromEuclideanExpr(ToEuclideanExpr) matrix.</p>
<p>Get element (i, j) of <a class="el" href="struct_open_kalman_1_1_to_euclidean_expr.html" title="A nested, non-Euclidean matrix.">ToEuclideanExpr</a> or <a class="el" href="struct_open_kalman_1_1_from_euclidean_expr.html">FromEuclideanExpr</a> matrix arg.</p>
<p>Get element (i, j) of a self-adjoint or triangular matrix that is also diagonal.</p>
<p>Get element (i, j) of triangular matrix arg.</p>
<p>Get element (i, j) of self-adjoint matrix arg. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_diagonal_8h_source.html#l00519">519</a> of file <a class="el" href="_eigen_diagonal_8h_source.html">EigenDiagonal.h</a>.</p>

</div>
</div>
<a id="a6f44bd141f1e2b9b65432a633d9180e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f44bd141f1e2b9b65432a633d9180e2">&#9670;&nbsp;</a></span>inverse_scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename S , std::enable_if_t&lt; is_covariance_v&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::inverse_scale </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale a covariance by the inverse of a scalar factor. Equivalent by division by the square of a scalar. For a square root covariance, this is equivalent to division by the scalar. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_overloads_8h_source.html#l00934">934</a> of file <a class="el" href="_covariance_overloads_8h_source.html">CovarianceOverloads.h</a>.</p>

</div>
</div>
<a id="aaee351667e13c16299dbbeadc383083a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee351667e13c16299dbbeadc383083a">&#9670;&nbsp;</a></span>LQ_decomposition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; is_native_Eigen_type_v&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto OpenKalman::LQ_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an LQ decomposition of matrix A=[L,0]Q, L is a lower-triangular matrix, and Q is orthogonal. Returns L as a lower-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00209">209</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="a2b6c57d62908d98416bcaed87375964c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b6c57d62908d98416bcaed87375964c">&#9670;&nbsp;</a></span>LQ_decomposition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; is_EigenDiagonal_v&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::LQ_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform an LQ decomposition. Since it is diagonal, it returns the matrix unchanged. </p>
<p>Perform an LQ decomposition of matrix A=[L,0]Q, where L is a lower-triangular matrix, and Q is orthogonal. Returns L as a lower-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_diagonal_8h_source.html#l00455">455</a> of file <a class="el" href="_eigen_diagonal_8h_source.html">EigenDiagonal.h</a>.</p>

</div>
</div>
<a id="a0e6f25c9190e4658793bb610b179bbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6f25c9190e4658793bb610b179bbc9">&#9670;&nbsp;</a></span>LQ_decomposition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::LQ_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an LQ decomposition of matrix A=[L,0]Q, where L is a lower-triangular matrix, and Q is orthogonal. Returns L as a lower-triangular matrix.</p>
<p>Perform an LQ decomposition of matrix A=[L,0]Q, L is a lower-triangular matrix, and Q is orthogonal. Returns L as a lower-triangular matrix.</p>
<p>Perform an LQ decomposition of matrix A=[L,0]Q, L is a lower-triangular matrix, and Q is orthogonal. Returns L as a triangular matrix.</p>
<p>Perform an LQ decomposition of matrix A=[L|0]Q, where L is a lower-triangular matrix, and Q is orthogonal. Returns L as a Cholesky lower-triangular <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a>. All column coefficients must be axes, and A cannot be Euclidean-transformed. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_self_adjoint_matrix_8h_source.html#l00477">477</a> of file <a class="el" href="_eigen_self_adjoint_matrix_8h_source.html">EigenSelfAdjointMatrix.h</a>.</p>

</div>
</div>
<a id="a05f9155e6a8c211c128af8bdc3f02c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f9155e6a8c211c128af8bdc3f02c14">&#9670;&nbsp;</a></span>make_Transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , std::enable_if_t&lt; is_linearized_function_v&lt; Function, 1 &gt; and not is_linearized_function_v&lt; Function, 2 &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_Transformation </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a transformation from a first-order linearized transformation defining a Jacobian function. Substitution failure if the transformation function is polymorphic.</p>
<p>Make a transformation from a second-order linearized transformation defining Jacobian and Hessian functions. Substitution failure if the transformation function is polymorphic. </p>

<p class="definition">Definition at line <a class="el" href="_transformation_8h_source.html#l00242">242</a> of file <a class="el" href="_transformation_8h_source.html">Transformation.h</a>.</p>

</div>
</div>
<a id="afc31742e92d82b2c519c73f2657e3da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc31742e92d82b2c519c73f2657e3da5">&#9670;&nbsp;</a></span>Mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , std::enable_if_t&lt; is_typed_matrix_base_v&lt; V &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_mean.html">OpenKalman::Mean</a> </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::dimension &gt;, lvalue_or_strict_t&lt; V &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce template parameters from a typed matrix base, assuming axis-only coefficients. </p>
<p>Deduce template parameters from a Euclidean-transformed typed matrix.</p>
<p>Deduce template parameters from a non-Euclidean-transformed typed matrix. </p>

</div>
</div>
<a id="a6c8bc52340ab01395a4aba7470d13d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8bc52340ab01395a4aba7470d13d29">&#9670;&nbsp;</a></span>QR_decomposition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; is_native_Eigen_type_v&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto OpenKalman::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a QR decomposition of matrix A=Q[U,0], U is a upper-triangular matrix, and Q is orthogonal. Returns U as an upper-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00243">243</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="a11ae142f488e2f8e68a657b091ed195d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ae142f488e2f8e68a657b091ed195d">&#9670;&nbsp;</a></span>QR_decomposition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; is_EigenDiagonal_v&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a QR decomposition. Since it is diagonal, it returns the matrix unchanged. </p>
<p>Perform a QR decomposition of matrix A=Q[U,0], where U is an upper-triangular matrix, and Q is orthogonal. Returns U as an upper-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_diagonal_8h_source.html#l00464">464</a> of file <a class="el" href="_eigen_diagonal_8h_source.html">EigenDiagonal.h</a>.</p>

</div>
</div>
<a id="ae8c9b539547601ae4b033c3ffe425b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c9b539547601ae4b033c3ffe425b5b">&#9670;&nbsp;</a></span>QR_decomposition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; is_EigenSelfAdjointMatrix_v&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a QR decomposition of matrix A=Q[U,0], where U is an upper-triangular matrix, and Q is orthogonal. Returns L as an upper-triangular matrix.</p>
<p>Perform a QR decomposition of matrix A=Q[U,0], U is a upper-triangular matrix, and Q is orthogonal. Returns U as an upper-triangular matrix.</p>
<p>Perform a QR decomposition of matrix A=Q[U|0], where U is an upper-triangular matrix, and Q is orthogonal. Returns U as a Cholesky upper-triangular <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a>. All row coefficients must be axes. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_self_adjoint_matrix_8h_source.html#l00487">487</a> of file <a class="el" href="_eigen_self_adjoint_matrix_8h_source.html">EigenSelfAdjointMatrix.h</a>.</p>

</div>
</div>
<a id="a3a5aa50cd3446c27bc08deacb3456b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5aa50cd3446c27bc08deacb3456b2d">&#9670;&nbsp;</a></span>randomize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , template&lt; typename &gt; typename distribution_type = std::normal_distribution, typename random_number_engine  = std::mt19937, typename... Params, std::enable_if_t&lt; is_Eigen_matrix_v&lt; ReturnType &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::randomize </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill an Eigen matrix with random values selected from a random distribution. The Gaussian distribution has mean zero and a scalar standard deviation sigma (== 1, if not specified). </p>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00957">957</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="af64ea73d28077cecfc217139a9d77813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64ea73d28077cecfc217139a9d77813">&#9670;&nbsp;</a></span>reduce_columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::reduce_columns </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a column vector from a diagnoal matrix. (Same as base_matrix()). </p>
<p>Returns the mean of the column vectors after they are transformed into Euclidean space.</p>
<p>Create a column vector by taking the mean of each row in a set of column vectors. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_diagonal_8h_source.html#l00446">446</a> of file <a class="el" href="_eigen_diagonal_8h_source.html">EigenDiagonal.h</a>.</p>

</div>
</div>
<a id="a3be486e53ad3cb44d7ea46c4201f4ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be486e53ad3cb44d7ea46c4201f4ce5">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename A , std::enable_if_t&lt; is_covariance_v&lt; M &gt; and is_typed_matrix_v&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::scale </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale a covariance by a matrix. A scaled covariance Arg is A * Arg * adjoint(A). A scaled square root covariance L or U is also scaled accordingly, so that scale(L * adjoint(L)) = A * L * adjoint(L) * adjoint(A) or scale(adjoint(U) * U) = A * adjoint(U) * U * adjoint(A). </p>

<p class="definition">Definition at line <a class="el" href="_covariance_overloads_8h_source.html#l00957">957</a> of file <a class="el" href="_covariance_overloads_8h_source.html">CovarianceOverloads.h</a>.</p>

</div>
</div>
<a id="a77f2335ea8a758c0b229c54cadc27aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f2335ea8a758c0b229c54cadc27aa1">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename S , std::enable_if_t&lt; is_covariance_v&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::scale </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale a covariance by a factor. Equivalent to multiplication by the square of a scalar. For a square root covariance, this is equivalent to multiplication by the scalar. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_overloads_8h_source.html#l00919">919</a> of file <a class="el" href="_covariance_overloads_8h_source.html">CovarianceOverloads.h</a>.</p>

</div>
</div>
<a id="a1a86339bc79fa01578464985b73e03a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a86339bc79fa01578464985b73e03a5">&#9670;&nbsp;</a></span>set_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and(is_element_settable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 1 &gt; or is_element_settable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 2 &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenKalman::set_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set element (i) of matrix arg to s. </p>
<p>Set element (i) of a typed matrix.</p>
<p>Set element (i) of a covariance matrix.</p>
<p>Set element (i) of <a class="el" href="struct_open_kalman_1_1_to_euclidean_expr.html" title="A nested, non-Euclidean matrix.">ToEuclideanExpr</a> or <a class="el" href="struct_open_kalman_1_1_from_euclidean_expr.html">FromEuclideanExpr</a> matrix arg if coefficients are only axes.</p>
<p>Set element (i) of diagonal self-adjoint or triangular matrix.</p>
<p>Set element (i) of one-column matrix arg to s.</p>
<p>Set element (i) of arg in FromEuclideanExpr(ToEuclideanExpr(arg)) to s, where arg is a single-column vector. This function sets the base matrix, not the wrapped resulting matrix. For example, if the coefficient is Polar&lt;Distance, Angle&gt; and the initial value of a single-column vector is {-1., pi/2}, then set_element(arg, pi/4, 1) will replace p/2 with pi/4 to yield {-1., pi/4} in the base matrix. The resulting wrapped expression will yield {1., -3*pi/4}. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_diagonal_8h_source.html#l00539">539</a> of file <a class="el" href="_eigen_diagonal_8h_source.html">EigenDiagonal.h</a>.</p>

</div>
</div>
<a id="ab5d576e04f45d8081c586f69f8b7f96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d576e04f45d8081c586f69f8b7f96f">&#9670;&nbsp;</a></span>set_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; is_EigenDiagonal_v&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and(is_element_settable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 1 &gt; or is_element_settable_v&lt; typename MatrixTraits&lt; Arg &gt;::BaseMatrix, 2 &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenKalman::set_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set element (i, j) of matrix arg to s. </p>
<p>Set element (i, j) of a typed matrix.</p>
<p>Set element (i, j) of a covariance matrix.</p>
<p>Set element (i, j) of <a class="el" href="struct_open_kalman_1_1_to_euclidean_expr.html" title="A nested, non-Euclidean matrix.">ToEuclideanExpr</a> or <a class="el" href="struct_open_kalman_1_1_from_euclidean_expr.html">FromEuclideanExpr</a> matrix arg if coefficients are only axes.</p>
<p>Set element (i, j) of a self-adjoint or triangular matrix that is also diagonal.</p>
<p>Set element (i, j) of triangular matrix arg to s.</p>
<p>Set element (i, j) of self-adjoint matrix arg to s.</p>
<p>Set element (i, j) of arg in FromEuclideanExpr(ToEuclideanExpr(arg)) to s. This function sets the base matrix, not the wrapped resulting matrix. For example, if the coefficient is Polar&lt;Distance, Angle&gt; and the initial value of a single-column vector is {-1., pi/2}, then set_element(arg, pi/4, 1, 0) will replace p/2 with pi/4 to yield {-1., pi/4} in the base matrix. The resulting wrapped expression will yield {1., -3*pi/4}. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_diagonal_8h_source.html#l00554">554</a> of file <a class="el" href="_eigen_diagonal_8h_source.html">EigenDiagonal.h</a>.</p>

</div>
</div>
<a id="a6d68d378015402b26f87dc9de25a32ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d68d378015402b26f87dc9de25a32ff">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , std::enable_if_t&lt; is_ToEuclideanExpr_v&lt; A &gt; or is_FromEuclideanExpr_v&lt; A &gt;, int &gt;  = 0, std::enable_if_t&lt; is_Eigen_matrix_v&lt; B &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::solve </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a x = b for x (A is a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a>, B is a vector type). </p>
<p>Solves AX = B for X (A is a regular matrix type, and B is a Euclidean expression). A must be invertible. (Does not check.)</p>
<p>Solves AX = B for X, where X and B are means of the same type, and A is a square matrix with compatible types. If wrapping occurs, it will be both before for B and after for the X result. </p>

<p class="definition">Definition at line <a class="el" href="_euclidean_expr_overloads_8h_source.html#l00165">165</a> of file <a class="el" href="_euclidean_expr_overloads_8h_source.html">EuclideanExprOverloads.h</a>.</p>

</div>
</div>
<a id="ad508289e902f8099b14dad0890c64795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad508289e902f8099b14dad0890c64795">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , std::enable_if_t&lt; is_EigenDiagonal_v&lt; A &gt;, int &gt;  = 0, std::enable_if_t&lt; is_Eigen_matrix_v&lt; B &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::solve </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve the equation AX = B for X. A is a diagonal matrix. </p>
<p>Solve the equation AX = B for X. A is an invertible square matrix. (Does not check that A is invertible.) Uses the square LU decomposition. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_diagonal_8h_source.html#l00436">436</a> of file <a class="el" href="_eigen_diagonal_8h_source.html">EigenDiagonal.h</a>.</p>

</div>
</div>
<a id="ab02034b9c631ff6e206820af08cc7e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02034b9c631ff6e206820af08cc7e1b">&#9670;&nbsp;</a></span>split_diagonal() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Cs, typename Arg , std::enable_if_t&lt;(is_EigenSelfAdjointMatrix_v&lt; Arg &gt; or is_EigenTriangularMatrix_v&lt; Arg &gt; or is_EigenDiagonal_v&lt; Arg &gt;) and std::conjunction_v&lt; is_coefficient&lt; Cs &gt;... &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_diagonal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a self-adjoint, triangular, or diagonal matrix diagonally. </p>
<p>Split into one or more Euclidean expressions diagonally. The valuated expression must be square. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_special_matrix_overloads_8h_source.html#l00190">190</a> of file <a class="el" href="_eigen_special_matrix_overloads_8h_source.html">EigenSpecialMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="ac15b73be3f7afa907872a4c65359e71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15b73be3f7afa907872a4c65359e71f">&#9670;&nbsp;</a></span>split_diagonal() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , bool euclidean, typename C , typename... Cs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_diagonal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a matrix diagonally and invoke function F on each segment, returning a tuple. Must be a square matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>An object having a static call() method to which the result is applied before creating the tuple. </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">Cs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for each of the second and subsequent cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00566">566</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="a0a63cbe9ff790107682a6fefd2006e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a63cbe9ff790107682a6fefd2006e8d">&#9670;&nbsp;</a></span>split_diagonal() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F  = internal::default_split_function, bool euclidean = false, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and not is_coefficient_v&lt; F &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_diagonal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a matrix vertically (case in which there is no split). </p>
<p>Split into one or more Euclidean expressions diagonally. The valuated expression must be square.</p>
<p>Split a self-adjoint, triangular, or diagonal matrix diagonally.</p>
<p>Split a self-adjoint or triangular matrix diagonally.</p>
<p>Split a diagonal matrix diagonally.</p>
<p>Split a matrix diagonally. Must be a square matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">Cs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for the second and subsequent cuts.</td></tr>
  </table>
  </dd>
</dl>
<p>Split a matrix diagonally. Must be a square matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of rows and columns in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Numbers of rows and columns in the second and subsequent cuts. </td></tr>
    <tr><td class="paramname">F</td><td>An object having a static call() method to which the result is applied before creating the tuple.</td></tr>
  </table>
  </dd>
</dl>
<p>Split into one or more Euclidean expressions diagonally. The expression (which must be square) is evaluated to a strict matrix first. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of rows in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Number of rows in the second and subsequent cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00601">601</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="aaa80d0137de848614c73a2bdc6a65fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa80d0137de848614c73a2bdc6a65fdd">&#9670;&nbsp;</a></span>split_diagonal() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename C , typename... Cs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and not is_coefficient_v&lt; F &gt; and std::conjunction_v&lt; is_coefficient&lt; C &gt;, is_coefficient&lt; Cs &gt;... &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_diagonal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into one or more Euclidean expressions diagonally. The valuated expression must be square. </p>
<p>Split a matrix vertically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>A class with a static <code>call</code> member to which the result is applied before creating the tuple. </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">Cs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for each of the second and subsequent cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00613">613</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="a2bf46841af75eee02bfd52c1708831b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf46841af75eee02bfd52c1708831b7">&#9670;&nbsp;</a></span>split_diagonal() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Cs, typename M , std::enable_if_t&lt; is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_diagonal </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a> diagonally. </p>
<p>Split typed matrix into one or more typed matrices diagonally. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_overloads_8h_source.html#l00305">305</a> of file <a class="el" href="_covariance_overloads_8h_source.html">CovarianceOverloads.h</a>.</p>

</div>
</div>
<a id="a719b02c283269c9d08d634559a20b7dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719b02c283269c9d08d634559a20b7dc">&#9670;&nbsp;</a></span>split_horizontal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CC , typename... CCs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and is_coefficient_v&lt; CC &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_horizontal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a self-adjoint, triangular, or diagonal matrix horizontally, returning a regular matrix. </p>
<p>Split into one or more Euclidean expressions horizontally.</p>
<p>Split a self-adjoint, triangular, or diagonal matrix horizontally.</p>
<p>Split a matrix horizontally. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CC</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">CCs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for the second and subsequent cuts.</td></tr>
  </table>
  </dd>
</dl>
<p>Split a matrix horizontally. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of columns in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Numbers of columns in the second and subsequent cuts. </td></tr>
    <tr><td class="paramname">F</td><td>An object having a static call() method to which the result is applied before creating the tuple.</td></tr>
  </table>
  </dd>
</dl>
<p>Split into one or more Euclidean expressions horizontally. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of columns in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Number of columns in the second and subsequent cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00541">541</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="a9ade2c818a6ac726e63817f86ed1b071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ade2c818a6ac726e63817f86ed1b071">&#9670;&nbsp;</a></span>split_horizontal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename CC , typename... CCs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and not is_coefficient_v&lt; F &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_horizontal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a matrix horizontally and invoke function F on each segment, returning a tuple. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CC</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">CCs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for each of the second and subsequent cuts. </td></tr>
    <tr><td class="paramname">F</td><td>An object having a static call() method to which the result is applied before creating the tuple. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00497">497</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="a864237f3b06bf93ceaffbf1d992b19f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864237f3b06bf93ceaffbf1d992b19f2">&#9670;&nbsp;</a></span>split_horizontal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F  = internal::default_split_function, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_horizontal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a matrix horizontally (case in which there is no split). </p>
<p>Split into one or more Euclidean expressions horizontally.</p>
<p>Split a self-adjoint, triangular, or diagonal matrix horizontally. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00530">530</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="a313e2b8a742da23f4623c6bc4c295d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313e2b8a742da23f4623c6bc4c295d5b">&#9670;&nbsp;</a></span>split_horizontal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Cs, typename M , std::enable_if_t&lt; is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_horizontal </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a> vertically. Result is a tuple of typed matrices. </p>
<p>Split typed matrix into one or more typed matrices horizontally. Column coefficients must all be <a class="el" href="struct_open_kalman_1_1_axis.html">Axis</a>.</p>
<p>Split typed matrix into one or more typed matrices horizontally. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_overloads_8h_source.html#l00326">326</a> of file <a class="el" href="_covariance_overloads_8h_source.html">CovarianceOverloads.h</a>.</p>

</div>
</div>
<a id="aa562124c539af400938c39532e7b57a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa562124c539af400938c39532e7b57a1">&#9670;&nbsp;</a></span>split_vertical() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Cs, typename Arg , std::enable_if_t&lt;(is_EigenSelfAdjointMatrix_v&lt; Arg &gt; or is_EigenTriangularMatrix_v&lt; Arg &gt; or is_EigenDiagonal_v&lt; Arg &gt;) and std::conjunction_v&lt; is_coefficient&lt; Cs &gt;... &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_vertical </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a self-adjoint, triangular, or diagonal matrix diagonally. </p>
<p>Split into one or more Euclidean expressions vertically. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_special_matrix_overloads_8h_source.html#l00223">223</a> of file <a class="el" href="_eigen_special_matrix_overloads_8h_source.html">EigenSpecialMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="a2742abeb205f5ed2e4d92ebb579329a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2742abeb205f5ed2e4d92ebb579329a7">&#9670;&nbsp;</a></span>split_vertical() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , bool euclidean, typename RC , typename... RCs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_vertical </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a matrix vertically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>A class with a static <code>call</code> member to which the result is applied before creating the tuple. </td></tr>
    <tr><td class="paramname">euclidean</td><td>Whether coefficients RC and RCs are transformed to Euclidean space. </td></tr>
    <tr><td class="paramname">RC</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">RCs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for each of the second and subsequent cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00417">417</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="a620f0997bfd5cc822af4d33d52313f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620f0997bfd5cc822af4d33d52313f4d">&#9670;&nbsp;</a></span>split_vertical() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F  = internal::default_split_function, bool euclidean = false, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_vertical </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split a matrix vertically (case in which there is no split). </p>
<p>Split into one or more Euclidean expressions vertically.</p>
<p>Split a self-adjoint, triangular, or diagonal matrix diagonally.</p>
<p>Split a self-adjoint, triangular, or diagonal matrix vertically, returning a regular matrix.</p>
<p>Split a matrix vertically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RC</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">RCs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for the second and subsequent cuts.</td></tr>
  </table>
  </dd>
</dl>
<p>Split a matrix vertically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of rows in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Numbers of rows in the second and subsequent cuts.</td></tr>
  </table>
  </dd>
</dl>
<p>Split into one or more Euclidean expressions vertically. The expression is evaluated to a strict matrix first. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of rows in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Number of rows in the second and subsequent cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00451">451</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="ae0038e7aa690a366121acc4c2c807075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0038e7aa690a366121acc4c2c807075">&#9670;&nbsp;</a></span>split_vertical() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename RC , typename... RCs, typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; and not is_coefficient_v&lt; F &gt; and std::conjunction_v&lt; is_coefficient&lt; RC &gt;, is_coefficient&lt; RCs &gt;... &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_vertical </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into one or more Euclidean expressions vertically. </p>
<p>Split a matrix vertically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>A class with a static <code>call</code> member to which the result is applied before creating the tuple. </td></tr>
    <tr><td class="paramname">RCs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types to be associated with a variable. The types should be instances of is_coef...">Coefficients</a> for each of the cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00462">462</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="a68dba71f80c4270929d21e416f1c8739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dba71f80c4270929d21e416f1c8739">&#9670;&nbsp;</a></span>split_vertical() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Cs, typename M , std::enable_if_t&lt; is_covariance_v&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_vertical </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix. If S is a SquareRoo...">SquareRootCovariance</a> vertically. Result is a tuple of typed matrices. </p>
<p>Split typed matrix into one or more typed matrices vertically. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_overloads_8h_source.html#l00315">315</a> of file <a class="el" href="_covariance_overloads_8h_source.html">CovarianceOverloads.h</a>.</p>

</div>
</div>
<a id="a0fd8f48a0e8423e7f1db724d834e5375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd8f48a0e8423e7f1db724d834e5375">&#9670;&nbsp;</a></span>strict()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; is_Gaussian_distribution_v&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::strict </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to strict version of the distribution. </p>
<p>Convert vector object to strict version (wrapping any angles).</p>
<p>Convert to strict version of the covariance matrix.</p>
<p>Convert to strict version of the special matrix.</p>
<p>Convert to strict version of the matrix. </p>

<p class="definition">Definition at line <a class="el" href="_gaussian_distribution_8h_source.html#l00558">558</a> of file <a class="el" href="_gaussian_distribution_8h_source.html">GaussianDistribution.h</a>.</p>

</div>
</div>
<a id="a773cf4e126d6964b9ffd37d666b56fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a773cf4e126d6964b9ffd37d666b56fe2">&#9670;&nbsp;</a></span>strict_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt; or is_EigenDiagonal_v&lt; Arg &gt; or is_EigenSelfAdjointMatrix_v&lt; Arg &gt; or is_EigenTriangularMatrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::strict_matrix </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to strict version of the matrix. </p>
<p>Convert to strict regular matrix (wrapping any angles, if necessary).</p>
<p>Convert to strict regular matrix. </p>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00026">26</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<a id="a94023ee812f40709ac61cdd392d105f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94023ee812f40709ac61cdd392d105f3">&#9670;&nbsp;</a></span>to_Euclidean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; is_FromEuclideanExpr_v&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::to_Euclidean </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Special case for converting a matrix to Euclidean form. This is a shortcut. Returns the base matrix of the argument, because <a class="el" href="struct_open_kalman_1_1_to_euclidean_expr.html" title="A nested, non-Euclidean matrix.">ToEuclideanExpr</a>&lt;FromEuclideanExpr&lt;M&gt;&gt; reduces to M. </p>

<p class="definition">Definition at line <a class="el" href="_euclidean_expr_overloads_8h_source.html#l00068">68</a> of file <a class="el" href="_euclidean_expr_overloads_8h_source.html">EuclideanExprOverloads.h</a>.</p>

</div>
</div>
<a id="abbd655dfd0d89b3b12ece39ab953e061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd655dfd0d89b3b12ece39ab953e061">&#9670;&nbsp;</a></span>Transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename... TaylorDerivatives&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_transformation.html">OpenKalman::Transformation</a> </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaylorDerivatives &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="struct_open_kalman_1_1_transformation.html">Transformation</a>&lt; Function, TaylorDerivatives... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deduction guides </p>

</div>
</div>
<a id="a24079444a9ad2d5a5d7aa189ad2de7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24079444a9ad2d5a5d7aa189ad2de7f1">&#9670;&nbsp;</a></span>TypedMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , std::enable_if_t&lt; is_typed_matrix_v&lt; V &gt; and not is_Euclidean_transformed_v&lt; V &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_typed_matrix.html">OpenKalman::TypedMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_open_kalman_1_1_typed_matrix.html">TypedMatrix</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::RowCoefficients, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::ColumnCoefficients, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::BaseMatrix &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce template parameters from a non-Euclidean-transformed typed matrix. </p>
<p>Deduce parameter types from a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A Covariance matrix.">Covariance</a>.</p>
<p>Deduce template parameters from a Euclidean-transformed typed matrix. </p>

</div>
</div>
<a id="a53512a5b7aa44f6146dfcc267c0596fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53512a5b7aa44f6146dfcc267c0596fd">&#9670;&nbsp;</a></span>wrap_angles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; is_Eigen_matrix_v&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::wrap_angles </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@TODO: Add functionality to conditionally wrap zero and identity, depending on wrap min and max.</p>

<p class="definition">Definition at line <a class="el" href="_eigen_matrix_overloads_8h_source.html#l00092">92</a> of file <a class="el" href="_eigen_matrix_overloads_8h_source.html">EigenMatrixOverloads.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3610ff5e19b29f39e826572a55ee540d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3610ff5e19b29f39e826572a55ee540d">&#9670;&nbsp;</a></span>is_upper_triangular_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::is_upper_triangular_v = <a class="el" href="struct_open_kalman_1_1is__upper__triangular.html">is_upper_triangular</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether an object is a triangular matrix. Helper template for <a class="el" href="struct_open_kalman_1_1is__upper__triangular.html" title="Whether an object is an upper triangular matrix.">is_upper_triangular</a>. </p>

<p class="definition">Definition at line <a class="el" href="_traits_8h_source.html#l00174">174</a> of file <a class="el" href="_traits_8h_source.html">Traits.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_open_kalman.html">OpenKalman</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
