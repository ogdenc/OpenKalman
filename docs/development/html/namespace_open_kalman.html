<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenKalman: OpenKalman Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenKalman
   </div>
   <div id="projectbrief">An open-source, heading-only library for Kalman filters and other recursive filters</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_open_kalman.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#typedef-members">Aliases</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">OpenKalman Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The root namespace for <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a>.  
<a href="namespace_open_kalman.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_open_kalman_1_1angle"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1angle.html">angle</a></td></tr>
<tr class="memdesc:namespace_open_kalman_1_1angle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for definitions relating to coefficients representing an angle. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_open_kalman_1_1_eigen3"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html">Eigen3</a></td></tr>
<tr class="memdesc:namespace_open_kalman_1_1_eigen3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for all <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> interface definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_open_kalman_1_1inclination"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1inclination.html">inclination</a></td></tr>
<tr class="memdesc:namespace_open_kalman_1_1inclination"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for definitions relating to coefficients representing an inclination. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_open_kalman_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2745b3bfff7250ac8d9e0dc79902508c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2745b3bfff7250ac8d9e0dc79902508c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2745b3bfff7250ac8d9e0dc79902508c">mean</a> = detail::is_mean&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:a2745b3bfff7250ac8d9e0dc79902508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d3de4ef2635e290fd9640db5721563"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2d3de4ef2635e290fd9640db5721563"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae2d3de4ef2635e290fd9640db5721563">wrapped_mean</a> = detail::is_wrapped_mean&lt;T&gt;::value</td></tr>
<tr class="separator:ae2d3de4ef2635e290fd9640db5721563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c621b67811a5ba3abe325f75618cd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50c621b67811a5ba3abe325f75618cd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a50c621b67811a5ba3abe325f75618cd8">euclidean_mean</a> = detail::is_euclidean_mean&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:a50c621b67811a5ba3abe325f75618cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434bc44aa1de7faf3cac40cca8944b44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a434bc44aa1de7faf3cac40cca8944b44"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a434bc44aa1de7faf3cac40cca8944b44">euclidean_transformed</a> = detail::is_euclidean_transformed&lt;T&gt;::value</td></tr>
<tr class="separator:a434bc44aa1de7faf3cac40cca8944b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19962a38a87cd8c8003e48f42150145"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae19962a38a87cd8c8003e48f42150145"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a> = <a class="el" href="namespace_open_kalman.html#a2745b3bfff7250ac8d9e0dc79902508c">mean</a>&lt;T&gt; or <a class="el" href="namespace_open_kalman.html#a50c621b67811a5ba3abe325f75618cd8">euclidean_mean</a>&lt;T&gt; or detail::is_matrix&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:ae19962a38a87cd8c8003e48f42150145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f3b5f0d758aec7db59022e845abed1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77f3b5f0d758aec7db59022e845abed1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a77f3b5f0d758aec7db59022e845abed1">column_vector</a> = detail::is_column_vector&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:a77f3b5f0d758aec7db59022e845abed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf939b25b2e4bfc1162f21533ae490e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bf939b25b2e4bfc1162f21533ae490e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4bf939b25b2e4bfc1162f21533ae490e">square_root_covariance</a> = detail::is_square_root_covariance&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:a4bf939b25b2e4bfc1162f21533ae490e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc62cd53d66b676058de97da3caaca3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc62cd53d66b676058de97da3caaca3b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#acc62cd53d66b676058de97da3caaca3b">covariance</a> = <a class="el" href="namespace_open_kalman.html#a4bf939b25b2e4bfc1162f21533ae490e">square_root_covariance</a>&lt;T&gt; or detail::is_sa_covariance&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:acc62cd53d66b676058de97da3caaca3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9367eb4d7b08c961db76037c1926531"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9367eb4d7b08c961db76037c1926531"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a> = detail::is_gaussian_distribution&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:af9367eb4d7b08c961db76037c1926531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80760930fc0db06999a2dce3dd4b53f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80760930fc0db06999a2dce3dd4b53f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a80760930fc0db06999a2dce3dd4b53f0">distribution</a> = <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>&lt;T&gt;</td></tr>
<tr class="separator:a80760930fc0db06999a2dce3dd4b53f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af847ece5eb2e6d50df847573c505b852"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af847ece5eb2e6d50df847573c505b852"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af847ece5eb2e6d50df847573c505b852">coefficients</a> = detail::is_coefficients&lt;T&gt;::value</td></tr>
<tr class="memdesc:af847ece5eb2e6d50df847573c505b852"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a group of atomic or composite coefficients.  <a href="namespace_open_kalman.html#af847ece5eb2e6d50df847573c505b852">More...</a><br /></td></tr>
<tr class="separator:af847ece5eb2e6d50df847573c505b852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78584a279011110fd315cbf73ca2fe36"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a78584a279011110fd315cbf73ca2fe36"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a78584a279011110fd315cbf73ca2fe36">equivalent_to</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__equivalent__to.html">internal::is_equivalent_to</a>&lt;T, U&gt;::value</td></tr>
<tr class="memdesc:a78584a279011110fd315cbf73ca2fe36"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is equivalent to U, where T and U are sets of coefficients.  <a href="namespace_open_kalman.html#a78584a279011110fd315cbf73ca2fe36">More...</a><br /></td></tr>
<tr class="separator:a78584a279011110fd315cbf73ca2fe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163a7971e4b4684e1793a209c83f5688"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a163a7971e4b4684e1793a209c83f5688"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a163a7971e4b4684e1793a209c83f5688">prefix_of</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__prefix__of.html">internal::is_prefix_of</a>&lt;T, U&gt;::value</td></tr>
<tr class="memdesc:a163a7971e4b4684e1793a209c83f5688"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a prefix of U, where T and U are sets of coefficients.  <a href="namespace_open_kalman.html#a163a7971e4b4684e1793a209c83f5688">More...</a><br /></td></tr>
<tr class="separator:a163a7971e4b4684e1793a209c83f5688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19898d83f3f0b722b834acac97f7c17e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19898d83f3f0b722b834acac97f7c17e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__covariance__nestable.html">internal::is_covariance_nestable</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a19898d83f3f0b722b834acac97f7c17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is an acceptable nested matrix for a covariance (including square_root_covariance).  <a href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">More...</a><br /></td></tr>
<tr class="separator:a19898d83f3f0b722b834acac97f7c17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5245fbf912b12a279acb815fcf7650d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5245fbf912b12a279acb815fcf7650d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__typed__matrix__nestable.html">internal::is_typed_matrix_nestable</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a5245fbf912b12a279acb815fcf7650d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a type that is nestable in a general typed matrix (e.g., matrix, mean, or euclidean_mean)  <a href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">More...</a><br /></td></tr>
<tr class="separator:a5245fbf912b12a279acb815fcf7650d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8b4f9495a8827f4f2235b3dd17a6aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef8b4f9495a8827f4f2235b3dd17a6aa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aef8b4f9495a8827f4f2235b3dd17a6aa">self_contained</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__self__contained.html">internal::is_self_contained</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:aef8b4f9495a8827f4f2235b3dd17a6aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a self-contained matrix or expression.  <a href="namespace_open_kalman.html#aef8b4f9495a8827f4f2235b3dd17a6aa">More...</a><br /></td></tr>
<tr class="separator:aef8b4f9495a8827f4f2235b3dd17a6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46b30e35dee139fe206951335c1b4ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae46b30e35dee139fe206951335c1b4ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae46b30e35dee139fe206951335c1b4ec">zero_matrix</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__zero__matrix.html">internal::is_zero_matrix</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:ae46b30e35dee139fe206951335c1b4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a zero matrix.  <a href="namespace_open_kalman.html#ae46b30e35dee139fe206951335c1b4ec">More...</a><br /></td></tr>
<tr class="separator:ae46b30e35dee139fe206951335c1b4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79246e358d47951c68ade232002bdecb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79246e358d47951c68ade232002bdecb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a79246e358d47951c68ade232002bdecb">identity_matrix</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__identity__matrix.html">internal::is_identity_matrix</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a79246e358d47951c68ade232002bdecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is an identity matrix.  <a href="namespace_open_kalman.html#a79246e358d47951c68ade232002bdecb">More...</a><br /></td></tr>
<tr class="separator:a79246e358d47951c68ade232002bdecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65caec2881ed038f08fbf632355bfbf4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65caec2881ed038f08fbf632355bfbf4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a65caec2881ed038f08fbf632355bfbf4">one_by_one_matrix</a> = detail::is_1by1&lt;T&gt;::value</td></tr>
<tr class="memdesc:a65caec2881ed038f08fbf632355bfbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a one-by-one matrix (i.e., one row and one column).  <a href="namespace_open_kalman.html#a65caec2881ed038f08fbf632355bfbf4">More...</a><br /></td></tr>
<tr class="separator:a65caec2881ed038f08fbf632355bfbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda49202b6dd92195051ed9db5fcdcaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acda49202b6dd92195051ed9db5fcdcaf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#acda49202b6dd92195051ed9db5fcdcaf">diagonal_matrix</a> = detail::is_diag_matrix_impl&lt;T&gt;::value</td></tr>
<tr class="memdesc:acda49202b6dd92195051ed9db5fcdcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a diagonal matrix.  <a href="namespace_open_kalman.html#acda49202b6dd92195051ed9db5fcdcaf">More...</a><br /></td></tr>
<tr class="separator:acda49202b6dd92195051ed9db5fcdcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63114cb8862cdcff4b5f0660b16a5bec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63114cb8862cdcff4b5f0660b16a5bec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a63114cb8862cdcff4b5f0660b16a5bec">self_adjoint_matrix</a> = detail::is_sa_matrix_impl&lt;T&gt;::value</td></tr>
<tr class="memdesc:a63114cb8862cdcff4b5f0660b16a5bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a self-adjoint matrix.  <a href="namespace_open_kalman.html#a63114cb8862cdcff4b5f0660b16a5bec">More...</a><br /></td></tr>
<tr class="separator:a63114cb8862cdcff4b5f0660b16a5bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05da5d495bfe6445599208b60bf12d69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05da5d495bfe6445599208b60bf12d69"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a05da5d495bfe6445599208b60bf12d69">lower_triangular_matrix</a> = detail::is_lt_matrix_impl&lt;T&gt;::value</td></tr>
<tr class="memdesc:a05da5d495bfe6445599208b60bf12d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a lower-triangular matrix.  <a href="namespace_open_kalman.html#a05da5d495bfe6445599208b60bf12d69">More...</a><br /></td></tr>
<tr class="separator:a05da5d495bfe6445599208b60bf12d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5456de7a2e027daca692a5c72dc3540e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5456de7a2e027daca692a5c72dc3540e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5456de7a2e027daca692a5c72dc3540e">upper_triangular_matrix</a> = detail::is_ut_matrix_impl&lt;T&gt;::value</td></tr>
<tr class="memdesc:a5456de7a2e027daca692a5c72dc3540e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is an upper-triangular matrix.  <a href="namespace_open_kalman.html#a5456de7a2e027daca692a5c72dc3540e">More...</a><br /></td></tr>
<tr class="separator:a5456de7a2e027daca692a5c72dc3540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada97c2afb746e33dd806af6f63957fce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada97c2afb746e33dd806af6f63957fce"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ada97c2afb746e33dd806af6f63957fce">triangular_matrix</a> = detail::is_triangular_matrix_impl&lt;T&gt;::value</td></tr>
<tr class="memdesc:ada97c2afb746e33dd806af6f63957fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a triangular matrix (upper or lower).  <a href="namespace_open_kalman.html#ada97c2afb746e33dd806af6f63957fce">More...</a><br /></td></tr>
<tr class="separator:ada97c2afb746e33dd806af6f63957fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2562e4c0918dc2cbf74de6a97d9388cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2562e4c0918dc2cbf74de6a97d9388cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2562e4c0918dc2cbf74de6a97d9388cf">cholesky_form</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__cholesky__form.html">internal::is_cholesky_form</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a2562e4c0918dc2cbf74de6a97d9388cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type has a nested native matrix that is a Cholesky square root.  <a href="namespace_open_kalman.html#a2562e4c0918dc2cbf74de6a97d9388cf">More...</a><br /></td></tr>
<tr class="separator:a2562e4c0918dc2cbf74de6a97d9388cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82301b5eacb294f1e37d3d90624921b"><td class="memTemplParams" colspan="2"><a id="ad82301b5eacb294f1e37d3d90624921b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad82301b5eacb294f1e37d3d90624921b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2">TriangleType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad82301b5eacb294f1e37d3d90624921b">triangle_type_of</a> = detail::triangle_type_of_impl&lt;T&gt;::value</td></tr>
<tr class="memdesc:ad82301b5eacb294f1e37d3d90624921b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive the TriangleType from the type of the triangular_matrix. <br /></td></tr>
<tr class="separator:ad82301b5eacb294f1e37d3d90624921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4a95b16bcf85246cc892ddf51cc9ddfa">element_gettable</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__element__gettable.html">internal::is_element_gettable</a>&lt;std::decay_t&lt;T&gt;, N&gt;::value</td></tr>
<tr class="memdesc:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type has elements that can be retrieved with N number of indices.  <a href="namespace_open_kalman.html#a4a95b16bcf85246cc892ddf51cc9ddfa">More...</a><br /></td></tr>
<tr class="separator:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77329c3cd71568cac6bd18c3add8d0c"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ac77329c3cd71568cac6bd18c3add8d0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac77329c3cd71568cac6bd18c3add8d0c">element_settable</a></td></tr>
<tr class="memdesc:ac77329c3cd71568cac6bd18c3add8d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type has elements that can be set with N number of indices.  <a href="namespace_open_kalman.html#ac77329c3cd71568cac6bd18c3add8d0c">More...</a><br /></td></tr>
<tr class="separator:ac77329c3cd71568cac6bd18c3add8d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac012d357f1dc0a72d7a6fb43d0169998"><td class="memTemplParams" colspan="2"><a id="ac012d357f1dc0a72d7a6fb43d0169998"></a>
template&lt;typename T , std::size_t order&gt; </td></tr>
<tr class="memitem:ac012d357f1dc0a72d7a6fb43d0169998"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac012d357f1dc0a72d7a6fb43d0169998">is_linearized_function_v</a> = <a class="el" href="struct_open_kalman_1_1is__linearized__function.html">is_linearized_function</a>&lt;T, order&gt;::value</td></tr>
<tr class="memdesc:ac012d357f1dc0a72d7a6fb43d0169998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__linearized__function.html" title="Whether an object is a linearized function (with defined Jacobian and optionally Hessian functions).">is_linearized_function</a>. <br /></td></tr>
<tr class="separator:ac012d357f1dc0a72d7a6fb43d0169998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac7f227b2f13e813d6e60695f05b004"><td class="memTemplParams" colspan="2"><a id="a5ac7f227b2f13e813d6e60695f05b004"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5ac7f227b2f13e813d6e60695f05b004"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5ac7f227b2f13e813d6e60695f05b004">is_perturbation_v</a> = is_perturbation&lt;T&gt;::value</td></tr>
<tr class="memdesc:a5ac7f227b2f13e813d6e60695f05b004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for is_perturbation. <br /></td></tr>
<tr class="separator:a5ac7f227b2f13e813d6e60695f05b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741c1e6dcd7c405a2f747e10fb2e2c02"><td class="memTemplParams" colspan="2"><a id="a741c1e6dcd7c405a2f747e10fb2e2c02"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a741c1e6dcd7c405a2f747e10fb2e2c02"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a741c1e6dcd7c405a2f747e10fb2e2c02">perturbation</a> = is_perturbation&lt;T&gt;::value</td></tr>
<tr class="memdesc:a741c1e6dcd7c405a2f747e10fb2e2c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for is_perturbation. <br /></td></tr>
<tr class="separator:a741c1e6dcd7c405a2f747e10fb2e2c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab6c606169452d88f33b64e3b1ae18fa2"><td class="memItemLeft" align="right" valign="top"><a id="ab6c606169452d88f33b64e3b1ae18fa2"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2">TriangleType</a> { <b>lower</b>
, <b>upper</b>
, <b>diagonal</b>
 }</td></tr>
<tr class="memdesc:ab6c606169452d88f33b64e3b1ae18fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a triangular matrix, either lower, upper, or diagonal. <br /></td></tr>
<tr class="separator:ab6c606169452d88f33b64e3b1ae18fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Aliases</h2></td></tr>
<tr class="memitem:abc8e1017c2a892423e656ba212290b74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename MatrixTraits&lt;T&gt;::NestedMatrix&gt; </td></tr>
<tr class="memitem:abc8e1017c2a892423e656ba212290b74"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a> = typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; T &gt;::NestedMatrix</td></tr>
<tr class="memdesc:abc8e1017c2a892423e656ba212290b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a type's nested matrix, if it exists.  <a href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">More...</a><br /></td></tr>
<tr class="separator:abc8e1017c2a892423e656ba212290b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d08cc520e029d965770641656727893"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d08cc520e029d965770641656727893"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1d08cc520e029d965770641656727893">self_contained_t</a> = std::conditional_t&lt; <a class="el" href="namespace_open_kalman.html#aef8b4f9495a8827f4f2235b3dd17a6aa">self_contained</a>&lt; T &gt;, std::decay_t&lt; T &gt;, typename detail::self_contained_impl&lt; T &gt;::type &gt;</td></tr>
<tr class="memdesc:a1d08cc520e029d965770641656727893"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for type, derived from and equivalent to parameter T, that is self-contained.  <a href="namespace_open_kalman.html#a1d08cc520e029d965770641656727893">More...</a><br /></td></tr>
<tr class="separator:a1d08cc520e029d965770641656727893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86f091b16817336eb3f67006cd3a779"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab86f091b16817336eb3f67006cd3a779"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a> = std::conditional_t&lt; std::is_lvalue_reference_v&lt; T &gt;, T, <a class="el" href="namespace_open_kalman.html#a1d08cc520e029d965770641656727893">self_contained_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ab86f091b16817336eb3f67006cd3a779"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a type, derived from and equivalent to parameter T, that can be passed as a function parameter.  <a href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">More...</a><br /></td></tr>
<tr class="separator:ab86f091b16817336eb3f67006cd3a779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb718bc7a10021ec9a0032e9b3fc92e"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t rows = MatrixTraits&lt;T&gt;::dimension, std::size_t cols = MatrixTraits&lt;T&gt;::columns&gt; </td></tr>
<tr class="memitem:a7fb718bc7a10021ec9a0032e9b3fc92e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a7fb718bc7a10021ec9a0032e9b3fc92e">native_matrix_t</a> = typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; T &gt;::template NativeMatrix&lt; rows, cols &gt;</td></tr>
<tr class="memdesc:a7fb718bc7a10021ec9a0032e9b3fc92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a self-contained native matrix, based on and equivalent to parameter T.  <a href="namespace_open_kalman.html#a7fb718bc7a10021ec9a0032e9b3fc92e">More...</a><br /></td></tr>
<tr class="separator:a7fb718bc7a10021ec9a0032e9b3fc92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66c8a3d2e7e2449a727d370262995ef"><td class="memTemplParams" colspan="2">template&lt;typename C , std::size_t N&gt; </td></tr>
<tr class="memitem:ac66c8a3d2e7e2449a727d370262995ef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">Replicate</a> = typename detail::ReplicateImpl&lt; C, N &gt;::type</td></tr>
<tr class="memdesc:ac66c8a3d2e7e2449a727d370262995ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>Coefficients&lt;C...&gt;</code>, where <code>C</code> is repeated <em>N</em> times.  <a href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">More...</a><br /></td></tr>
<tr class="separator:ac66c8a3d2e7e2449a727d370262995ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fbe21f478b7b06ac97b6eb6f5967c3"><td class="memTemplParams" colspan="2">template&lt;std::size_t size&gt; </td></tr>
<tr class="memitem:ad7fbe21f478b7b06ac97b6eb6f5967c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a> = <a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">Replicate</a>&lt; Axis, size &gt;</td></tr>
<tr class="memdesc:ad7fbe21f478b7b06ac97b6eb6f5967c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>Coefficients&lt;Axis...&gt;</code>, where Axis is repeated <code>size</code> times.  <a href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">More...</a><br /></td></tr>
<tr class="separator:ad7fbe21f478b7b06ac97b6eb6f5967c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098e86bc01897e4b391805799008a9f4"><td class="memTemplParams" colspan="2">template&lt;typename ... Coeffs&gt; </td></tr>
<tr class="memitem:a098e86bc01897e4b391805799008a9f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a098e86bc01897e4b391805799008a9f4">Concatenate</a> = typename detail::ConcatenateImpl&lt; Coeffs... &gt;::type</td></tr>
<tr class="memdesc:a098e86bc01897e4b391805799008a9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate any number of Coefficients&lt;...&gt; types.  <a href="namespace_open_kalman.html#a098e86bc01897e4b391805799008a9f4">More...</a><br /></td></tr>
<tr class="separator:a098e86bc01897e4b391805799008a9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322bd5c1958f6977b8627bceb8d6ba18"><td class="memItemLeft" align="right" valign="top"><a id="a322bd5c1958f6977b8627bceb8d6ba18"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CubatureTransform</b> = <a class="el" href="struct_open_kalman_1_1_sample_points_transform.html">SamplePointsTransform</a>&lt; CubaturePoints &gt;</td></tr>
<tr class="separator:a322bd5c1958f6977b8627bceb8d6ba18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb3984e6d92af7ead25a90f38f1d48d"><td class="memItemLeft" align="right" valign="top"><a id="aecb3984e6d92af7ead25a90f38f1d48d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UnscentedTransform</b> = <a class="el" href="struct_open_kalman_1_1_sample_points_transform.html">SamplePointsTransform</a>&lt; <a class="el" href="namespace_open_kalman.html#a8b0239f8b1168cde423e125102a257b3">UnscentedSigmaPoints</a> &gt;</td></tr>
<tr class="separator:aecb3984e6d92af7ead25a90f38f1d48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5313251ad9dffa61e697a4bd2cfc3b6"><td class="memItemLeft" align="right" valign="top"><a id="ad5313251ad9dffa61e697a4bd2cfc3b6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UnscentedTransformParameterEstimation</b> = <a class="el" href="struct_open_kalman_1_1_sample_points_transform.html">SamplePointsTransform</a>&lt; UnscentedSigmaPointsParameterEstimation &gt;</td></tr>
<tr class="separator:ad5313251ad9dffa61e697a4bd2cfc3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4e48c14c18eb62b99c005ae82255be"><td class="memItemLeft" align="right" valign="top"><a id="a7b4e48c14c18eb62b99c005ae82255be"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UnscentedSigmaPointsStateEstimation</b> = SigmaPoints&lt; Unscented&lt; <a class="el" href="struct_open_kalman_1_1_unscented_parameters_state_estimation.html">UnscentedParametersStateEstimation</a> &gt; &gt;</td></tr>
<tr class="separator:a7b4e48c14c18eb62b99c005ae82255be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bfcd723cacf106eeedb5b242a3c425"><td class="memItemLeft" align="right" valign="top"><a id="ac8bfcd723cacf106eeedb5b242a3c425"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>UnscentedSigmaPointsParameterEstimation</b> = SigmaPoints&lt; Unscented&lt; <a class="el" href="struct_open_kalman_1_1_unscented_parameters_parameter_estimation.html">UnscentedParametersParameterEstimation</a> &gt; &gt;</td></tr>
<tr class="separator:ac8bfcd723cacf106eeedb5b242a3c425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0239f8b1168cde423e125102a257b3"><td class="memItemLeft" align="right" valign="top"><a id="a8b0239f8b1168cde423e125102a257b3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a8b0239f8b1168cde423e125102a257b3">UnscentedSigmaPoints</a> = SigmaPoints&lt; Unscented&lt;&gt; &gt;</td></tr>
<tr class="memdesc:a8b0239f8b1168cde423e125102a257b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as UnscentedSigmaPointsStateEstimation. <br /></td></tr>
<tr class="separator:a8b0239f8b1168cde423e125102a257b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4573e83439df0815982003e65a6413fb"><td class="memItemLeft" align="right" valign="top"><a id="a4573e83439df0815982003e65a6413fb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SphericalSimplexSigmaPoints</b> = SigmaPoints&lt; SphericalSimplex&lt;&gt; &gt;</td></tr>
<tr class="separator:a4573e83439df0815982003e65a6413fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeb6f38230dcdbeeecce62ba45cf45714"><td class="memTemplParams" colspan="2"><a id="aeb6f38230dcdbeeecce62ba45cf45714"></a>
template&lt;typename D , std::enable_if_t&lt; gaussian_distribution&lt; D &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aeb6f38230dcdbeeecce62ba45cf45714"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GaussianDistribution</b> (D &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_gaussian_distribution.html">GaussianDistribution</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_distribution_traits.html">DistributionTraits</a>&lt; D &gt;::<a class="el" href="struct_open_kalman_1_1_coefficients.html">Coefficients</a>, <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_distribution_traits.html">DistributionTraits</a>&lt; <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a>&lt; D &gt;&gt;::<a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a> &gt;, <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_distribution_traits.html">DistributionTraits</a>&lt; <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a>&lt; D &gt;&gt;::<a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a> &gt;&gt;</td></tr>
<tr class="separator:aeb6f38230dcdbeeecce62ba45cf45714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4a480268c32d2e7531eae879bba64e"><td class="memTemplParams" colspan="2"><a id="a3f4a480268c32d2e7531eae879bba64e"></a>
template&lt;typename M , typename C , std::enable_if_t&lt; typed_matrix&lt; M &gt; and covariance&lt; C &gt; and not square_root_covariance&lt; C &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3f4a480268c32d2e7531eae879bba64e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GaussianDistribution</b> (M &amp;&amp;, C &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_gaussian_distribution.html">GaussianDistribution</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::RowCoefficients, <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a>&lt; <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a>&lt; M &gt;&gt;, <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a>&lt; <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a>&lt; C &gt;&gt;&gt;</td></tr>
<tr class="separator:a3f4a480268c32d2e7531eae879bba64e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131455a38340a120002aca624717d3d4"><td class="memTemplParams" colspan="2"><a id="a131455a38340a120002aca624717d3d4"></a>
template&lt;typename D , std::enable_if_t&lt; gaussian_distribution&lt; D &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a131455a38340a120002aca624717d3d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a131455a38340a120002aca624717d3d4">make_GaussianDistribution</a> (D &amp;&amp;dist) noexcept</td></tr>
<tr class="memdesc:a131455a38340a120002aca624717d3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution from another Gaussian distribution. <br /></td></tr>
<tr class="separator:a131455a38340a120002aca624717d3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="memTemplParams" colspan="2"><a id="ac2d0c0d4d3f9bab0130dbcd6654617c0"></a>
template&lt;typename re  = std::mt19937, typename M , typename Cov , std::enable_if_t&lt; not coefficients&lt; re &gt; and(typed_matrix&lt; M &gt; or typed_matrix_nestable&lt; M &gt;) and(covariance&lt; Cov &gt; or covariance_nestable&lt; Cov &gt; or typed_matrix&lt; Cov &gt; or typed_matrix_nestable&lt; Cov &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac2d0c0d4d3f9bab0130dbcd6654617c0">make_GaussianDistribution</a> (M &amp;&amp;<a class="el" href="namespace_open_kalman.html#a2745b3bfff7250ac8d9e0dc79902508c">mean</a>, Cov &amp;&amp;cov) noexcept</td></tr>
<tr class="memdesc:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution from a mean and a covariance. <br /></td></tr>
<tr class="separator:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f53ae8006d8068435df09f99c8baf0"><td class="memTemplParams" colspan="2"><a id="a87f53ae8006d8068435df09f99c8baf0"></a>
template&lt;typename Coefficients , typename re  = std::mt19937, typename M , typename Cov , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(covariance_nestable&lt; Cov &gt; or typed_matrix_nestable&lt; Cov &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a87f53ae8006d8068435df09f99c8baf0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a87f53ae8006d8068435df09f99c8baf0">make_GaussianDistribution</a> (M &amp;&amp;<a class="el" href="namespace_open_kalman.html#a2745b3bfff7250ac8d9e0dc79902508c">mean</a>, Cov &amp;&amp;cov) noexcept</td></tr>
<tr class="memdesc:a87f53ae8006d8068435df09f99c8baf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution from a typed_matrix_nestable and a covariance_nestable or regular matrix for the covariance. <br /></td></tr>
<tr class="separator:a87f53ae8006d8068435df09f99c8baf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a419b046972de2b566cc220dcae618"><td class="memTemplParams" colspan="2"><a id="a30a419b046972de2b566cc220dcae618"></a>
template&lt;typename M , typename Cov , typename re  = std::mt19937, std::enable_if_t&lt;(typed_matrix&lt; M &gt; or typed_matrix_nestable&lt; M &gt;) and(covariance&lt; Cov &gt; or covariance_nestable&lt; Cov &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a30a419b046972de2b566cc220dcae618"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a30a419b046972de2b566cc220dcae618">make_GaussianDistribution</a> ()</td></tr>
<tr class="memdesc:a30a419b046972de2b566cc220dcae618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default Gaussian distribution from a typed matrix (or typed_matrix_nestable) and a covariance (or covariance_nestable). <br /></td></tr>
<tr class="separator:a30a419b046972de2b566cc220dcae618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c01a83c83d3a23aafb59dcd527daed1"><td class="memTemplParams" colspan="2"><a id="a8c01a83c83d3a23aafb59dcd527daed1"></a>
template&lt;typename Coefficients , typename M , typename Cov , typename re  = std::mt19937, std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt; and covariance_nestable&lt; Cov &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8c01a83c83d3a23aafb59dcd527daed1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a8c01a83c83d3a23aafb59dcd527daed1">make_GaussianDistribution</a> ()</td></tr>
<tr class="memdesc:a8c01a83c83d3a23aafb59dcd527daed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default Gaussian distribution from a typed_matrix_nestable and a covariance_nestable or regular matrix for the covariance. <br /></td></tr>
<tr class="separator:a8c01a83c83d3a23aafb59dcd527daed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d2e4b600345150553cfd00b35b5873"><td class="memTemplParams" colspan="2"><a id="a14d2e4b600345150553cfd00b35b5873"></a>
template&lt;typename Arg , std::enable_if_t&lt; gaussian_distribution&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a14d2e4b600345150553cfd00b35b5873"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mean_of</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a14d2e4b600345150553cfd00b35b5873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd8a5e344ce40d706ed10798b1aec8d"><td class="memTemplParams" colspan="2"><a id="a9bd8a5e344ce40d706ed10798b1aec8d"></a>
template&lt;typename Arg , std::enable_if_t&lt; gaussian_distribution&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9bd8a5e344ce40d706ed10798b1aec8d"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>covariance_of</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a9bd8a5e344ce40d706ed10798b1aec8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0641e84ff6f6105215fe70acc0896277"><td class="memTemplParams" colspan="2"><a id="a0641e84ff6f6105215fe70acc0896277"></a>
template&lt;typename Arg , std::enable_if_t&lt; gaussian_distribution&lt; Arg &gt; and not cholesky_form&lt; Arg &gt; and not diagonal_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0641e84ff6f6105215fe70acc0896277"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_Cholesky</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a0641e84ff6f6105215fe70acc0896277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c544e1f5e268ea657d3895746468c91"><td class="memTemplParams" colspan="2"><a id="a6c544e1f5e268ea657d3895746468c91"></a>
template&lt;typename Arg , std::enable_if_t&lt; gaussian_distribution&lt; Arg &gt; and cholesky_form&lt; Arg &gt; and not diagonal_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6c544e1f5e268ea657d3895746468c91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_Cholesky</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a6c544e1f5e268ea657d3895746468c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad137ac22381d6cd2d06a57b96a3f4a83"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename Arg , std::enable_if_t&lt; gaussian_distribution&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad137ac22381d6cd2d06a57b96a3f4a83"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad137ac22381d6cd2d06a57b96a3f4a83">make_self_contained</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:ad137ac22381d6cd2d06a57b96a3f4a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to self-contained version of the distribution.  <a href="namespace_open_kalman.html#ad137ac22381d6cd2d06a57b96a3f4a83">More...</a><br /></td></tr>
<tr class="separator:ad137ac22381d6cd2d06a57b96a3f4a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f06f7fc72648cedfd49327fa17ac75"><td class="memTemplParams" colspan="2"><a id="a20f06f7fc72648cedfd49327fa17ac75"></a>
template&lt;typename D , typename ... Ds, std::enable_if_t&lt;(gaussian_distribution&lt; D &gt; and ... and gaussian_distribution&lt; Ds &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a20f06f7fc72648cedfd49327fa17ac75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>concatenate</b> (const D &amp;d, const Ds &amp;... ds)</td></tr>
<tr class="separator:a20f06f7fc72648cedfd49327fa17ac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="memTemplParams" colspan="2"><a id="a6656a830ae8f0446ec8f3bfe5159a90f"></a>
template&lt;typename ... Cs, typename D , std::enable_if_t&lt; gaussian_distribution&lt; D &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6656a830ae8f0446ec8f3bfe5159a90f">split</a> (D &amp;&amp;d) noexcept</td></tr>
<tr class="memdesc:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split distribution. <br /></td></tr>
<tr class="separator:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b12ec95de2bc68ab2b3115873d36e6"><td class="memTemplParams" colspan="2"><a id="a74b12ec95de2bc68ab2b3115873d36e6"></a>
template&lt;typename Dist , std::enable_if_t&lt; gaussian_distribution&lt; Dist &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a74b12ec95de2bc68ab2b3115873d36e6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const Dist &amp;d)</td></tr>
<tr class="separator:a74b12ec95de2bc68ab2b3115873d36e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189f804de633e1696b5ea798571632c6"><td class="memTemplParams" colspan="2"><a id="a189f804de633e1696b5ea798571632c6"></a>
template&lt;typename Dist1 , typename Dist2 , std::enable_if_t&lt; gaussian_distribution&lt; Dist1 &gt; and gaussian_distribution&lt; Dist2 &gt; and equivalent_to&lt; typename DistributionTraits&lt; Dist1 &gt;::Coefficients, typename DistributionTraits&lt; Dist2 &gt;::Coefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a189f804de633e1696b5ea798571632c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const Dist1 &amp;d1, const Dist2 &amp;d2)</td></tr>
<tr class="separator:a189f804de633e1696b5ea798571632c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708c180a99179c17769a15d282d4cf97"><td class="memTemplParams" colspan="2"><a id="a708c180a99179c17769a15d282d4cf97"></a>
template&lt;typename Dist1 , typename Dist2 , std::enable_if_t&lt; gaussian_distribution&lt; Dist1 &gt; and gaussian_distribution&lt; Dist2 &gt; and equivalent_to&lt; typename DistributionTraits&lt; Dist1 &gt;::Coefficients, typename DistributionTraits&lt; Dist2 &gt;::Coefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a708c180a99179c17769a15d282d4cf97"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const Dist1 &amp;d1, const Dist2 &amp;d2)</td></tr>
<tr class="separator:a708c180a99179c17769a15d282d4cf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3371aaf35876aee1bc583ef48d123617"><td class="memTemplParams" colspan="2"><a id="a3371aaf35876aee1bc583ef48d123617"></a>
template&lt;typename A , typename D , std::enable_if_t&lt; typed_matrix&lt; A &gt; and gaussian_distribution&lt; D &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3371aaf35876aee1bc583ef48d123617"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const A &amp;a, const D &amp;d)</td></tr>
<tr class="separator:a3371aaf35876aee1bc583ef48d123617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf93273a761823f98487e018bf9cc55b"><td class="memTemplParams" colspan="2"><a id="aaf93273a761823f98487e018bf9cc55b"></a>
template&lt;typename Dist , typename S , std::enable_if_t&lt; gaussian_distribution&lt; Dist &gt; and std::is_convertible_v&lt; S, typename DistributionTraits&lt; Dist &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aaf93273a761823f98487e018bf9cc55b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (Dist &amp;&amp;d, const S s)</td></tr>
<tr class="separator:aaf93273a761823f98487e018bf9cc55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3aa9d1579cf96946a65a7dfd9ad315"><td class="memTemplParams" colspan="2"><a id="a3a3aa9d1579cf96946a65a7dfd9ad315"></a>
template&lt;typename Dist , typename S , std::enable_if_t&lt; gaussian_distribution&lt; Dist &gt; and std::is_convertible_v&lt; S, typename DistributionTraits&lt; Dist &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3a3aa9d1579cf96946a65a7dfd9ad315"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const S s, Dist &amp;&amp;d)</td></tr>
<tr class="separator:a3a3aa9d1579cf96946a65a7dfd9ad315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da67807e9ed9ade59482260747bc809"><td class="memTemplParams" colspan="2"><a id="a2da67807e9ed9ade59482260747bc809"></a>
template&lt;typename Dist , typename S , std::enable_if_t&lt; gaussian_distribution&lt; Dist &gt; and std::is_convertible_v&lt; S, typename DistributionTraits&lt; Dist &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2da67807e9ed9ade59482260747bc809"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (Dist &amp;&amp;d, const S s)</td></tr>
<tr class="separator:a2da67807e9ed9ade59482260747bc809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6c1ea30e81f7795fcf0fd773807887"><td class="memTemplParams" colspan="2"><a id="aec6c1ea30e81f7795fcf0fd773807887"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:aec6c1ea30e81f7795fcf0fd773807887"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>KalmanFilter</b> (P &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_kalman_filter.html">KalmanFilter</a>&lt; P &gt;</td></tr>
<tr class="separator:aec6c1ea30e81f7795fcf0fd773807887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5203529b2d7c88e224b48a320bbc7e7b"><td class="memTemplParams" colspan="2"><a id="a5203529b2d7c88e224b48a320bbc7e7b"></a>
template&lt;typename P , typename M &gt; </td></tr>
<tr class="memitem:a5203529b2d7c88e224b48a320bbc7e7b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>KalmanFilter</b> (P &amp;&amp;, M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_kalman_filter.html">KalmanFilter</a>&lt; P, M &gt;</td></tr>
<tr class="separator:a5203529b2d7c88e224b48a320bbc7e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef7259e3509057d19e67622dc66ff5c"><td class="memTemplParams" colspan="2"><a id="a0ef7259e3509057d19e67622dc66ff5c"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0ef7259e3509057d19e67622dc66ff5c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Matrix</b> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_matrix.html">Matrix</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; sizeof...(Args)&gt;, Axis, Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, sizeof...(Args), 1 &gt;&gt;</td></tr>
<tr class="separator:a0ef7259e3509057d19e67622dc66ff5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b797c590b3e19ce373b02f7237e4bb1"><td class="memTemplParams" colspan="2"><a id="a4b797c590b3e19ce373b02f7237e4bb1"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4b797c590b3e19ce373b02f7237e4bb1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4b797c590b3e19ce373b02f7237e4bb1">Mean</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; sizeof...(Args)&gt;, Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, sizeof...(Args), 1 &gt;&gt;</td></tr>
<tr class="memdesc:a4b797c590b3e19ce373b02f7237e4bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, deduce a single-column mean with all Axis coefficients. <br /></td></tr>
<tr class="separator:a4b797c590b3e19ce373b02f7237e4bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299661af360b08bf64b104c3376f9126"><td class="memTemplParams" colspan="2"><a id="a299661af360b08bf64b104c3376f9126"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a299661af360b08bf64b104c3376f9126"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a299661af360b08bf64b104c3376f9126">EuclideanMean</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">OpenKalman::Axes</a>&lt; sizeof...(Args)&gt;, Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, sizeof...(Args), 1 &gt;&gt;</td></tr>
<tr class="memdesc:a299661af360b08bf64b104c3376f9126"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, construct a single-column Euclidean mean. <br /></td></tr>
<tr class="separator:a299661af360b08bf64b104c3376f9126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c706282524a9765f4fe3cea62fc99c6"><td class="memTemplParams" colspan="2"><a id="a2c706282524a9765f4fe3cea62fc99c6"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2c706282524a9765f4fe3cea62fc99c6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2c706282524a9765f4fe3cea62fc99c6">Covariance</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">internal::constexpr_sqrt</a>(sizeof...(Args))&gt;, <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">Eigen3::SelfAdjointMatrix</a>&lt; Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">internal::constexpr_sqrt</a>(sizeof...(Args)), <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">internal::constexpr_sqrt</a>(sizeof...(Args))&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a2c706282524a9765f4fe3cea62fc99c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, derive a square, self-adjoint matrix. <br /></td></tr>
<tr class="separator:a2c706282524a9765f4fe3cea62fc99c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad575f1ca1f80d5beb7016d6e6ab31790"><td class="memTemplParams" colspan="2"><a id="ad575f1ca1f80d5beb7016d6e6ab31790"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad575f1ca1f80d5beb7016d6e6ab31790"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad575f1ca1f80d5beb7016d6e6ab31790">SquareRootCovariance</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html">SquareRootCovariance</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">internal::constexpr_sqrt</a>(sizeof...(Args))&gt;, <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_triangular_matrix.html">Eigen3::TriangularMatrix</a>&lt; Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">OpenKalman::internal::constexpr_sqrt</a>(sizeof...(Args)), <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">OpenKalman::internal::constexpr_sqrt</a>(sizeof...(Args))&gt;&gt;&gt;</td></tr>
<tr class="memdesc:ad575f1ca1f80d5beb7016d6e6ab31790"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, derive a square, lower triangular matrix. <br /></td></tr>
<tr class="separator:ad575f1ca1f80d5beb7016d6e6ab31790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c3621e7f7c43e0ce6334bedd6e8692"><td class="memTemplParams" colspan="2"><a id="a90c3621e7f7c43e0ce6334bedd6e8692"></a>
template&lt;typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a90c3621e7f7c43e0ce6334bedd6e8692"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Covariance</b> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::RowCoefficients, <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a>&lt; M &gt;&gt;</td></tr>
<tr class="separator:a90c3621e7f7c43e0ce6334bedd6e8692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1167376779e08b44911a5b18134ba1d4"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and covariance_nestable&lt; Arg &gt; and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1167376779e08b44911a5b18134ba1d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1167376779e08b44911a5b18134ba1d4">make_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a1167376779e08b44911a5b18134ba1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a covariance_nestable, specifying the coefficients.  <a href="namespace_open_kalman.html#a1167376779e08b44911a5b18134ba1d4">More...</a><br /></td></tr>
<tr class="separator:a1167376779e08b44911a5b18134ba1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1367d0df6f272ee442c2272a228ab8"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance_nestable&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8b1367d0df6f272ee442c2272a228ab8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a8b1367d0df6f272ee442c2272a228ab8">make_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a8b1367d0df6f272ee442c2272a228ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a covariance_nestable, with default Axis coefficients.  <a href="namespace_open_kalman.html#a8b1367d0df6f272ee442c2272a228ab8">More...</a><br /></td></tr>
<tr class="separator:a8b1367d0df6f272ee442c2272a228ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae21ef7c840cf37fb755618dd419a221"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and(not covariance_nestable&lt; Arg &gt;) and(triangle_type==TriangleType::lower or triangle_type==TriangleType::upper) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aae21ef7c840cf37fb755618dd419a221"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aae21ef7c840cf37fb755618dd419a221">make_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:aae21ef7c840cf37fb755618dd419a221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> (with nested triangular matrix) from a self-adjoint typed_matrix_nestable.  <a href="namespace_open_kalman.html#aae21ef7c840cf37fb755618dd419a221">More...</a><br /></td></tr>
<tr class="separator:aae21ef7c840cf37fb755618dd419a221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e11974581182d024289c3df6f00e92b"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6e11974581182d024289c3df6f00e92b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6e11974581182d024289c3df6f00e92b">make_covariance</a> ()</td></tr>
<tr class="memdesc:a6e11974581182d024289c3df6f00e92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a covariance_nestable or typed_matrix_nestable.  <a href="namespace_open_kalman.html#a6e11974581182d024289c3df6f00e92b">More...</a><br /></td></tr>
<tr class="separator:a6e11974581182d024289c3df6f00e92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f4317db70b740a4b05b154ea7d144e"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a74f4317db70b740a4b05b154ea7d144e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a74f4317db70b740a4b05b154ea7d144e">make_covariance</a> ()</td></tr>
<tr class="memdesc:a74f4317db70b740a4b05b154ea7d144e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> with a nested triangular matrix, from a typed_matrix_nestable.  <a href="namespace_open_kalman.html#a74f4317db70b740a4b05b154ea7d144e">More...</a><br /></td></tr>
<tr class="separator:a74f4317db70b740a4b05b154ea7d144e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82a27123450aa0fd5266c332bde0362"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af82a27123450aa0fd5266c332bde0362"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af82a27123450aa0fd5266c332bde0362">make_covariance</a> ()</td></tr>
<tr class="memdesc:af82a27123450aa0fd5266c332bde0362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a typed_matrix_nestable or covariance_nestable.  <a href="namespace_open_kalman.html#af82a27123450aa0fd5266c332bde0362">More...</a><br /></td></tr>
<tr class="separator:af82a27123450aa0fd5266c332bde0362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dc097a8ab1edb54efc24071cccb68a"><td class="memTemplParams" colspan="2"><a id="ac2dc097a8ab1edb54efc24071cccb68a"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt;(covariance&lt; Arg1 &gt; and(covariance&lt; Arg2 &gt; or typed_matrix&lt; Arg2 &gt;)) or(typed_matrix&lt; Arg1 &gt; and covariance&lt; Arg2 &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac2dc097a8ab1edb54efc24071cccb68a"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (Arg1 &amp;&amp;arg1, Arg2 &amp;&amp;arg2)</td></tr>
<tr class="separator:ac2dc097a8ab1edb54efc24071cccb68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da8b8930aaa180daa6782f7b243ea63"><td class="memTemplParams" colspan="2"><a id="a1da8b8930aaa180daa6782f7b243ea63"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt;(covariance&lt; Arg1 &gt; and(covariance&lt; Arg2 &gt; or typed_matrix&lt; Arg2 &gt;)) or(typed_matrix&lt; Arg1 &gt; and covariance&lt; Arg2 &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1da8b8930aaa180daa6782f7b243ea63"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (Arg1 &amp;&amp;arg1, Arg2 &amp;&amp;arg2)</td></tr>
<tr class="separator:a1da8b8930aaa180daa6782f7b243ea63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8f99371e3f22ae56f03a8b5ea4bca3"><td class="memTemplParams" colspan="2"><a id="a9c8f99371e3f22ae56f03a8b5ea4bca3"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt; covariance&lt; Arg1 &gt; and covariance&lt; Arg2 &gt; and equivalent_to&lt; typename MatrixTraits&lt; Arg1 &gt;::RowCoefficients, typename MatrixTraits&lt; Arg2 &gt;::RowCoefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9c8f99371e3f22ae56f03a8b5ea4bca3"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (Arg1 &amp;&amp;arg1, Arg2 &amp;&amp;arg2) noexcept</td></tr>
<tr class="separator:a9c8f99371e3f22ae56f03a8b5ea4bca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0fb0ebb64b857004cc5967e75bcf40"><td class="memTemplParams" colspan="2"><a id="abf0fb0ebb64b857004cc5967e75bcf40"></a>
template&lt;typename M , typename Cov , std::enable_if_t&lt; typed_matrix&lt; M &gt; and covariance&lt; Cov &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:abf0fb0ebb64b857004cc5967e75bcf40"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (M &amp;&amp;m, Cov &amp;&amp;cov) noexcept</td></tr>
<tr class="separator:abf0fb0ebb64b857004cc5967e75bcf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78212f67c3e24b3314a2c11a5c58e4b"><td class="memTemplParams" colspan="2"><a id="ae78212f67c3e24b3314a2c11a5c58e4b"></a>
template&lt;typename Cov , typename M , std::enable_if_t&lt; covariance&lt; Cov &gt; and typed_matrix&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae78212f67c3e24b3314a2c11a5c58e4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (Cov &amp;&amp;cov, M &amp;&amp;m) noexcept</td></tr>
<tr class="separator:ae78212f67c3e24b3314a2c11a5c58e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f6010166be08b5ded8fd65f108da49"><td class="memTemplParams" colspan="2"><a id="a85f6010166be08b5ded8fd65f108da49"></a>
template&lt;typename M , typename S , std::enable_if_t&lt; covariance&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a85f6010166be08b5ded8fd65f108da49"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (M &amp;&amp;m, const S s) noexcept</td></tr>
<tr class="separator:a85f6010166be08b5ded8fd65f108da49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b95d4c1f3025e4b8b4ca458641f0cf"><td class="memTemplParams" colspan="2"><a id="a45b95d4c1f3025e4b8b4ca458641f0cf"></a>
template&lt;typename S , typename M , std::enable_if_t&lt; std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt; and covariance&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a45b95d4c1f3025e4b8b4ca458641f0cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const S s, M &amp;&amp;m) noexcept</td></tr>
<tr class="separator:a45b95d4c1f3025e4b8b4ca458641f0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a6ba1e817ff8e11542c4b7c9782246"><td class="memTemplParams" colspan="2"><a id="a06a6ba1e817ff8e11542c4b7c9782246"></a>
template&lt;typename M , typename S , std::enable_if_t&lt; covariance&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a06a6ba1e817ff8e11542c4b7c9782246"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (M &amp;&amp;m, const S s)</td></tr>
<tr class="separator:a06a6ba1e817ff8e11542c4b7c9782246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415939aa93212817bac5ee06a0630e04"><td class="memTemplParams" colspan="2"><a id="a415939aa93212817bac5ee06a0630e04"></a>
template&lt;typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a415939aa93212817bac5ee06a0630e04"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (M &amp;&amp;m) noexcept</td></tr>
<tr class="separator:a415939aa93212817bac5ee06a0630e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a774b47e620ec1a0fae797bef8e553a49"><td class="memTemplParams" colspan="2"><a id="a774b47e620ec1a0fae797bef8e553a49"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt; covariance&lt; Arg1 &gt; and covariance&lt; Arg2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a774b47e620ec1a0fae797bef8e553a49"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const Arg1 &amp;arg1, const Arg2 &amp;arg2)</td></tr>
<tr class="separator:a774b47e620ec1a0fae797bef8e553a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5180fdd8e25991ba6516e0d523ed0229"><td class="memTemplParams" colspan="2"><a id="a5180fdd8e25991ba6516e0d523ed0229"></a>
template&lt;typename Arg1 , typename Arg2 , std::enable_if_t&lt; covariance&lt; Arg1 &gt; and covariance&lt; Arg2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5180fdd8e25991ba6516e0d523ed0229"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const Arg1 &amp;arg1, const Arg2 &amp;arg2)</td></tr>
<tr class="separator:a5180fdd8e25991ba6516e0d523ed0229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f2335ea8a758c0b229c54cadc27aa1"><td class="memTemplParams" colspan="2">template&lt;typename M , typename S , std::enable_if_t&lt; covariance&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a77f2335ea8a758c0b229c54cadc27aa1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a> (M &amp;&amp;m, const S s)</td></tr>
<tr class="separator:a77f2335ea8a758c0b229c54cadc27aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f44bd141f1e2b9b65432a633d9180e2"><td class="memTemplParams" colspan="2">template&lt;typename M , typename S , std::enable_if_t&lt; covariance&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6f44bd141f1e2b9b65432a633d9180e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6f44bd141f1e2b9b65432a633d9180e2">inverse_scale</a> (M &amp;&amp;m, const S s)</td></tr>
<tr class="separator:a6f44bd141f1e2b9b65432a633d9180e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be486e53ad3cb44d7ea46c4201f4ce5"><td class="memTemplParams" colspan="2">template&lt;typename M , typename A , std::enable_if_t&lt; covariance&lt; M &gt; and typed_matrix&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3be486e53ad3cb44d7ea46c4201f4ce5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3be486e53ad3cb44d7ea46c4201f4ce5">scale</a> (M &amp;&amp;m, A &amp;&amp;a)</td></tr>
<tr class="separator:a3be486e53ad3cb44d7ea46c4201f4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94754fd4ae4cc92cb970c04be6afc45"><td class="memTemplParams" colspan="2"><a id="ad94754fd4ae4cc92cb970c04be6afc45"></a>
template&lt;typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad94754fd4ae4cc92cb970c04be6afc45"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nested_matrix</b> (M &amp;&amp;m) noexcept</td></tr>
<tr class="separator:ad94754fd4ae4cc92cb970c04be6afc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579e1ec33564b5e46be63b872b9aad5f"><td class="memTemplParams" colspan="2"><a id="a579e1ec33564b5e46be63b872b9aad5f"></a>
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt; and not square_root_covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a579e1ec33564b5e46be63b872b9aad5f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>square_root</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a579e1ec33564b5e46be63b872b9aad5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206fbe83e03311e2b265a5d28bf0eec9"><td class="memTemplParams" colspan="2"><a id="a206fbe83e03311e2b265a5d28bf0eec9"></a>
template&lt;typename Arg , std::enable_if_t&lt; square_root_covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a206fbe83e03311e2b265a5d28bf0eec9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>square</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a206fbe83e03311e2b265a5d28bf0eec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd840cc6cadb87e6bae5724c66b575a9"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acd840cc6cadb87e6bae5724c66b575a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#acd840cc6cadb87e6bae5724c66b575a9">make_native_matrix</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:acd840cc6cadb87e6bae5724c66b575a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aca24c428687bac2d17ef1efd20f4fe"><td class="memTemplParams" colspan="2"><a id="a0aca24c428687bac2d17ef1efd20f4fe"></a>
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0aca24c428687bac2d17ef1efd20f4fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a0aca24c428687bac2d17ef1efd20f4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfd416d34f737890d02a7df5c231ad2"><td class="memTemplParams" colspan="2"><a id="addfd416d34f737890d02a7df5c231ad2"></a>
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:addfd416d34f737890d02a7df5c231ad2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adjoint</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:addfd416d34f737890d02a7df5c231ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d15f831673c20ed3bfd363a2df21b28"><td class="memTemplParams" colspan="2"><a id="a9d15f831673c20ed3bfd363a2df21b28"></a>
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9d15f831673c20ed3bfd363a2df21b28"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>determinant</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a9d15f831673c20ed3bfd363a2df21b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc11a35860348b1b517cf8487f38ced"><td class="memTemplParams" colspan="2"><a id="afdc11a35860348b1b517cf8487f38ced"></a>
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afdc11a35860348b1b517cf8487f38ced"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trace</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:afdc11a35860348b1b517cf8487f38ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af362226c188b29e2967097ba0f5f75"><td class="memTemplParams" colspan="2"><a id="a5af362226c188b29e2967097ba0f5f75"></a>
template&lt;typename Arg , typename U , std::enable_if_t&lt; covariance&lt; Arg &gt; and typed_matrix&lt; U &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5af362226c188b29e2967097ba0f5f75"><td class="memTemplItemLeft" align="right" valign="top">Arg &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rank_update</b> (Arg &amp;arg, const U &amp;u, const typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; Arg &gt;::Scalar alpha=1)</td></tr>
<tr class="separator:a5af362226c188b29e2967097ba0f5f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d12c21618fa40c9195f01ac20ae203"><td class="memTemplParams" colspan="2"><a id="ad1d12c21618fa40c9195f01ac20ae203"></a>
template&lt;typename Arg , typename U , std::enable_if_t&lt; covariance&lt; Arg &gt; and typed_matrix&lt; U &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad1d12c21618fa40c9195f01ac20ae203"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rank_update</b> (Arg &amp;&amp;arg, const U &amp;u, const typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; Arg &gt;::Scalar alpha=1)</td></tr>
<tr class="separator:ad1d12c21618fa40c9195f01ac20ae203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef70489b68fd02e29dc2210aeaa4311"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , std::enable_if_t&lt; covariance&lt; A &gt; and typed_matrix&lt; B &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3ef70489b68fd02e29dc2210aeaa4311"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3ef70489b68fd02e29dc2210aeaa4311">solve</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept</td></tr>
<tr class="memdesc:a3ef70489b68fd02e29dc2210aeaa4311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a x = b for x (A is a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>, B is a vector type).  <a href="namespace_open_kalman.html#a3ef70489b68fd02e29dc2210aeaa4311">More...</a><br /></td></tr>
<tr class="separator:a3ef70489b68fd02e29dc2210aeaa4311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596d0d8ec72e25fb9c5efb90d65ad126"><td class="memTemplParams" colspan="2"><a id="a596d0d8ec72e25fb9c5efb90d65ad126"></a>
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a596d0d8ec72e25fb9c5efb90d65ad126"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce_columns</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a596d0d8ec72e25fb9c5efb90d65ad126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8ce92ebb39445ad24273396c57ff0b"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0c8ce92ebb39445ad24273396c57ff0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0c8ce92ebb39445ad24273396c57ff0b">LQ_decomposition</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a0c8ce92ebb39445ad24273396c57ff0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c53f3473e7552a36723afca9d5588ad"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2c53f3473e7552a36723afca9d5588ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2c53f3473e7552a36723afca9d5588ad">QR_decomposition</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a2c53f3473e7552a36723afca9d5588ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="memTemplParams" colspan="2"><a id="a82c47a34ff6b7584fb93a6ede9db6a12"></a>
template&lt;typename M , typename ... Ms, std::enable_if_t&lt;(covariance&lt; M &gt; and ... and covariance&lt; Ms &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a82c47a34ff6b7584fb93a6ede9db6a12">concatenate</a> (M &amp;&amp;m, Ms &amp;&amp;... mN) noexcept</td></tr>
<tr class="memdesc:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> objects diagonally. <br /></td></tr>
<tr class="separator:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf46841af75eee02bfd52c1708831b7"><td class="memTemplParams" colspan="2">template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2bf46841af75eee02bfd52c1708831b7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2bf46841af75eee02bfd52c1708831b7">split_diagonal</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a2bf46841af75eee02bfd52c1708831b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> diagonally.  <a href="namespace_open_kalman.html#a2bf46841af75eee02bfd52c1708831b7">More...</a><br /></td></tr>
<tr class="separator:a2bf46841af75eee02bfd52c1708831b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dba71f80c4270929d21e416f1c8739"><td class="memTemplParams" colspan="2">template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a68dba71f80c4270929d21e416f1c8739"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a68dba71f80c4270929d21e416f1c8739">split_vertical</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a68dba71f80c4270929d21e416f1c8739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> vertically. Result is a tuple of typed matrices.  <a href="namespace_open_kalman.html#a68dba71f80c4270929d21e416f1c8739">More...</a><br /></td></tr>
<tr class="separator:a68dba71f80c4270929d21e416f1c8739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313e2b8a742da23f4623c6bc4c295d5b"><td class="memTemplParams" colspan="2">template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a313e2b8a742da23f4623c6bc4c295d5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a313e2b8a742da23f4623c6bc4c295d5b">split_horizontal</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a313e2b8a742da23f4623c6bc4c295d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> vertically. Result is a tuple of typed matrices.  <a href="namespace_open_kalman.html#a313e2b8a742da23f4623c6bc4c295d5b">More...</a><br /></td></tr>
<tr class="separator:a313e2b8a742da23f4623c6bc4c295d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9f83dc120f7424fe949f401344960e"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt; and element_gettable&lt; nested_matrix_t&lt; Arg &gt;, 2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aab9f83dc120f7424fe949f401344960e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aab9f83dc120f7424fe949f401344960e">get_element</a> (Arg &amp;&amp;arg, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:aab9f83dc120f7424fe949f401344960e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i, j) of a covariance matrix.  <a href="namespace_open_kalman.html#aab9f83dc120f7424fe949f401344960e">More...</a><br /></td></tr>
<tr class="separator:aab9f83dc120f7424fe949f401344960e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed81d91202d9b998733a3be06de9910"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt; and((self_adjoint_matrix&lt; nested_matrix_t&lt; Arg &gt;&gt; and not square_root_covariance&lt; Arg &gt;) or(triangular_matrix&lt; nested_matrix_t&lt; Arg &gt;&gt; and square_root_covariance&lt; Arg &gt;)) and element_gettable&lt; nested_matrix_t&lt; Arg &gt;, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7ed81d91202d9b998733a3be06de9910"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a7ed81d91202d9b998733a3be06de9910">get_element</a> (Arg &amp;&amp;arg, const std::size_t i)</td></tr>
<tr class="memdesc:a7ed81d91202d9b998733a3be06de9910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i) of a covariance matrix.  <a href="namespace_open_kalman.html#a7ed81d91202d9b998733a3be06de9910">More...</a><br /></td></tr>
<tr class="separator:a7ed81d91202d9b998733a3be06de9910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d576e04f45d8081c586f69f8b7f96f"><td class="memTemplParams" colspan="2"><a id="ab5d576e04f45d8081c586f69f8b7f96f"></a>
template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; covariance&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and element_settable&lt; nested_matrix_t&lt; Arg &gt;, 2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab5d576e04f45d8081c586f69f8b7f96f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab5d576e04f45d8081c586f69f8b7f96f">set_element</a> (Arg &amp;arg, const Scalar s, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:ab5d576e04f45d8081c586f69f8b7f96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i, j) of a covariance matrix. <br /></td></tr>
<tr class="separator:ab5d576e04f45d8081c586f69f8b7f96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a86339bc79fa01578464985b73e03a5"><td class="memTemplParams" colspan="2"><a id="a1a86339bc79fa01578464985b73e03a5"></a>
template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; covariance&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and((self_adjoint_matrix&lt; nested_matrix_t&lt; Arg &gt;&gt; and not square_root_covariance&lt; Arg &gt;) or(triangular_matrix&lt; nested_matrix_t&lt; Arg &gt;&gt; and square_root_covariance&lt; Arg &gt;)) and element_settable&lt; nested_matrix_t&lt; Arg &gt;, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1a86339bc79fa01578464985b73e03a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1a86339bc79fa01578464985b73e03a5">set_element</a> (Arg &amp;arg, const Scalar s, const std::size_t i)</td></tr>
<tr class="memdesc:a1a86339bc79fa01578464985b73e03a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i) of a covariance matrix. <br /></td></tr>
<tr class="separator:a1a86339bc79fa01578464985b73e03a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cf22b04919ddaac53d9296aa77be2d"><td class="memTemplParams" colspan="2"><a id="a38cf22b04919ddaac53d9296aa77be2d"></a>
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a38cf22b04919ddaac53d9296aa77be2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a38cf22b04919ddaac53d9296aa77be2d">column</a> (Arg &amp;&amp;arg, const std::size_t index)</td></tr>
<tr class="memdesc:a38cf22b04919ddaac53d9296aa77be2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column <code>index</code> of Arg. <br /></td></tr>
<tr class="separator:a38cf22b04919ddaac53d9296aa77be2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="memTemplParams" colspan="2"><a id="a6e7e42a6fae7659f1f67c68979ba9a95"></a>
template&lt;std::size_t index, typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6e7e42a6fae7659f1f67c68979ba9a95">column</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column <code>index</code> of Arg. Constexpr index version. <br /></td></tr>
<tr class="separator:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f7c6166aa7f40f7170a79bc1a116eb"><td class="memTemplParams" colspan="2"><a id="a11f7c6166aa7f40f7170a79bc1a116eb"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; covariance&lt; Arg &gt; and typed_matrix&lt; std::invoke_result_t&lt; Function, std::decay_t&lt; decltype(column&lt; 0 &gt;(std::declval&lt; Arg &gt;()))&gt;&gt; , int &gt; </td></tr>
<tr class="memitem:a11f7c6166aa7f40f7170a79bc1a116eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_columnwise</b> (Arg &amp;&amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:a11f7c6166aa7f40f7170a79bc1a116eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2416ba939328801e4b2bf65f3baa855"><td class="memTemplParams" colspan="2"><a id="ad2416ba939328801e4b2bf65f3baa855"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; covariance&lt; Arg &gt; and std::is_convertible_v&lt; std::invoke_result_t&lt; Function, typename MatrixTraits&lt; Arg &gt;::Scalar &gt;, const typename MatrixTraits&lt; Arg &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad2416ba939328801e4b2bf65f3baa855"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_coefficientwise</b> (Arg &amp;&amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:ad2416ba939328801e4b2bf65f3baa855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfb08272538904db9518f9b60e563a6"><td class="memTemplParams" colspan="2"><a id="a0bfb08272538904db9518f9b60e563a6"></a>
template&lt;typename Cov , std::enable_if_t&lt; covariance&lt; Cov &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0bfb08272538904db9518f9b60e563a6"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const Cov &amp;c)</td></tr>
<tr class="separator:a0bfb08272538904db9518f9b60e563a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039f354d5cd736da949ab03453e8e7ec"><td class="memTemplParams" colspan="2"><a id="a039f354d5cd736da949ab03453e8e7ec"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; typed_matrix&lt; V1 &gt; and typed_matrix&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a039f354d5cd736da949ab03453e8e7ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a039f354d5cd736da949ab03453e8e7ec">operator+</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a039f354d5cd736da949ab03453e8e7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two typed matrices. If the operands are of different types, the result will be a regular typed matrix. <br /></td></tr>
<tr class="separator:a039f354d5cd736da949ab03453e8e7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e926152518ac5b9857395881d6495f7"><td class="memTemplParams" colspan="2"><a id="a2e926152518ac5b9857395881d6495f7"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; typed_matrix&lt; V1 &gt; and typed_matrix&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2e926152518ac5b9857395881d6495f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2e926152518ac5b9857395881d6495f7">operator-</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a2e926152518ac5b9857395881d6495f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two typed matrices. The result is a regular typed matrix unless both operands are <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>. <br /></td></tr>
<tr class="separator:a2e926152518ac5b9857395881d6495f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aeb063fca8bd5a6714e9a46749e706"><td class="memTemplParams" colspan="2"><a id="a20aeb063fca8bd5a6714e9a46749e706"></a>
template&lt;typename V , typename S , std::enable_if_t&lt; typed_matrix&lt; V &gt; and std::is_convertible_v&lt; S, const typename MatrixTraits&lt; V &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a20aeb063fca8bd5a6714e9a46749e706"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a20aeb063fca8bd5a6714e9a46749e706">operator*</a> (V &amp;&amp;v, S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>)</td></tr>
<tr class="memdesc:a20aeb063fca8bd5a6714e9a46749e706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a typed matrix by a scalar. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:a20aeb063fca8bd5a6714e9a46749e706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3928da684e7a5ef385a77828f3c3cc14"><td class="memTemplParams" colspan="2"><a id="a3928da684e7a5ef385a77828f3c3cc14"></a>
template&lt;typename V , typename S , std::enable_if_t&lt; typed_matrix&lt; V &gt; and std::is_convertible_v&lt; S, const typename MatrixTraits&lt; V &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3928da684e7a5ef385a77828f3c3cc14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3928da684e7a5ef385a77828f3c3cc14">operator*</a> (S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>, V &amp;&amp;v)</td></tr>
<tr class="memdesc:a3928da684e7a5ef385a77828f3c3cc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a scalar by a typed matrix. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:a3928da684e7a5ef385a77828f3c3cc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b0a24352923b27433819ba40b6394c"><td class="memTemplParams" colspan="2"><a id="a82b0a24352923b27433819ba40b6394c"></a>
template&lt;typename V , typename S , std::enable_if_t&lt; typed_matrix&lt; V &gt; and std::is_convertible_v&lt; S, const typename MatrixTraits&lt; V &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a82b0a24352923b27433819ba40b6394c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a82b0a24352923b27433819ba40b6394c">operator/</a> (V &amp;&amp;v, S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>)</td></tr>
<tr class="memdesc:a82b0a24352923b27433819ba40b6394c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a typed matrix by a scalar. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:a82b0a24352923b27433819ba40b6394c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51481c7e308adfcf8f33c4891f35618"><td class="memTemplParams" colspan="2"><a id="ae51481c7e308adfcf8f33c4891f35618"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; typed_matrix&lt; V1 &gt; and typed_matrix&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae51481c7e308adfcf8f33c4891f35618"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae51481c7e308adfcf8f33c4891f35618">operator*</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:ae51481c7e308adfcf8f33c4891f35618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a typed matrix by another typed matrix. The result is a regular typed matrix unless the first operand is <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>. <br /></td></tr>
<tr class="separator:ae51481c7e308adfcf8f33c4891f35618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eaac6005b36334fa28a5c223cbe545"><td class="memTemplParams" colspan="2"><a id="a08eaac6005b36334fa28a5c223cbe545"></a>
template&lt;typename V , std::enable_if_t&lt; typed_matrix&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a08eaac6005b36334fa28a5c223cbe545"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a08eaac6005b36334fa28a5c223cbe545">operator-</a> (V &amp;&amp;v)</td></tr>
<tr class="memdesc:a08eaac6005b36334fa28a5c223cbe545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate a vector object. The result is a regular typed matrix unless the operand is <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>. <br /></td></tr>
<tr class="separator:a08eaac6005b36334fa28a5c223cbe545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba759789716e968b7d516cfc2c2efe8"><td class="memTemplParams" colspan="2"><a id="a5ba759789716e968b7d516cfc2c2efe8"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; typed_matrix&lt; V1 &gt; and typed_matrix&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5ba759789716e968b7d516cfc2c2efe8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5ba759789716e968b7d516cfc2c2efe8">operator==</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a5ba759789716e968b7d516cfc2c2efe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a5ba759789716e968b7d516cfc2c2efe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="memTemplParams" colspan="2"><a id="ac245a6153e8c8dee4c412d9a86e70b9b"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; typed_matrix&lt; V1 &gt; and typed_matrix&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac245a6153e8c8dee4c412d9a86e70b9b">operator!=</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772f77767f5b588e1461421b80926b30"><td class="memTemplParams" colspan="2"><a id="a772f77767f5b588e1461421b80926b30"></a>
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a772f77767f5b588e1461421b80926b30"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nested_matrix</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a772f77767f5b588e1461421b80926b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94023ee812f40709ac61cdd392d105f3"><td class="memTemplParams" colspan="2"><a id="a94023ee812f40709ac61cdd392d105f3"></a>
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and column_vector&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a94023ee812f40709ac61cdd392d105f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_Euclidean</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a94023ee812f40709ac61cdd392d105f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b41be5ac82018f99a2e06e2ea391e6"><td class="memTemplParams" colspan="2"><a id="ab8b41be5ac82018f99a2e06e2ea391e6"></a>
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and column_vector&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab8b41be5ac82018f99a2e06e2ea391e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_Euclidean</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:ab8b41be5ac82018f99a2e06e2ea391e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b6735e2c5cb8088a905ad6641c87c5"><td class="memTemplParams" colspan="2"><a id="a63b6735e2c5cb8088a905ad6641c87c5"></a>
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and(not euclidean_transformed&lt; Arg &gt;) and equivalent_to&lt; typename MatrixTraits&lt; Arg &gt;::ColumnCoefficients, Axis &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a63b6735e2c5cb8088a905ad6641c87c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_diagonal</b> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a63b6735e2c5cb8088a905ad6641c87c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64ea73d28077cecfc217139a9d77813"><td class="memTemplParams" colspan="2"><a id="af64ea73d28077cecfc217139a9d77813"></a>
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and((MatrixTraits&lt; Arg &gt;::columns==1) or column_vector&lt; Arg &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af64ea73d28077cecfc217139a9d77813"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af64ea73d28077cecfc217139a9d77813">reduce_columns</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:af64ea73d28077cecfc217139a9d77813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean of the column vectors after they are transformed into Euclidean space. <br /></td></tr>
<tr class="separator:af64ea73d28077cecfc217139a9d77813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6f25c9190e4658793bb610b179bbc9"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; typed_matrix&lt; A &gt; and(not euclidean_transformed&lt; A &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0e6f25c9190e4658793bb610b179bbc9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0e6f25c9190e4658793bb610b179bbc9">LQ_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:a0e6f25c9190e4658793bb610b179bbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c9b539547601ae4b033c3ffe425b5b"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; typed_matrix&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae8c9b539547601ae4b033c3ffe425b5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae8c9b539547601ae4b033c3ffe425b5b">QR_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:ae8c9b539547601ae4b033c3ffe425b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07f38b9b803ce7be54501d6899eebb1"><td class="memTemplParams" colspan="2"><a id="ac07f38b9b803ce7be54501d6899eebb1"></a>
template&lt;typename V , typename ... Vs, std::enable_if_t&lt;(typed_matrix&lt; V &gt; and ... and typed_matrix&lt; Vs &gt;) and((sizeof...(Vs)==0) or(equivalent_to&lt; typename MatrixTraits&lt; V &gt;::ColumnCoefficients, typename MatrixTraits&lt; Vs &gt;::ColumnCoefficients &gt; and ...)), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac07f38b9b803ce7be54501d6899eebb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac07f38b9b803ce7be54501d6899eebb1">concatenate_vertical</a> (V &amp;&amp;v, Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:ac07f38b9b803ce7be54501d6899eebb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more typed matrices objects vertically. <br /></td></tr>
<tr class="separator:ac07f38b9b803ce7be54501d6899eebb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16f5d48f74dec8a73700b18a26e94b3"><td class="memTemplParams" colspan="2"><a id="ae16f5d48f74dec8a73700b18a26e94b3"></a>
template&lt;typename ... Vs, std::enable_if_t&lt;(typed_matrix&lt; Vs &gt; and ...), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae16f5d48f74dec8a73700b18a26e94b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae16f5d48f74dec8a73700b18a26e94b3">concatenate</a> (Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:ae16f5d48f74dec8a73700b18a26e94b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more typed matrices vertically. (Synonym for concatenate_vertical.) <br /></td></tr>
<tr class="separator:ae16f5d48f74dec8a73700b18a26e94b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c5157500f9c2c2018697ce9fd276d5"><td class="memTemplParams" colspan="2"><a id="ac3c5157500f9c2c2018697ce9fd276d5"></a>
template&lt;typename V , typename ... Vs, std::enable_if_t&lt;(typed_matrix&lt; V &gt; and ... and typed_matrix&lt; Vs &gt;) and((sizeof...(Vs)==0) or(equivalent_to&lt; typename MatrixTraits&lt; V &gt;::RowCoefficients, typename MatrixTraits&lt; Vs &gt;::RowCoefficients &gt; and ...)), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac3c5157500f9c2c2018697ce9fd276d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac3c5157500f9c2c2018697ce9fd276d5">concatenate_horizontal</a> (V &amp;&amp;v, Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:ac3c5157500f9c2c2018697ce9fd276d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more matrix objects vertically. <br /></td></tr>
<tr class="separator:ac3c5157500f9c2c2018697ce9fd276d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba340bb29158708cf93b6e103fbcd6e"><td class="memTemplParams" colspan="2"><a id="acba340bb29158708cf93b6e103fbcd6e"></a>
template&lt;typename V , typename ... Vs, std::enable_if_t&lt;(typed_matrix&lt; V &gt; and ... and typed_matrix&lt; Vs &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acba340bb29158708cf93b6e103fbcd6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#acba340bb29158708cf93b6e103fbcd6e">concatenate_diagonal</a> (V &amp;&amp;v, Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:acba340bb29158708cf93b6e103fbcd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more typed matrices diagonally. <br /></td></tr>
<tr class="separator:acba340bb29158708cf93b6e103fbcd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac00857e744721c29956a56550892a08"><td class="memTemplParams" colspan="2"><a id="aac00857e744721c29956a56550892a08"></a>
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and element_settable&lt; nested_matrix_t&lt; Arg &gt;, 2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aac00857e744721c29956a56550892a08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aac00857e744721c29956a56550892a08">set_element</a> (Arg &amp;arg, const typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; Arg &gt;::Scalar s, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:aac00857e744721c29956a56550892a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i, j) of a typed matrix. <br /></td></tr>
<tr class="separator:aac00857e744721c29956a56550892a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd804a52e5750b0be9c60a34a1c3323"><td class="memTemplParams" colspan="2"><a id="a4fd804a52e5750b0be9c60a34a1c3323"></a>
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and element_settable&lt; nested_matrix_t&lt; Arg &gt;, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4fd804a52e5750b0be9c60a34a1c3323"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4fd804a52e5750b0be9c60a34a1c3323">set_element</a> (Arg &amp;arg, const typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; Arg &gt;::Scalar s, const std::size_t i)</td></tr>
<tr class="memdesc:a4fd804a52e5750b0be9c60a34a1c3323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i) of a typed matrix. <br /></td></tr>
<tr class="separator:a4fd804a52e5750b0be9c60a34a1c3323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa5df002cc4298b5debd50b238e2e94"><td class="memTemplParams" colspan="2"><a id="a3fa5df002cc4298b5debd50b238e2e94"></a>
template&lt;std::size_t index, typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3fa5df002cc4298b5debd50b238e2e94"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><b>column</b> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a3fa5df002cc4298b5debd50b238e2e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5815ed4167eb12e5f6c0ba16ea941e8f"><td class="memTemplParams" colspan="2"><a id="a5815ed4167eb12e5f6c0ba16ea941e8f"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and std::is_void_v&lt; std::invoke_result_t&lt; const Function &amp;, std::decay_t&lt; decltype(column(std::declval&lt; Arg &amp; &gt;(), 0))&gt; &amp; &gt;&gt; , int &gt; </td></tr>
<tr class="memitem:a5815ed4167eb12e5f6c0ba16ea941e8f"><td class="memTemplItemLeft" align="right" valign="top">Arg &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_columnwise</b> (Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:a5815ed4167eb12e5f6c0ba16ea941e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac99e230059968583a5d4fa00f635a1a"><td class="memTemplParams" colspan="2"><a id="aac99e230059968583a5d4fa00f635a1a"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and not std::is_void_v&lt; std::invoke_result_t&lt; const Function &amp;, std::decay_t&lt; decltype(column(std::declval&lt; const Arg &amp; &gt;(), 0))&gt; &amp;&amp; &gt;&gt; , int &gt; </td></tr>
<tr class="memitem:aac99e230059968583a5d4fa00f635a1a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_columnwise</b> (const Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:aac99e230059968583a5d4fa00f635a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf692f460af0aba79c4724f055071756"><td class="memTemplParams" colspan="2"><a id="adf692f460af0aba79c4724f055071756"></a>
template&lt;std::size_t count, typename Function , std::enable_if_t&lt; typed_matrix&lt; std::invoke_result_t&lt; const Function &amp; &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adf692f460af0aba79c4724f055071756"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_columnwise</b> (const Function &amp;f)</td></tr>
<tr class="separator:adf692f460af0aba79c4724f055071756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc74b68192a9f74d29cd4b224c9ecc6"><td class="memTemplParams" colspan="2"><a id="a4cc74b68192a9f74d29cd4b224c9ecc6"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and std::is_void_v&lt; std::invoke_result_t&lt; const Function &amp;, std::decay_t&lt; typename MatrixTraits&lt; Arg &gt;::Scalar &gt; &amp; &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4cc74b68192a9f74d29cd4b224c9ecc6"><td class="memTemplItemLeft" align="right" valign="top">Arg &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_coefficientwise</b> (Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:a4cc74b68192a9f74d29cd4b224c9ecc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8c307ca3e471cb3f8fc12cc2abbc60"><td class="memTemplParams" colspan="2"><a id="acd8c307ca3e471cb3f8fc12cc2abbc60"></a>
template&lt;typename Arg , typename Function , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and std::is_convertible_v&lt; std::invoke_result_t&lt; const Function &amp;, std::decay_t&lt; typename MatrixTraits&lt; Arg &gt;::Scalar &gt;&gt;, typename MatrixTraits&lt; Arg &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acd8c307ca3e471cb3f8fc12cc2abbc60"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_coefficientwise</b> (const Arg &amp;arg, const Function &amp;f)</td></tr>
<tr class="separator:acd8c307ca3e471cb3f8fc12cc2abbc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f3ece1b90bb739b43c7b94f95df219"><td class="memTemplParams" colspan="2"><a id="a76f3ece1b90bb739b43c7b94f95df219"></a>
template&lt;typename V , typename Function , std::enable_if_t&lt; typed_matrix&lt; V &gt; and std::is_convertible_v&lt; std::invoke_result_t&lt; const Function &amp; &gt;, typename MatrixTraits&lt; V &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a76f3ece1b90bb739b43c7b94f95df219"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_coefficientwise</b> (const Function &amp;f)</td></tr>
<tr class="separator:a76f3ece1b90bb739b43c7b94f95df219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545052d9d62e60171a20c7704d65b1a0"><td class="memTemplParams" colspan="2"><a id="a545052d9d62e60171a20c7704d65b1a0"></a>
template&lt;typename V , std::enable_if_t&lt; typed_matrix&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a545052d9d62e60171a20c7704d65b1a0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a545052d9d62e60171a20c7704d65b1a0">operator&lt;&lt;</a> (std::ostream &amp;os, const V &amp;v)</td></tr>
<tr class="memdesc:a545052d9d62e60171a20c7704d65b1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the vector to a stream. <br /></td></tr>
<tr class="separator:a545052d9d62e60171a20c7704d65b1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59a5b875bd8ebda034f8876dd865a99"><td class="memTemplParams" colspan="2">template&lt;typename V , std::enable_if_t&lt; typed_matrix_nestable&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae59a5b875bd8ebda034f8876dd865a99"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae59a5b875bd8ebda034f8876dd865a99">EuclideanMean</a> (V &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a>&lt; V &gt;&gt;</td></tr>
<tr class="memdesc:ae59a5b875bd8ebda034f8876dd865a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a typed_matrix_nestable, assuming axis-only coefficients.  <a href="namespace_open_kalman.html#ae59a5b875bd8ebda034f8876dd865a99">More...</a><br /></td></tr>
<tr class="separator:ae59a5b875bd8ebda034f8876dd865a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48c0170c781745c5abc1e13f83777d3"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::dimension==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa48c0170c781745c5abc1e13f83777d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aa48c0170c781745c5abc1e13f83777d3">make_euclidean_mean</a> (M &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:aa48c0170c781745c5abc1e13f83777d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> from a typed_matrix_nestable, specifying the row coefficients.  <a href="namespace_open_kalman.html#aa48c0170c781745c5abc1e13f83777d3">More...</a><br /></td></tr>
<tr class="separator:aa48c0170c781745c5abc1e13f83777d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6687a8e5791a070fb3bb625687f4b7"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3d6687a8e5791a070fb3bb625687f4b7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3d6687a8e5791a070fb3bb625687f4b7">make_euclidean_mean</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a3d6687a8e5791a070fb3bb625687f4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> from a typed_matrix_nestable object, with default Axis coefficients.  <a href="namespace_open_kalman.html#a3d6687a8e5791a070fb3bb625687f4b7">More...</a><br /></td></tr>
<tr class="separator:a3d6687a8e5791a070fb3bb625687f4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51161ea0e106d97f06ca53662029bf7a"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and column_vector&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a51161ea0e106d97f06ca53662029bf7a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a51161ea0e106d97f06ca53662029bf7a">make_euclidean_mean</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a51161ea0e106d97f06ca53662029bf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> from another typed_matrix.  <a href="namespace_open_kalman.html#a51161ea0e106d97f06ca53662029bf7a">More...</a><br /></td></tr>
<tr class="separator:a51161ea0e106d97f06ca53662029bf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae62cc2a04ec13fe3c3a71f9326b4637"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::dimension==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aae62cc2a04ec13fe3c3a71f9326b4637"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aae62cc2a04ec13fe3c3a71f9326b4637">make_euclidean_mean</a> ()</td></tr>
<tr class="memdesc:aae62cc2a04ec13fe3c3a71f9326b4637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, self-contained <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>.  <a href="namespace_open_kalman.html#aae62cc2a04ec13fe3c3a71f9326b4637">More...</a><br /></td></tr>
<tr class="separator:aae62cc2a04ec13fe3c3a71f9326b4637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc328414ecb720005c3c813be752ec3"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3dc328414ecb720005c3c813be752ec3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3dc328414ecb720005c3c813be752ec3">make_euclidean_mean</a> ()</td></tr>
<tr class="memdesc:a3dc328414ecb720005c3c813be752ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a self-contained <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> with default Axis coefficients.  <a href="namespace_open_kalman.html#a3dc328414ecb720005c3c813be752ec3">More...</a><br /></td></tr>
<tr class="separator:a3dc328414ecb720005c3c813be752ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67371d0db0c89c7d13983f48b94d66ea"><td class="memTemplParams" colspan="2"><a id="a67371d0db0c89c7d13983f48b94d66ea"></a>
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a67371d0db0c89c7d13983f48b94d66ea"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a67371d0db0c89c7d13983f48b94d66ea">Matrix</a> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_matrix.html">Matrix</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::columns &gt;, <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a>&lt; M &gt;&gt;</td></tr>
<tr class="memdesc:a67371d0db0c89c7d13983f48b94d66ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce parameter types from a typed_matrix_nestable. <br /></td></tr>
<tr class="separator:a67371d0db0c89c7d13983f48b94d66ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff013f3acace99fb1191fd677bdaba67"><td class="memTemplParams" colspan="2">template&lt;typename V , std::enable_if_t&lt; typed_matrix&lt; V &gt; and not euclidean_transformed&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aff013f3acace99fb1191fd677bdaba67"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aff013f3acace99fb1191fd677bdaba67">Matrix</a> (V &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_matrix.html">Matrix</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::RowCoefficients, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::ColumnCoefficients, <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a>&lt; <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a>&lt; V &gt;&gt;&gt;</td></tr>
<tr class="memdesc:aff013f3acace99fb1191fd677bdaba67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a non-Euclidean-transformed typed matrix.  <a href="namespace_open_kalman.html#aff013f3acace99fb1191fd677bdaba67">More...</a><br /></td></tr>
<tr class="separator:aff013f3acace99fb1191fd677bdaba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e36fbdb948bce537bd17d75114f712"><td class="memTemplParams" colspan="2">template&lt;typename RowCoefficients , typename ColumnCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and coefficients&lt; ColumnCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size) and(MatrixTraits&lt; M &gt;::columns==ColumnCoefficients::size), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a73e36fbdb948bce537bd17d75114f712"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a73e36fbdb948bce537bd17d75114f712">make_matrix</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:a73e36fbdb948bce537bd17d75114f712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from a typed_matrix_nestable, specifying the row and column coefficients.  <a href="namespace_open_kalman.html#a73e36fbdb948bce537bd17d75114f712">More...</a><br /></td></tr>
<tr class="separator:a73e36fbdb948bce537bd17d75114f712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71be5796e548bfdb501444c727d9f372"><td class="memTemplParams" colspan="2">template&lt;typename RowCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a71be5796e548bfdb501444c727d9f372"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a71be5796e548bfdb501444c727d9f372">make_matrix</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:a71be5796e548bfdb501444c727d9f372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from a typed_matrix_nestable, specifying only the row coefficients.  <a href="namespace_open_kalman.html#a71be5796e548bfdb501444c727d9f372">More...</a><br /></td></tr>
<tr class="separator:a71be5796e548bfdb501444c727d9f372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82be03cc51cb7a0b7b8c2eb14c6c0bb"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af82be03cc51cb7a0b7b8c2eb14c6c0bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af82be03cc51cb7a0b7b8c2eb14c6c0bb">make_matrix</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:af82be03cc51cb7a0b7b8c2eb14c6c0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from a typed_matrix_nestable object, with default Axis coefficients.  <a href="namespace_open_kalman.html#af82be03cc51cb7a0b7b8c2eb14c6c0bb">More...</a><br /></td></tr>
<tr class="separator:af82be03cc51cb7a0b7b8c2eb14c6c0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb3bd9bc6f894eb4b03b48b8a0d850c"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afdb3bd9bc6f894eb4b03b48b8a0d850c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#afdb3bd9bc6f894eb4b03b48b8a0d850c">make_matrix</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:afdb3bd9bc6f894eb4b03b48b8a0d850c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from another typed_matrix.  <a href="namespace_open_kalman.html#afdb3bd9bc6f894eb4b03b48b8a0d850c">More...</a><br /></td></tr>
<tr class="separator:afdb3bd9bc6f894eb4b03b48b8a0d850c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5647c719085536c8fa6851836c5d03ea"><td class="memTemplParams" colspan="2">template&lt;typename RowCoefficients , typename ColumnCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and coefficients&lt; ColumnCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size) and(MatrixTraits&lt; M &gt;::columns==ColumnCoefficients::size), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5647c719085536c8fa6851836c5d03ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5647c719085536c8fa6851836c5d03ea">make_matrix</a> ()</td></tr>
<tr class="memdesc:a5647c719085536c8fa6851836c5d03ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, self-contained <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object.  <a href="namespace_open_kalman.html#a5647c719085536c8fa6851836c5d03ea">More...</a><br /></td></tr>
<tr class="separator:a5647c719085536c8fa6851836c5d03ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa3556236800e6eecb365ea76199ae5"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:affa3556236800e6eecb365ea76199ae5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#affa3556236800e6eecb365ea76199ae5">make_matrix</a> ()</td></tr>
<tr class="memdesc:affa3556236800e6eecb365ea76199ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a self-contained <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object with default Axis coefficients.  <a href="namespace_open_kalman.html#affa3556236800e6eecb365ea76199ae5">More...</a><br /></td></tr>
<tr class="separator:affa3556236800e6eecb365ea76199ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4811b89985f03ba5fe3b5c6a54b9e49b"><td class="memTemplParams" colspan="2">template&lt;typename V , std::enable_if_t&lt; typed_matrix_nestable&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4811b89985f03ba5fe3b5c6a54b9e49b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4811b89985f03ba5fe3b5c6a54b9e49b">Mean</a> (V &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a>&lt; V &gt;&gt;</td></tr>
<tr class="memdesc:a4811b89985f03ba5fe3b5c6a54b9e49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a typed_matrix_nestable, assuming axis-only coefficients.  <a href="namespace_open_kalman.html#a4811b89985f03ba5fe3b5c6a54b9e49b">More...</a><br /></td></tr>
<tr class="separator:a4811b89985f03ba5fe3b5c6a54b9e49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74553d9027b3d93c5020f13c0570a8b"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::size==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad74553d9027b3d93c5020f13c0570a8b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad74553d9027b3d93c5020f13c0570a8b">make_mean</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:ad74553d9027b3d93c5020f13c0570a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> from a typed_matrix_nestable, specifying the row coefficients.  <a href="namespace_open_kalman.html#ad74553d9027b3d93c5020f13c0570a8b">More...</a><br /></td></tr>
<tr class="separator:ad74553d9027b3d93c5020f13c0570a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cb56942738ea287feeb456de8a1ee8"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab6cb56942738ea287feeb456de8a1ee8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab6cb56942738ea287feeb456de8a1ee8">make_mean</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:ab6cb56942738ea287feeb456de8a1ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> from a typed_matrix_nestable object, with default Axis coefficients.  <a href="namespace_open_kalman.html#ab6cb56942738ea287feeb456de8a1ee8">More...</a><br /></td></tr>
<tr class="separator:ab6cb56942738ea287feeb456de8a1ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342c91bcf1ffd94505e1c4336f95d43e"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and column_vector&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a342c91bcf1ffd94505e1c4336f95d43e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a342c91bcf1ffd94505e1c4336f95d43e">make_mean</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a342c91bcf1ffd94505e1c4336f95d43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> from another typed_matrix.  <a href="namespace_open_kalman.html#a342c91bcf1ffd94505e1c4336f95d43e">More...</a><br /></td></tr>
<tr class="separator:a342c91bcf1ffd94505e1c4336f95d43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258fd14762cd857444878183fc128c73"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==Coefficients::size), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a258fd14762cd857444878183fc128c73"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a258fd14762cd857444878183fc128c73">make_mean</a> ()</td></tr>
<tr class="memdesc:a258fd14762cd857444878183fc128c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, self-contained <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>.  <a href="namespace_open_kalman.html#a258fd14762cd857444878183fc128c73">More...</a><br /></td></tr>
<tr class="separator:a258fd14762cd857444878183fc128c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abae6f929b546e22c34d58a1595303f"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6abae6f929b546e22c34d58a1595303f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6abae6f929b546e22c34d58a1595303f">make_mean</a> ()</td></tr>
<tr class="memdesc:a6abae6f929b546e22c34d58a1595303f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a self-contained <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> with default Axis coefficients.  <a href="namespace_open_kalman.html#a6abae6f929b546e22c34d58a1595303f">More...</a><br /></td></tr>
<tr class="separator:a6abae6f929b546e22c34d58a1595303f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6dae028e91c6d55ec089d52c6b01d7"><td class="memTemplParams" colspan="2"><a id="aba6dae028e91c6d55ec089d52c6b01d7"></a>
template&lt;typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aba6dae028e91c6d55ec089d52c6b01d7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SquareRootCovariance</b> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html">SquareRootCovariance</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::RowCoefficients, <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a>&lt; M &gt;&gt;</td></tr>
<tr class="separator:aba6dae028e91c6d55ec089d52c6b01d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3983a57927dc746dcc5a6c877337a686"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and covariance_nestable&lt; Arg &gt; and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3983a57927dc746dcc5a6c877337a686"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3983a57927dc746dcc5a6c877337a686">make_square_root_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a3983a57927dc746dcc5a6c877337a686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a covariance_nestable, specifying the coefficients.  <a href="namespace_open_kalman.html#a3983a57927dc746dcc5a6c877337a686">More...</a><br /></td></tr>
<tr class="separator:a3983a57927dc746dcc5a6c877337a686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9adb3eae588123a5f80eafea891a0c5"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance_nestable&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae9adb3eae588123a5f80eafea891a0c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae9adb3eae588123a5f80eafea891a0c5">make_square_root_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:ae9adb3eae588123a5f80eafea891a0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a covariance_nestable, with default Axis coefficients.  <a href="namespace_open_kalman.html#ae9adb3eae588123a5f80eafea891a0c5">More...</a><br /></td></tr>
<tr class="separator:ae9adb3eae588123a5f80eafea891a0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc58f602f72886f980090ec403f86f2e"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , TriangleType triangle_type = TriangleType::lower, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and(not covariance_nestable&lt; Arg &gt;) and(triangle_type==TriangleType::lower or triangle_type==TriangleType::upper) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adc58f602f72886f980090ec403f86f2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#adc58f602f72886f980090ec403f86f2e">make_square_root_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:adc58f602f72886f980090ec403f86f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> (with nested triangular matrix) from a self-adjoint typed_matrix_nestable.  <a href="namespace_open_kalman.html#adc58f602f72886f980090ec403f86f2e">More...</a><br /></td></tr>
<tr class="separator:adc58f602f72886f980090ec403f86f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22473ed4dd2db3f2eaa82a5dbd7e799d"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a22473ed4dd2db3f2eaa82a5dbd7e799d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a22473ed4dd2db3f2eaa82a5dbd7e799d">make_square_root_covariance</a> ()</td></tr>
<tr class="memdesc:a22473ed4dd2db3f2eaa82a5dbd7e799d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a typed_matrix_nestable.  <a href="namespace_open_kalman.html#a22473ed4dd2db3f2eaa82a5dbd7e799d">More...</a><br /></td></tr>
<tr class="separator:a22473ed4dd2db3f2eaa82a5dbd7e799d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00898738e33dfb03d94f4289d6855633"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a00898738e33dfb03d94f4289d6855633"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a00898738e33dfb03d94f4289d6855633">make_square_root_covariance</a> ()</td></tr>
<tr class="memdesc:a00898738e33dfb03d94f4289d6855633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a covariance_nestable or typed_matrix_nestable.  <a href="namespace_open_kalman.html#a00898738e33dfb03d94f4289d6855633">More...</a><br /></td></tr>
<tr class="separator:a00898738e33dfb03d94f4289d6855633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2f1e0973fe26e185ec3d80837fcd67"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1e2f1e0973fe26e185ec3d80837fcd67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1e2f1e0973fe26e185ec3d80837fcd67">make_square_root_covariance</a> ()</td></tr>
<tr class="memdesc:a1e2f1e0973fe26e185ec3d80837fcd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a typed_matrix_nestable or covariance_nestable.  <a href="namespace_open_kalman.html#a1e2f1e0973fe26e185ec3d80837fcd67">More...</a><br /></td></tr>
<tr class="separator:a1e2f1e0973fe26e185ec3d80837fcd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memTemplParams" colspan="2"><a id="a82c83df8efb22e49dd3e6f5ea119caef"></a>
template&lt;typename OutputCoefficients , typename In , typename ... Perturbations&gt; </td></tr>
<tr class="memitem:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a82c83df8efb22e49dd3e6f5ea119caef">zero_hessian</a> ()</td></tr>
<tr class="memdesc:a82c83df8efb22e49dd3e6f5ea119caef"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple of zero-filled arrays of Hessian matrices, based on the input and each perturbation term. <br /></td></tr>
<tr class="separator:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memTemplParams" colspan="2"><a id="ac32f98e2f9ea9d21f58ac57b49ee011e"></a>
template&lt;typename OutputCoefficients , typename In , typename ... Perturbations&gt; </td></tr>
<tr class="memitem:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac32f98e2f9ea9d21f58ac57b49ee011e">zero_hessian</a> (In &amp;&amp;, Perturbations &amp;&amp;...)</td></tr>
<tr class="memdesc:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple of zero-filled arrays of Hessian matrices, based on the input and each perturbation term. <br /></td></tr>
<tr class="separator:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9934a0fa27adfaf949d994695a13b6af"><td class="memTemplParams" colspan="2">template&lt;typename Trans , typename InDelta , typename ... PsDelta&gt; </td></tr>
<tr class="memitem:a9934a0fa27adfaf949d994695a13b6af"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a9934a0fa27adfaf949d994695a13b6af">FiniteDifferenceLinearization</a> (Trans &amp;&amp;, InDelta &amp;&amp;, PsDelta &amp;&amp;...) -&gt; FiniteDifferenceLinearization&lt; Trans, InDelta, PsDelta... &gt;</td></tr>
<tr class="separator:a9934a0fa27adfaf949d994695a13b6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a56bc6a5e94670e5b5dd21d7039667"><td class="memTemplParams" colspan="2"><a id="ad3a56bc6a5e94670e5b5dd21d7039667"></a>
template&lt;typename T , typename ... Ps, std::enable_if_t&lt;(typed_matrix_nestable&lt; T &gt; and ... and typed_matrix_nestable&lt; Ps &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad3a56bc6a5e94670e5b5dd21d7039667"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LinearTransformation</b> (T &amp;&amp;, Ps &amp;&amp;...) -&gt; <a class="el" href="struct_open_kalman_1_1_linear_transformation.html">LinearTransformation</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; T &gt;::columns &gt;, <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; T &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#a1d08cc520e029d965770641656727893">self_contained_t</a>&lt; std::decay_t&lt; T &gt;&gt;, <a class="el" href="namespace_open_kalman.html#a1d08cc520e029d965770641656727893">self_contained_t</a>&lt; std::decay_t&lt; Ps &gt;&gt;... &gt;</td></tr>
<tr class="separator:ad3a56bc6a5e94670e5b5dd21d7039667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd655dfd0d89b3b12ece39ab953e061"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename... TaylorDerivatives&gt; </td></tr>
<tr class="memitem:abbd655dfd0d89b3b12ece39ab953e061"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#abbd655dfd0d89b3b12ece39ab953e061">Transformation</a> (Function &amp;&amp;, TaylorDerivatives &amp;&amp;...) -&gt; <a class="el" href="struct_open_kalman_1_1_transformation.html">Transformation</a>&lt; Function, TaylorDerivatives... &gt;</td></tr>
<tr class="separator:abbd655dfd0d89b3b12ece39ab953e061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98098102f472923f49b098c25d822621"><td class="memTemplParams" colspan="2"><a id="a98098102f472923f49b098c25d822621"></a>
template&lt;typename Function , std::enable_if_t&lt; is_linearized_function_v&lt; Function, 0 &gt; and not is_linearized_function_v&lt; Function, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a98098102f472923f49b098c25d822621"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Transformation</b> (Function &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_transformation.html">Transformation</a>&lt; Function &gt;</td></tr>
<tr class="separator:a98098102f472923f49b098c25d822621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcaeb1f9fe73f713397b37d3209e817"><td class="memTemplParams" colspan="2"><a id="a6bcaeb1f9fe73f713397b37d3209e817"></a>
template&lt;typename Function , typename... TaylorDerivatives, std::enable_if_t&lt; not is_linearized_function_v&lt; Function, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6bcaeb1f9fe73f713397b37d3209e817"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6bcaeb1f9fe73f713397b37d3209e817">make_Transformation</a> (const Function &amp;f, const TaylorDerivatives &amp;...ds)</td></tr>
<tr class="memdesc:a6bcaeb1f9fe73f713397b37d3209e817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_transformation.html" title="A transformation from one single-column vector to another.">Transformation</a> from a transformation function (and optionally one or more Taylor series derivatives). <br /></td></tr>
<tr class="separator:a6bcaeb1f9fe73f713397b37d3209e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f9155e6a8c211c128af8bdc3f02c14"><td class="memTemplParams" colspan="2">template&lt;typename Function , std::enable_if_t&lt; is_linearized_function_v&lt; Function, 1 &gt; and not is_linearized_function_v&lt; Function, 2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a05f9155e6a8c211c128af8bdc3f02c14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a05f9155e6a8c211c128af8bdc3f02c14">make_Transformation</a> (const Function &amp;f)</td></tr>
<tr class="separator:a05f9155e6a8c211c128af8bdc3f02c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_angle.html">Angle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An angle or any other simple modular value.  <a href="struct_open_kalman_1_1_angle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_coefficients.html">Coefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of coefficient types.  <a href="struct_open_kalman_1_1_coefficients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A self-adjoint <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> matrix.  <a href="struct_open_kalman_1_1_covariance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_distribution_traits.html">DistributionTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait class for any distribution T.  <a href="struct_open_kalman_1_1_distribution_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>, but the coefficients are transformed into Euclidean space, based on their type.  <a href="struct_open_kalman_1_1_euclidean_mean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_gaussian_distribution.html">GaussianDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian distribution, defined in terms of a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> and a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>.  <a href="struct_open_kalman_1_1_gaussian_distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_identity_transform.html">IdentityTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An identity transform from one statistical distribution to another.  <a href="struct_open_kalman_1_1_identity_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_identity_transformation.html">IdentityTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identity transformation from one single-column vector to another. Perturbation terms are treated as additive.  <a href="struct_open_kalman_1_1_identity_transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_inclination.html">Inclination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A positive or negative real number &phi; representing an inclination or declination from the horizon.  <a href="struct_open_kalman_1_1_inclination.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function.html">is_linearized_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a linearized function (with defined Jacobian and optionally Hessian functions).  <a href="struct_open_kalman_1_1is__linearized__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_kalman_filter.html">KalmanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using one or more statistical transforms.  <a href="struct_open_kalman_1_1_kalman_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_kalman_filter_3_01_process_transform_00_01_measurement_transform_01_4.html">KalmanFilter&lt; ProcessTransform, MeasurementTransform &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using a different statistical transform for the process and the measurement.  <a href="struct_open_kalman_1_1_kalman_filter_3_01_process_transform_00_01_measurement_transform_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_kalman_filter_3_01_transform_01_4.html">KalmanFilter&lt; Transform &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using the same transform for the process and the measurement.  <a href="struct_open_kalman_1_1_kalman_filter_3_01_transform_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_linearized_transform.html">LinearizedTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linearized transform, using a 1st or 2nd order Taylor approximation of a linear transformation.  <a href="struct_open_kalman_1_1_linearized_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_linear_transform.html">LinearTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear transformation from one statistical distribution to another.  <a href="struct_open_kalman_1_1_linear_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_linear_transformation.html">LinearTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear transformation from one single-column vector to another.  <a href="struct_open_kalman_1_1_linear_transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix with typed rows and columns.  <a href="struct_open_kalman_1_1_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait class for any matrix T.  <a href="struct_open_kalman_1_1_matrix_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of one or more column vectors, each representing a statistical mean.  <a href="struct_open_kalman_1_1_mean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_mixture_of_continuous_distributions.html">MixtureOfContinuousDistributions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_monte_carlo_transform.html">MonteCarloTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Monte Carlo transform from one Gaussian distribution to another. Uses ideas from Chan, Tony F.; Golub, Gene H.; LeVeque, Randall J. (1979), "Updating Formulae and a Pairwise Algorithm for Computing Sample Variances." Technical Report STAN-CS-79-773, Department of Computer Science, Stanford University. <a href="http://i.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf">http://i.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf</a>.  <a href="struct_open_kalman_1_1_monte_carlo_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_particle_distribution.html">ParticleDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribution of particles.  <a href="struct_open_kalman_1_1_particle_distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_polar.html">Polar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic coefficient group reflecting polar coordinates.  <a href="struct_open_kalman_1_1_polar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_recursive_least_squares_transform.html">RecursiveLeastSquaresTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates a recursive least squares error distribution of parameters, with a forgetting factor λ. Useful for parameter estimation, where the parameter is expected to possibly drift over time.  <a href="struct_open_kalman_1_1_recursive_least_squares_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_sample_points_transform.html">SamplePointsTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled points transform. Compatible with unscented transform and cubature transform. As implemented in, e.g., E. Wan &amp; R. van der Merwe, "The unscented Kalman filter for nonlinear estimation," in Proc. of IEEE Symposium (AS-SPCC), pp. 153-158. See also R. van der Merwe &amp; E. Wan, "The Square-Root Unscented Kalman Filter for State and Parameter-Estimation in Proc. Acoustics, Speech, and Signal Processing (ICASSP'01), 2001, pp. 3461-64.  <a href="struct_open_kalman_1_1_sample_points_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_spherical.html">Spherical</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic coefficient group reflecting spherical coordinates.  <a href="struct_open_kalman_1_1_spherical.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_square_root_covariance.html">SquareRootCovariance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The upper or lower triangle Cholesky factor (square root) of a covariance matrix.  <a href="struct_open_kalman_1_1_square_root_covariance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_transformation.html">Transformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transformation from one single-column vector to another.  <a href="struct_open_kalman_1_1_transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_transform_base.html">TransformBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base for all transforms.  <a href="struct_open_kalman_1_1_transform_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_unscented_parameters_parameter_estimation.html">UnscentedParametersParameterEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unscented parameters for use in parameter estimation.  <a href="struct_open_kalman_1_1_unscented_parameters_parameter_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_unscented_parameters_state_estimation.html">UnscentedParametersStateEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unscented parameters for use in state estimation (the default).  <a href="struct_open_kalman_1_1_unscented_parameters_state_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The root namespace for <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a>. </p>
<p>The namespace for all OpenKalman-specific classes and methods. </p>
</div><h2 class="groupheader">Variable Documentation</h2>
<a id="a2562e4c0918dc2cbf74de6a97d9388cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2562e4c0918dc2cbf74de6a97d9388cf">&#9670;&nbsp;</a></span>cholesky_form</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::cholesky_form = <a class="el" href="struct_open_kalman_1_1internal_1_1is__cholesky__form.html">internal::is_cholesky_form</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that a type has a nested native matrix that is a Cholesky square root. </p>
<p>If this is true, then nested_matrix_t&lt;T&gt; is true. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00769">769</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="af847ece5eb2e6d50df847573c505b852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af847ece5eb2e6d50df847573c505b852">&#9670;&nbsp;</a></span>coefficients</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::coefficients = detail::is_coefficients&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>T is a group of atomic or composite coefficients. </p>
<p>Atomic coefficient groups are coefficients or groups of coefficients that function as a unit, and cannot be separated. They may be combined into composite coefficients by passing them as template parameters to <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>. These include Axis, Distance, <a class="el" href="struct_open_kalman_1_1_angle.html" title="An angle or any other simple modular value.">Angle</a>, <a class="el" href="struct_open_kalman_1_1_inclination.html" title="A positive or negative real number φ representing an inclination or declination from the horizon.">Inclination</a>, <a class="el" href="struct_open_kalman_1_1_polar.html" title="An atomic coefficient group reflecting polar coordinates.">Polar</a>, and <a class="el" href="struct_open_kalman_1_1_spherical.html" title="An atomic coefficient group reflecting spherical coordinates.">Spherical</a>.</p>
<p>Composite coefficients are specializations of the class <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>, which has the purpose of grouping other atomic or composite coefficients. Composite coefficients can, themselves, comprise groups of other composite components. Composite coefficients are of the form Coefficients&lt;Cs...&gt;.</p>
<p>Examples of coefficients:</p><ul>
<li>Axis</li>
<li>Polar&lt;Distance, angle::Radians&gt;</li>
<li>Coefficients&lt;Axis, angle::Radians&gt;</li>
<li><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>&lt;Spherical&lt;angle::Degrees, inclination::degrees, Distance&gt;, Axis, Axis&gt; </li>
</ul>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00094">94</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a77f3b5f0d758aec7db59022e845abed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f3b5f0d758aec7db59022e845abed1">&#9670;&nbsp;</a></span>column_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::column_vector = detail::is_column_vector&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T is a column vector or set of column vectors (i.e., the columns all have type Axis). </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00294">294</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="acc62cd53d66b676058de97da3caaca3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc62cd53d66b676058de97da3caaca3b">&#9670;&nbsp;</a></span>covariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::covariance = <a class="el" href="namespace_open_kalman.html#a4bf939b25b2e4bfc1162f21533ae490e">square_root_covariance</a>&lt;T&gt; or detail::is_sa_covariance&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T is a specialization of either <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00346">346</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a19898d83f3f0b722b834acac97f7c17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19898d83f3f0b722b834acac97f7c17e">&#9670;&nbsp;</a></span>covariance_nestable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::covariance_nestable = <a class="el" href="struct_open_kalman_1_1internal_1_1is__covariance__nestable.html">internal::is_covariance_nestable</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>T is an acceptable nested matrix for a covariance (including square_root_covariance). </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00191">191</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="acda49202b6dd92195051ed9db5fcdcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda49202b6dd92195051ed9db5fcdcaf">&#9670;&nbsp;</a></span>diagonal_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::diagonal_matrix = detail::is_diag_matrix_impl&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that a type is a diagonal matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00419">419</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="a80760930fc0db06999a2dce3dd4b53f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80760930fc0db06999a2dce3dd4b53f0">&#9670;&nbsp;</a></span>distribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::distribution = <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T is a statistical distribution of any kind that is defined in <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a>. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00384">384</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a4a95b16bcf85246cc892ddf51cc9ddfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a95b16bcf85246cc892ddf51cc9ddfa">&#9670;&nbsp;</a></span>element_gettable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::element_gettable = <a class="el" href="struct_open_kalman_1_1internal_1_1is__element__gettable.html">internal::is_element_gettable</a>&lt;std::decay_t&lt;T&gt;, N&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that a type has elements that can be retrieved with N number of indices. </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00894">894</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="ac77329c3cd71568cac6bd18c3add8d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77329c3cd71568cac6bd18c3add8d0c">&#9670;&nbsp;</a></span>element_settable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::element_settable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= internal::is_element_settable&lt;T, N&gt;::value and</div>
<div class="line">    (not std::is_const_v&lt;std::remove_reference_t&lt;T&gt;&gt;)</div>
</div><!-- fragment -->
<p>Specifies that a type has elements that can be set with N number of indices. </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00944">944</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="a78584a279011110fd315cbf73ca2fe36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78584a279011110fd315cbf73ca2fe36">&#9670;&nbsp;</a></span>equivalent_to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::equivalent_to = <a class="el" href="struct_open_kalman_1_1internal_1_1is__equivalent__to.html">internal::is_equivalent_to</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>T is equivalent to U, where T and U are sets of coefficients. </p>
<p>Sets of coefficients are equivalent if they are treated functionally the same.</p><ul>
<li>Any coefficient or group of coefficients is equivalent to itself.</li>
<li>Coefficient&lt;Ts...&gt; is equivalent to Coefficient&lt;Us...&gt;, if each Ts is equivalent to its respective Us.</li>
<li>Coefficient&lt;T&gt; is equivalent to T, and vice versa. Example:<div class="fragment"><div class="line">equivalent_to&lt;Axis, Coefficients&lt;Axis&gt;&gt; </div>
</div><!-- fragment --> returns <code>true</code>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00127">127</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a50c621b67811a5ba3abe325f75618cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c621b67811a5ba3abe325f75618cd8">&#9670;&nbsp;</a></span>euclidean_mean</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::euclidean_mean = detail::is_euclidean_mean&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T is a Euclidean mean (i.e., is a specialization of the class <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>). </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00215">215</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a434bc44aa1de7faf3cac40cca8944b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434bc44aa1de7faf3cac40cca8944b44">&#9670;&nbsp;</a></span>euclidean_transformed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::euclidean_transformed = detail::is_euclidean_transformed&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T is a Euclidean mean that actually has coefficients that are transformed to Euclidean space. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00242">242</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="af9367eb4d7b08c961db76037c1926531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9367eb4d7b08c961db76037c1926531">&#9670;&nbsp;</a></span>gaussian_distribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::gaussian_distribution = detail::is_gaussian_distribution&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T is a Gaussian distribution. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00372">372</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a79246e358d47951c68ade232002bdecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79246e358d47951c68ade232002bdecb">&#9670;&nbsp;</a></span>identity_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::identity_matrix = <a class="el" href="struct_open_kalman_1_1internal_1_1is__identity__matrix.html">internal::is_identity_matrix</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that a type is an identity matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00311">311</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="a05da5d495bfe6445599208b60bf12d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05da5d495bfe6445599208b60bf12d69">&#9670;&nbsp;</a></span>lower_triangular_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::lower_triangular_matrix = detail::is_lt_matrix_impl&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that a type is a lower-triangular matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00599">599</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="a2745b3bfff7250ac8d9e0dc79902508c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2745b3bfff7250ac8d9e0dc79902508c">&#9670;&nbsp;</a></span>mean</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::mean = detail::is_mean&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T is a mean (i.e., is a specialization of the class <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>). </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00163">163</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a65caec2881ed038f08fbf632355bfbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65caec2881ed038f08fbf632355bfbf4">&#9670;&nbsp;</a></span>one_by_one_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::one_by_one_matrix = detail::is_1by1&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that a type is a one-by-one matrix (i.e., one row and one column). </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00371">371</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="a163a7971e4b4684e1793a209c83f5688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163a7971e4b4684e1793a209c83f5688">&#9670;&nbsp;</a></span>prefix_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::prefix_of = <a class="el" href="struct_open_kalman_1_1internal_1_1is__prefix__of.html">internal::is_prefix_of</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>T is a prefix of U, where T and U are sets of coefficients. </p>
<p>If T is a prefix of U, then U is equivalent_to concatenating T with the remaining part of U. C is a prefix of Coefficients&lt;C, Cs...&gt; for any coefficients Cs. T is a prefix of U if equivalent_to&lt;T, U&gt;. Coefficients&lt;&gt; is a prefix of any set of coefficients. Example,</p><div class="fragment"><div class="line">prefix_of&lt;Coefficients&lt;Axis&gt;, Coefficients&lt;Axis, angle::Radians&gt;&gt; </div>
</div><!-- fragment --><p> returns <code>true</code>. </p>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00160">160</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a63114cb8862cdcff4b5f0660b16a5bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63114cb8862cdcff4b5f0660b16a5bec">&#9670;&nbsp;</a></span>self_adjoint_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::self_adjoint_matrix = detail::is_sa_matrix_impl&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that a type is a self-adjoint matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00508">508</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="aef8b4f9495a8827f4f2235b3dd17a6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8b4f9495a8827f4f2235b3dd17a6aa">&#9670;&nbsp;</a></span>self_contained</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::self_contained = <a class="el" href="struct_open_kalman_1_1internal_1_1is__self__contained.html">internal::is_self_contained</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that a type is a self-contained matrix or expression. </p>
<p>A value is self-contained if it can be created in a function and returned as the result. <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> matrix types are self-contained if their wrapped native matrix is self-contained and is not an lvalue reference. The matrix library interface will specify which native matrices and expressions are self-contained. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00101">101</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="a4bf939b25b2e4bfc1162f21533ae490e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf939b25b2e4bfc1162f21533ae490e">&#9670;&nbsp;</a></span>square_root_covariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::square_root_covariance = detail::is_square_root_covariance&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T is a square root (Cholesky) covariance matrix (i.e., a specialization of <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>). </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00320">320</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="ada97c2afb746e33dd806af6f63957fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada97c2afb746e33dd806af6f63957fce">&#9670;&nbsp;</a></span>triangular_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::triangular_matrix = detail::is_triangular_matrix_impl&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that a type is a triangular matrix (upper or lower). </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00713">713</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="ae19962a38a87cd8c8003e48f42150145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19962a38a87cd8c8003e48f42150145">&#9670;&nbsp;</a></span>typed_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::typed_matrix = <a class="el" href="namespace_open_kalman.html#a2745b3bfff7250ac8d9e0dc79902508c">mean</a>&lt;T&gt; or <a class="el" href="namespace_open_kalman.html#a50c621b67811a5ba3abe325f75618cd8">euclidean_mean</a>&lt;T&gt; or detail::is_matrix&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T is a typed matrix (i.e., is a specialization of <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a>, <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>, or <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>). </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00268">268</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a5245fbf912b12a279acb815fcf7650d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5245fbf912b12a279acb815fcf7650d9">&#9670;&nbsp;</a></span>typed_matrix_nestable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::typed_matrix_nestable = <a class="el" href="struct_open_kalman_1_1internal_1_1is__typed__matrix__nestable.html">internal::is_typed_matrix_nestable</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies a type that is nestable in a general typed matrix (e.g., matrix, mean, or euclidean_mean) </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00222">222</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a5456de7a2e027daca692a5c72dc3540e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5456de7a2e027daca692a5c72dc3540e">&#9670;&nbsp;</a></span>upper_triangular_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::upper_triangular_matrix = detail::is_ut_matrix_impl&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that a type is an upper-triangular matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00664">664</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="ae2d3de4ef2635e290fd9640db5721563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d3de4ef2635e290fd9640db5721563">&#9670;&nbsp;</a></span>wrapped_mean</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::wrapped_mean = detail::is_wrapped_mean&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T is a wrapped mean (i.e., its row coefficients have at least one type that requires wrapping). </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00189">189</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="ae46b30e35dee139fe206951335c1b4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46b30e35dee139fe206951335c1b4ec">&#9670;&nbsp;</a></span>zero_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::zero_matrix = <a class="el" href="struct_open_kalman_1_1internal_1_1is__zero__matrix.html">internal::is_zero_matrix</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that a type is a zero matrix. </p>
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00250">250</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ad7fbe21f478b7b06ac97b6eb6f5967c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fbe21f478b7b06ac97b6eb6f5967c3">&#9670;&nbsp;</a></span>Axes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">OpenKalman::Axes</a> = typedef <a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">Replicate</a>&lt;Axis, size&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <code>Coefficients&lt;Axis...&gt;</code>, where Axis is repeated <code>size</code> times. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">size</td><td>The number of Axes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="coefficient-types_2_coefficients_8hpp_source.html#l00272">272</a> of file <a class="el" href="coefficient-types_2_coefficients_8hpp_source.html">Coefficients.hpp</a>.</p>

</div>
</div>
<a id="a098e86bc01897e4b391805799008a9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098e86bc01897e4b391805799008a9f4">&#9670;&nbsp;</a></span>Concatenate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Coeffs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#a098e86bc01897e4b391805799008a9f4">OpenKalman::Concatenate</a> = typedef typename detail::ConcatenateImpl&lt;Coeffs...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate any number of Coefficients&lt;...&gt; types. </p>
<p>Example:</p><div class="fragment"><div class="line"> Concatenate&lt;Coefficients&lt;angle::Radians&gt;, Coefficients&lt;Axis, Distance&gt;&gt; ==</div>
<div class="line">Coefficients&lt;angle::Radians, Axis, Distance&gt; </div>
</div><!-- fragment --><p>. </p>

<p class="definition">Definition at line <a class="el" href="coefficient__forward-declarations_8hpp_source.html#l00354">354</a> of file <a class="el" href="coefficient__forward-declarations_8hpp_source.html">coefficient_forward-declarations.hpp</a>.</p>

</div>
</div>
<a id="a7fb718bc7a10021ec9a0032e9b3fc92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb718bc7a10021ec9a0032e9b3fc92e">&#9670;&nbsp;</a></span>native_matrix_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t rows = MatrixTraits&lt;T&gt;::dimension, std::size_t cols = MatrixTraits&lt;T&gt;::columns&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#a7fb718bc7a10021ec9a0032e9b3fc92e">OpenKalman::native_matrix_t</a> = typedef typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt;T&gt;::template NativeMatrix&lt;rows, cols&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for a self-contained native matrix, based on and equivalent to parameter T. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type from which the native matrix is derived. </td></tr>
    <tr><td class="paramname">rows</td><td>Number of rows in the native matrix (defaults to the number of rows in T). </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns in the native matrix (defaults to the number of columns in T). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00198">198</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="abc8e1017c2a892423e656ba212290b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8e1017c2a892423e656ba212290b74">&#9670;&nbsp;</a></span>nested_matrix_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename MatrixTraits&lt;T&gt;::NestedMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">OpenKalman::nested_matrix_t</a> = typedef typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt;T&gt;::NestedMatrix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for a type's nested matrix, if it exists. </p>
<p>Only participates in overload resolution if the type has a nested matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that is a wrapper for a nested matrix. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00037">37</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="ab86f091b16817336eb3f67006cd3a779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86f091b16817336eb3f67006cd3a779">&#9670;&nbsp;</a></span>passable_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">OpenKalman::passable_t</a> = typedef std::conditional_t&lt;std::is_lvalue_reference_v&lt;T&gt;, T, <a class="el" href="namespace_open_kalman.html#a1d08cc520e029d965770641656727893">self_contained_t</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for a type, derived from and equivalent to parameter T, that can be passed as a function parameter. </p>
<p>A passable type is either an lvalue reference or an rvalue reference to a self_contained_t type. </p>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00183">183</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="ac66c8a3d2e7e2449a727d370262995ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66c8a3d2e7e2449a727d370262995ef">&#9670;&nbsp;</a></span>Replicate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">OpenKalman::Replicate</a> = typedef typename detail::ReplicateImpl&lt;C, N&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for <code>Coefficients&lt;C...&gt;</code>, where <code>C</code> is repeated <em>N</em> times. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The coefficient to be repeated. </td></tr>
    <tr><td class="paramname">N</td><td>The number of times to repeat coefficient C. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="coefficient-types_2_coefficients_8hpp_source.html#l00264">264</a> of file <a class="el" href="coefficient-types_2_coefficients_8hpp_source.html">Coefficients.hpp</a>.</p>

</div>
</div>
<a id="a1d08cc520e029d965770641656727893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d08cc520e029d965770641656727893">&#9670;&nbsp;</a></span>self_contained_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#a1d08cc520e029d965770641656727893">OpenKalman::self_contained_t</a> = typedef std::conditional_t&lt; <a class="el" href="namespace_open_kalman.html#aef8b4f9495a8827f4f2235b3dd17a6aa">self_contained</a>&lt;T&gt;, std::decay_t&lt;T&gt;, typename detail::self_contained_impl&lt;T&gt;::type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for type, derived from and equivalent to parameter T, that is self-contained. </p>
<p>Use this alias to obtain a type, equivalent to T, that can safely be returned from a function. </p>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00170">170</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae59a5b875bd8ebda034f8876dd865a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59a5b875bd8ebda034f8876dd865a99">&#9670;&nbsp;</a></span>EuclideanMean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , std::enable_if_t&lt; typed_matrix_nestable&lt; V &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">OpenKalman::EuclideanMean</a> </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a>&lt; V &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce template parameters from a typed_matrix_nestable, assuming axis-only coefficients. </p>
<p>Deduce template parameters from a non-Euclidean-transformed typed matrix.</p>
<p>Deduce template parameters from a Euclidean-transformed typed matrix. </p>

</div>
</div>
<a id="a9934a0fa27adfaf949d994695a13b6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9934a0fa27adfaf949d994695a13b6af">&#9670;&nbsp;</a></span>FiniteDifferenceLinearization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Trans , typename InDelta , typename ... PsDelta&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::FiniteDifferenceLinearization </td>
          <td>(</td>
          <td class="paramtype">Trans &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InDelta &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PsDelta &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  FiniteDifferenceLinearization&lt; Trans, InDelta, PsDelta... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deduction guide </p>

</div>
</div>
<a id="a7ed81d91202d9b998733a3be06de9910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed81d91202d9b998733a3be06de9910">&#9670;&nbsp;</a></span>get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt; and((self_adjoint_matrix&lt; nested_matrix_t&lt; Arg &gt;&gt; and not square_root_covariance&lt; Arg &gt;) or(triangular_matrix&lt; nested_matrix_t&lt; Arg &gt;&gt; and square_root_covariance&lt; Arg &gt;)) and element_gettable&lt; nested_matrix_t&lt; Arg &gt;, 1 &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::get_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get element (i) of a covariance matrix. </p>
<p>Get element (i) of a typed matrix. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00440">440</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="aab9f83dc120f7424fe949f401344960e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9f83dc120f7424fe949f401344960e">&#9670;&nbsp;</a></span>get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt; and element_gettable&lt; nested_matrix_t&lt; Arg &gt;, 2 &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::get_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get element (i, j) of a covariance matrix. </p>
<p>Get element (i, j) of a typed matrix. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00421">421</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a6f44bd141f1e2b9b65432a633d9180e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f44bd141f1e2b9b65432a633d9180e2">&#9670;&nbsp;</a></span>inverse_scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename S , std::enable_if_t&lt; covariance&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::inverse_scale </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale a covariance by the inverse of a scalar factor. Equivalent by division by the square of a scalar. For a square root covariance, this is equivalent to division by the scalar. </p>

<p class="definition">Definition at line <a class="el" href="covariance-arithmetic_8hpp_source.html#l00535">535</a> of file <a class="el" href="covariance-arithmetic_8hpp_source.html">covariance-arithmetic.hpp</a>.</p>

</div>
</div>
<a id="a0e6f25c9190e4658793bb610b179bbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6f25c9190e4658793bb610b179bbc9">&#9670;&nbsp;</a></span>LQ_decomposition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; typed_matrix&lt; A &gt; and(not euclidean_transformed&lt; A &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::LQ_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an LQ decomposition of matrix A=[L|0]Q, where L is a lower-triangular matrix, and Q is orthogonal. Returns L as a Cholesky lower-triangular <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>. All column coefficients must be axes, and A cannot be Euclidean-transformed. </p>

<p class="definition">Definition at line <a class="el" href="typed-matrix-overloads_8hpp_source.html#l00243">243</a> of file <a class="el" href="typed-matrix-overloads_8hpp_source.html">typed-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="a0c8ce92ebb39445ad24273396c57ff0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8ce92ebb39445ad24273396c57ff0b">&#9670;&nbsp;</a></span>LQ_decomposition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::LQ_decomposition </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an LQ decomposition of matrix A=[L,0]Q, where L is a lower-triangular matrix, and Q is orthogonal. Returns L as a lower-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00248">248</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a6e11974581182d024289c3df6f00e92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e11974581182d024289c3df6f00e92b">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a covariance_nestable or typed_matrix_nestable. </p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>, with nested triangular type based on a typed_matrix.</p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> based on a nested triangle, with default Axis coefficients.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l00576">576</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a74f4317db70b740a4b05b154ea7d144e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f4317db70b740a4b05b154ea7d144e">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> with a nested triangular matrix, from a typed_matrix_nestable. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l00601">601</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="af82a27123450aa0fd5266c332bde0362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82a27123450aa0fd5266c332bde0362">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a typed_matrix_nestable or covariance_nestable. </p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>, based on a typed_matrix type.</p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a covariance type.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  The coefficients will be Axis.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l00623">623</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a1167376779e08b44911a5b18134ba1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1167376779e08b44911a5b18134ba1d4">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and covariance_nestable&lt; Arg &gt; and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a covariance_nestable, specifying the coefficients. </p>
<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>, with a nested triangular matrix, from a typed matrix.</p>
<p>Make a default Axis <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> (with nested triangular matrix) from a self-adjoint typed_matrix_nestable.</p>
<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a self-adjoint typed_matrix_nestable, specifying the coefficients.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A covariance_nestable with size matching <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A square typed_matrix_nestable with size matching <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Arg</td><td>A square, self-adjoint typed_matrix_nestable.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l00444">444</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a8b1367d0df6f272ee442c2272a228ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1367d0df6f272ee442c2272a228ab8">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance_nestable&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a covariance_nestable, with default Axis coefficients. </p>
<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a typed matrix.</p>
<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> based on another covariance.</p>
<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a self-adjoint typed_matrix_nestable, using default Axis coefficients.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A covariance_nestable.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A square typed_matrix_nestable.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l00462">462</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="aae21ef7c840cf37fb755618dd419a221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae21ef7c840cf37fb755618dd419a221">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and(not covariance_nestable&lt; Arg &gt;) and(triangle_type==TriangleType::lower or triangle_type==TriangleType::upper) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> (with nested triangular matrix) from a self-adjoint typed_matrix_nestable. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Arg</td><td>A square, self-adjoint typed_matrix_nestable with size matching <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l00489">489</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="aae62cc2a04ec13fe3c3a71f9326b4637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae62cc2a04ec13fe3c3a71f9326b4637">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::dimension==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a default, self-contained <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new matrix is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_euclidean_mean_8hpp_source.html#l00310">310</a> of file <a class="el" href="_euclidean_mean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="a3dc328414ecb720005c3c813be752ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc328414ecb720005c3c813be752ec3">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a self-contained <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> with default Axis coefficients. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new Euclidean mean is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_euclidean_mean_8hpp_source.html#l00328">328</a> of file <a class="el" href="_euclidean_mean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="a51161ea0e106d97f06ca53662029bf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51161ea0e106d97f06ca53662029bf7a">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and column_vector&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> from another typed_matrix. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A typed_matrix (i.e., <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a>, <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>, or <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_euclidean_mean_8hpp_source.html#l00286">286</a> of file <a class="el" href="_euclidean_mean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="aa48c0170c781745c5abc1e13f83777d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48c0170c781745c5abc1e13f83777d3">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::dimension==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> from a typed_matrix_nestable, specifying the row coefficients. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>A typed_matrix_nestable with size matching ColumnCoefficients. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_euclidean_mean_8hpp_source.html#l00254">254</a> of file <a class="el" href="_euclidean_mean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="a3d6687a8e5791a070fb3bb625687f4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6687a8e5791a070fb3bb625687f4b7">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> from a typed_matrix_nestable object, with default Axis coefficients. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_euclidean_mean_8hpp_source.html#l00269">269</a> of file <a class="el" href="_euclidean_mean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="a5647c719085536c8fa6851836c5d03ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5647c719085536c8fa6851836c5d03ea">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RowCoefficients , typename ColumnCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and coefficients&lt; ColumnCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size) and(MatrixTraits&lt; M &gt;::columns==ColumnCoefficients::size), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a default, self-contained <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RowCoefficients</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">ColumnCoefficients</td><td>The coefficient types corresponding to the columns. </td></tr>
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new matrix is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00393">393</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="affa3556236800e6eecb365ea76199ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa3556236800e6eecb365ea76199ae5">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a self-contained <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object with default Axis coefficients. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new matrix is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00410">410</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="afdb3bd9bc6f894eb4b03b48b8a0d850c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb3bd9bc6f894eb4b03b48b8a0d850c">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from another typed_matrix. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A typed_matrix (i.e., <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a>, <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>, or <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00364">364</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="a73e36fbdb948bce537bd17d75114f712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e36fbdb948bce537bd17d75114f712">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RowCoefficients , typename ColumnCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and coefficients&lt; ColumnCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size) and(MatrixTraits&lt; M &gt;::columns==ColumnCoefficients::size), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from a typed_matrix_nestable, specifying the row and column coefficients. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RowCoefficients</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">ColumnCoefficients</td><td>The coefficient types corresponding to the columns. </td></tr>
    <tr><td class="paramname">M</td><td>A typed_matrix_nestable with size matching RowCoefficients and ColumnCoefficients. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00293">293</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="a71be5796e548bfdb501444c727d9f372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71be5796e548bfdb501444c727d9f372">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RowCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from a typed_matrix_nestable, specifying only the row coefficients. </p>
<p>The column coefficients are default Axis. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RowCoefficients</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>A typed_matrix_nestable with size matching RowCoefficients and ColumnCoefficients. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00313">313</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="af82be03cc51cb7a0b7b8c2eb14c6c0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82be03cc51cb7a0b7b8c2eb14c6c0bb">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from a typed_matrix_nestable object, with default Axis coefficients. </p>
<p>Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from a covariance object.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>A covariance object (i.e., <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>, <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00329">329</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="a258fd14762cd857444878183fc128c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258fd14762cd857444878183fc128c73">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==Coefficients::size), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a default, self-contained <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new matrix is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_mean_8hpp_source.html#l00424">424</a> of file <a class="el" href="_mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="a6abae6f929b546e22c34d58a1595303f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abae6f929b546e22c34d58a1595303f">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a self-contained <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> with default Axis coefficients. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new mean is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_mean_8hpp_source.html#l00441">441</a> of file <a class="el" href="_mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="a342c91bcf1ffd94505e1c4336f95d43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342c91bcf1ffd94505e1c4336f95d43e">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and column_vector&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> from another typed_matrix. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A typed_matrix (i.e., <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a>, <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>, or <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_mean_8hpp_source.html#l00399">399</a> of file <a class="el" href="_mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="ad74553d9027b3d93c5020f13c0570a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74553d9027b3d93c5020f13c0570a8b">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::size==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> from a typed_matrix_nestable, specifying the row coefficients. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>A typed_matrix_nestable with size matching ColumnCoefficients. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_mean_8hpp_source.html#l00364">364</a> of file <a class="el" href="_mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="ab6cb56942738ea287feeb456de8a1ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cb56942738ea287feeb456de8a1ee8">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> from a typed_matrix_nestable object, with default Axis coefficients. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_mean_8hpp_source.html#l00382">382</a> of file <a class="el" href="_mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="acd840cc6cadb87e6bae5724c66b575a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd840cc6cadb87e6bae5724c66b575a9">&#9670;&nbsp;</a></span>make_native_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::make_native_matrix </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert to a self-contained <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> matrix.</p>
<p>Convert to a self-contained <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> matrix (wrapping any angles, if necessary). </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00103">103</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="ad137ac22381d6cd2d06a57b96a3f4a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad137ac22381d6cd2d06a57b96a3f4a83">&#9670;&nbsp;</a></span>make_self_contained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename Arg , std::enable_if_t&lt; gaussian_distribution&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::make_self_contained </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert to self-contained version of the distribution. </p>
<p>Convert vector object to self-contained version (wrapping any angles).</p>
<p>Convert to self-contained version of the covariance matrix. </p>

<p class="definition">Definition at line <a class="el" href="_gaussian_distribution_8hpp_source.html#l00650">650</a> of file <a class="el" href="_gaussian_distribution_8hpp_source.html">GaussianDistribution.hpp</a>.</p>

</div>
</div>
<a id="a22473ed4dd2db3f2eaa82a5dbd7e799d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22473ed4dd2db3f2eaa82a5dbd7e799d">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a typed_matrix_nestable. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l00522">522</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="a00898738e33dfb03d94f4289d6855633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00898738e33dfb03d94f4289d6855633">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a covariance_nestable or typed_matrix_nestable. </p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> based on a typed_matrix.</p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>, with default Axis coefficients.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l00545">545</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="a1e2f1e0973fe26e185ec3d80837fcd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2f1e0973fe26e185ec3d80837fcd67">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and(MatrixTraits&lt; Arg &gt;::dimension==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a typed_matrix_nestable or covariance_nestable. </p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> based on a typed_matrix.</p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a covariance type.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  The coefficients will be Axis.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l00570">570</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="a3983a57927dc746dcc5a6c877337a686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3983a57927dc746dcc5a6c877337a686">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and covariance_nestable&lt; Arg &gt; and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a covariance_nestable, specifying the coefficients. </p>
<p>Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a typed matrix.</p>
<p>Make a default Axis <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a self-adjoint typed_matrix_nestable.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A covariance_nestable with size matching <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Arg</td><td>A square, self-adjoint typed_matrix_nestable.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l00432">432</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="ae9adb3eae588123a5f80eafea891a0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9adb3eae588123a5f80eafea891a0c5">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance_nestable&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a covariance_nestable, with default Axis coefficients. </p>
<p>Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> based on another covariance.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A covariance_nestable.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l00450">450</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="adc58f602f72886f980090ec403f86f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc58f602f72886f980090ec403f86f2e">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , TriangleType triangle_type = TriangleType::lower, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and(not covariance_nestable&lt; Arg &gt;) and(triangle_type==TriangleType::lower or triangle_type==TriangleType::upper) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> (with nested triangular matrix) from a self-adjoint typed_matrix_nestable. </p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Arg</td><td>A square, self-adjoint typed_matrix_nestable with size matching <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l00477">477</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="a05f9155e6a8c211c128af8bdc3f02c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f9155e6a8c211c128af8bdc3f02c14">&#9670;&nbsp;</a></span>make_Transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , std::enable_if_t&lt; is_linearized_function_v&lt; Function, 1 &gt; and not is_linearized_function_v&lt; Function, 2 &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_Transformation </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a transformation from a first-order linearized transformation defining a Jacobian function. Substitution failure if the transformation function is polymorphic.</p>
<p>Make a transformation from a second-order linearized transformation defining Jacobian and Hessian functions. Substitution failure if the transformation function is polymorphic. </p>

<p class="definition">Definition at line <a class="el" href="_transformation_8hpp_source.html#l00242">242</a> of file <a class="el" href="_transformation_8hpp_source.html">Transformation.hpp</a>.</p>

</div>
</div>
<a id="aff013f3acace99fb1191fd677bdaba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff013f3acace99fb1191fd677bdaba67">&#9670;&nbsp;</a></span>Matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , std::enable_if_t&lt; typed_matrix&lt; V &gt; and not euclidean_transformed&lt; V &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_matrix.html">OpenKalman::Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_open_kalman_1_1_matrix.html">Matrix</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::RowCoefficients, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::ColumnCoefficients, <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a>&lt; <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a>&lt; V &gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce template parameters from a non-Euclidean-transformed typed matrix. </p>
<p>Deduce parameter types from a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>.</p>
<p>Deduce template parameters from a Euclidean-transformed typed matrix. </p>

</div>
</div>
<a id="a4811b89985f03ba5fe3b5c6a54b9e49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4811b89985f03ba5fe3b5c6a54b9e49b">&#9670;&nbsp;</a></span>Mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , std::enable_if_t&lt; typed_matrix_nestable&lt; V &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_mean.html">OpenKalman::Mean</a> </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#ab86f091b16817336eb3f67006cd3a779">passable_t</a>&lt; V &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce template parameters from a typed_matrix_nestable, assuming axis-only coefficients. </p>
<p>Deduce template parameters from a Euclidean-transformed typed matrix.</p>
<p>Deduce template parameters from a non-Euclidean-transformed typed matrix. </p>

</div>
</div>
<a id="ae8c9b539547601ae4b033c3ffe425b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c9b539547601ae4b033c3ffe425b5b">&#9670;&nbsp;</a></span>QR_decomposition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; typed_matrix&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a QR decomposition of matrix A=Q[U|0], where U is an upper-triangular matrix, and Q is orthogonal. Returns U as a Cholesky upper-triangular <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>. All row coefficients must be axes. </p>

<p class="definition">Definition at line <a class="el" href="typed-matrix-overloads_8hpp_source.html#l00259">259</a> of file <a class="el" href="typed-matrix-overloads_8hpp_source.html">typed-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="a2c53f3473e7552a36723afca9d5588ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c53f3473e7552a36723afca9d5588ad">&#9670;&nbsp;</a></span>QR_decomposition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a QR decomposition of matrix A=Q[U,0], where U is an upper-triangular matrix, and Q is orthogonal. Returns L as an upper-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00264">264</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a3be486e53ad3cb44d7ea46c4201f4ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be486e53ad3cb44d7ea46c4201f4ce5">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename A , std::enable_if_t&lt; covariance&lt; M &gt; and typed_matrix&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::scale </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale a covariance by a matrix. A scaled covariance Arg is A * Arg * adjoint(A). A scaled square root covariance L or U is also scaled accordingly, so that scale(L * adjoint(L)) = A * L * adjoint(L) * adjoint(A) or scale(adjoint(U) * U) = A * adjoint(U) * U * adjoint(A). </p>

<p class="definition">Definition at line <a class="el" href="covariance-arithmetic_8hpp_source.html#l00562">562</a> of file <a class="el" href="covariance-arithmetic_8hpp_source.html">covariance-arithmetic.hpp</a>.</p>

</div>
</div>
<a id="a77f2335ea8a758c0b229c54cadc27aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f2335ea8a758c0b229c54cadc27aa1">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename S , std::enable_if_t&lt; covariance&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::scale </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale a covariance by a factor. Equivalent to multiplication by the square of a scalar. For a square root covariance, this is equivalent to multiplication by the scalar. </p>

<p class="definition">Definition at line <a class="el" href="covariance-arithmetic_8hpp_source.html#l00516">516</a> of file <a class="el" href="covariance-arithmetic_8hpp_source.html">covariance-arithmetic.hpp</a>.</p>

</div>
</div>
<a id="a3ef70489b68fd02e29dc2210aeaa4311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef70489b68fd02e29dc2210aeaa4311">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , std::enable_if_t&lt; covariance&lt; A &gt; and typed_matrix&lt; B &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::solve </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves a x = b for x (A is a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>, B is a vector type). </p>
<p>Solves AX = B for X, where X and B are means of the same type, and A is a square matrix with compatible types. If wrapping occurs, it will be both before for B and after for the X result. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00219">219</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a2bf46841af75eee02bfd52c1708831b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf46841af75eee02bfd52c1708831b7">&#9670;&nbsp;</a></span>split_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_diagonal </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> diagonally. </p>
<p>Split typed matrix into one or more typed matrices diagonally. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00376">376</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a313e2b8a742da23f4623c6bc4c295d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313e2b8a742da23f4623c6bc4c295d5b">&#9670;&nbsp;</a></span>split_horizontal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_horizontal </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> vertically. Result is a tuple of typed matrices. </p>
<p>Split typed matrix into one or more typed matrices horizontally. Column coefficients must all be Axis.</p>
<p>Split typed matrix into one or more typed matrices horizontally. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00405">405</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a68dba71f80c4270929d21e416f1c8739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dba71f80c4270929d21e416f1c8739">&#9670;&nbsp;</a></span>split_vertical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_vertical </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> vertically. Result is a tuple of typed matrices. </p>
<p>Split typed matrix into one or more typed matrices vertically. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00390">390</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="abbd655dfd0d89b3b12ece39ab953e061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd655dfd0d89b3b12ece39ab953e061">&#9670;&nbsp;</a></span>Transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename... TaylorDerivatives&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_transformation.html">OpenKalman::Transformation</a> </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaylorDerivatives &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="struct_open_kalman_1_1_transformation.html">Transformation</a>&lt; Function, TaylorDerivatives... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deduction guides </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_open_kalman.html">OpenKalman</a></li>
    <li class="footer">Generated on Wed Dec 2 2020 15:38:14 for OpenKalman by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0 </li>
  </ul>
</div>
</body>
</html>
