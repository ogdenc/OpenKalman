<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenKalman: OpenKalman Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenKalman
   </div>
   <div id="projectbrief">An open-source, heading-only library for Kalman filters and other recursive filters</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_open_kalman.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#typedef-members">Aliases</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">OpenKalman Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The root namespace for <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a>.  
<a href="namespace_open_kalman.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_open_kalman_1_1angle"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1angle.html">angle</a></td></tr>
<tr class="memdesc:namespace_open_kalman_1_1angle"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for definitions relating to coefficients representing an angle. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_open_kalman_1_1_eigen3"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html">Eigen3</a></td></tr>
<tr class="memdesc:namespace_open_kalman_1_1_eigen3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for all <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> interface definitions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_open_kalman_1_1inclination"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1inclination.html">inclination</a></td></tr>
<tr class="memdesc:namespace_open_kalman_1_1inclination"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for definitions relating to coefficients representing an inclination. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_open_kalman_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespace_open_kalman_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for internal definitions, not intended for use outside of <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> development. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2745b3bfff7250ac8d9e0dc79902508c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2745b3bfff7250ac8d9e0dc79902508c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2745b3bfff7250ac8d9e0dc79902508c">mean</a> = detail::is_mean&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a2745b3bfff7250ac8d9e0dc79902508c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a mean (i.e., is a specialization of the class <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>).  <a href="namespace_open_kalman.html#a2745b3bfff7250ac8d9e0dc79902508c">More...</a><br /></td></tr>
<tr class="separator:a2745b3bfff7250ac8d9e0dc79902508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d3de4ef2635e290fd9640db5721563"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2d3de4ef2635e290fd9640db5721563"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae2d3de4ef2635e290fd9640db5721563">wrapped_mean</a> = detail::is_wrapped_mean&lt;T&gt;::value</td></tr>
<tr class="memdesc:ae2d3de4ef2635e290fd9640db5721563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a wrapped mean (i.e., its row coefficients have at least one type that requires wrapping).  <a href="namespace_open_kalman.html#ae2d3de4ef2635e290fd9640db5721563">More...</a><br /></td></tr>
<tr class="separator:ae2d3de4ef2635e290fd9640db5721563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c621b67811a5ba3abe325f75618cd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50c621b67811a5ba3abe325f75618cd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a50c621b67811a5ba3abe325f75618cd8">euclidean_mean</a> = detail::is_euclidean_mean&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a50c621b67811a5ba3abe325f75618cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a Euclidean mean (i.e., is a specialization of the class <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>).  <a href="namespace_open_kalman.html#a50c621b67811a5ba3abe325f75618cd8">More...</a><br /></td></tr>
<tr class="separator:a50c621b67811a5ba3abe325f75618cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434bc44aa1de7faf3cac40cca8944b44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a434bc44aa1de7faf3cac40cca8944b44"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a434bc44aa1de7faf3cac40cca8944b44">euclidean_transformed</a> = detail::is_euclidean_transformed&lt;T&gt;::value</td></tr>
<tr class="memdesc:a434bc44aa1de7faf3cac40cca8944b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a Euclidean mean that actually has coefficients that are transformed to Euclidean space.  <a href="namespace_open_kalman.html#a434bc44aa1de7faf3cac40cca8944b44">More...</a><br /></td></tr>
<tr class="separator:a434bc44aa1de7faf3cac40cca8944b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19962a38a87cd8c8003e48f42150145"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae19962a38a87cd8c8003e48f42150145"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a> = <a class="el" href="namespace_open_kalman.html#a2745b3bfff7250ac8d9e0dc79902508c">mean</a>&lt;T&gt; or <a class="el" href="namespace_open_kalman.html#a50c621b67811a5ba3abe325f75618cd8">euclidean_mean</a>&lt;T&gt; or detail::is_matrix&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:ae19962a38a87cd8c8003e48f42150145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a typed matrix (i.e., is a specialization of <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a>, <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>, or <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>).  <a href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">More...</a><br /></td></tr>
<tr class="separator:ae19962a38a87cd8c8003e48f42150145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e454bc99a03d730955077ca215479e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11e454bc99a03d730955077ca215479e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a11e454bc99a03d730955077ca215479e">untyped_columns</a> = detail::has_untyped_columns&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a11e454bc99a03d730955077ca215479e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T has untyped (or <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> typed) column coefficients.  <a href="namespace_open_kalman.html#a11e454bc99a03d730955077ca215479e">More...</a><br /></td></tr>
<tr class="separator:a11e454bc99a03d730955077ca215479e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f3b5f0d758aec7db59022e845abed1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77f3b5f0d758aec7db59022e845abed1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a77f3b5f0d758aec7db59022e845abed1">column_vector</a> = <a class="el" href="namespace_open_kalman.html#a11e454bc99a03d730955077ca215479e">untyped_columns</a>&lt;T&gt; and detail::has_one_column&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a77f3b5f0d758aec7db59022e845abed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a column vector (i.e., has one untyped or Axis-typed column).  <a href="namespace_open_kalman.html#a77f3b5f0d758aec7db59022e845abed1">More...</a><br /></td></tr>
<tr class="separator:a77f3b5f0d758aec7db59022e845abed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf939b25b2e4bfc1162f21533ae490e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bf939b25b2e4bfc1162f21533ae490e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4bf939b25b2e4bfc1162f21533ae490e">square_root_covariance</a> = detail::is_square_root_covariance&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a4bf939b25b2e4bfc1162f21533ae490e"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a square root (Cholesky) covariance matrix (i.e., a specialization of <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>).  <a href="namespace_open_kalman.html#a4bf939b25b2e4bfc1162f21533ae490e">More...</a><br /></td></tr>
<tr class="separator:a4bf939b25b2e4bfc1162f21533ae490e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc62cd53d66b676058de97da3caaca3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc62cd53d66b676058de97da3caaca3b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#acc62cd53d66b676058de97da3caaca3b">covariance</a> = <a class="el" href="namespace_open_kalman.html#a4bf939b25b2e4bfc1162f21533ae490e">square_root_covariance</a>&lt;T&gt; or detail::is_sa_covariance&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:acc62cd53d66b676058de97da3caaca3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a specialization of either <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>.  <a href="namespace_open_kalman.html#acc62cd53d66b676058de97da3caaca3b">More...</a><br /></td></tr>
<tr class="separator:acc62cd53d66b676058de97da3caaca3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9367eb4d7b08c961db76037c1926531"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9367eb4d7b08c961db76037c1926531"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a> = detail::is_gaussian_distribution&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:af9367eb4d7b08c961db76037c1926531"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a Gaussian distribution.  <a href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">More...</a><br /></td></tr>
<tr class="separator:af9367eb4d7b08c961db76037c1926531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80760930fc0db06999a2dce3dd4b53f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80760930fc0db06999a2dce3dd4b53f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a80760930fc0db06999a2dce3dd4b53f0">distribution</a> = <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>&lt;T&gt;</td></tr>
<tr class="memdesc:a80760930fc0db06999a2dce3dd4b53f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a statistical distribution of any kind that is defined in <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a>.  <a href="namespace_open_kalman.html#a80760930fc0db06999a2dce3dd4b53f0">More...</a><br /></td></tr>
<tr class="separator:a80760930fc0db06999a2dce3dd4b53f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af847ece5eb2e6d50df847573c505b852"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af847ece5eb2e6d50df847573c505b852"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af847ece5eb2e6d50df847573c505b852">coefficients</a> = detail::is_coefficients&lt;T&gt;::value</td></tr>
<tr class="memdesc:af847ece5eb2e6d50df847573c505b852"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a group of atomic or composite coefficients.  <a href="namespace_open_kalman.html#af847ece5eb2e6d50df847573c505b852">More...</a><br /></td></tr>
<tr class="separator:af847ece5eb2e6d50df847573c505b852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78584a279011110fd315cbf73ca2fe36"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a78584a279011110fd315cbf73ca2fe36"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a78584a279011110fd315cbf73ca2fe36">equivalent_to</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__equivalent__to.html">internal::is_equivalent_to</a>&lt;T, U&gt;::value</td></tr>
<tr class="memdesc:a78584a279011110fd315cbf73ca2fe36"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is equivalent to U, where T and U are sets of coefficients.  <a href="namespace_open_kalman.html#a78584a279011110fd315cbf73ca2fe36">More...</a><br /></td></tr>
<tr class="separator:a78584a279011110fd315cbf73ca2fe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163a7971e4b4684e1793a209c83f5688"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a163a7971e4b4684e1793a209c83f5688"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a163a7971e4b4684e1793a209c83f5688">prefix_of</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__prefix__of.html">internal::is_prefix_of</a>&lt;T, U&gt;::value</td></tr>
<tr class="memdesc:a163a7971e4b4684e1793a209c83f5688"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a prefix of U, where T and U are sets of coefficients.  <a href="namespace_open_kalman.html#a163a7971e4b4684e1793a209c83f5688">More...</a><br /></td></tr>
<tr class="separator:a163a7971e4b4684e1793a209c83f5688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19898d83f3f0b722b834acac97f7c17e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19898d83f3f0b722b834acac97f7c17e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__covariance__nestable.html">internal::is_covariance_nestable</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a19898d83f3f0b722b834acac97f7c17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is an acceptable nested matrix for a covariance (including square_root_covariance).  <a href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">More...</a><br /></td></tr>
<tr class="separator:a19898d83f3f0b722b834acac97f7c17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5245fbf912b12a279acb815fcf7650d9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5245fbf912b12a279acb815fcf7650d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__typed__matrix__nestable.html">internal::is_typed_matrix_nestable</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a5245fbf912b12a279acb815fcf7650d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a type that is nestable in a general typed matrix (e.g., matrix, mean, or euclidean_mean)  <a href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">More...</a><br /></td></tr>
<tr class="separator:a5245fbf912b12a279acb815fcf7650d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b841cd9db4d9a19b89529d1aed58b03"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a8b841cd9db4d9a19b89529d1aed58b03"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a8b841cd9db4d9a19b89529d1aed58b03">self_contained</a></td></tr>
<tr class="memdesc:a8b841cd9db4d9a19b89529d1aed58b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a self-contained matrix or expression.  <a href="namespace_open_kalman.html#a8b841cd9db4d9a19b89529d1aed58b03">More...</a><br /></td></tr>
<tr class="separator:a8b841cd9db4d9a19b89529d1aed58b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46b30e35dee139fe206951335c1b4ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae46b30e35dee139fe206951335c1b4ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae46b30e35dee139fe206951335c1b4ec">zero_matrix</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__zero__matrix.html">internal::is_zero_matrix</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:ae46b30e35dee139fe206951335c1b4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a zero matrix.  <a href="namespace_open_kalman.html#ae46b30e35dee139fe206951335c1b4ec">More...</a><br /></td></tr>
<tr class="separator:ae46b30e35dee139fe206951335c1b4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79246e358d47951c68ade232002bdecb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79246e358d47951c68ade232002bdecb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a79246e358d47951c68ade232002bdecb">identity_matrix</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__identity__matrix.html">internal::is_identity_matrix</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a79246e358d47951c68ade232002bdecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is an identity matrix.  <a href="namespace_open_kalman.html#a79246e358d47951c68ade232002bdecb">More...</a><br /></td></tr>
<tr class="separator:a79246e358d47951c68ade232002bdecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65caec2881ed038f08fbf632355bfbf4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65caec2881ed038f08fbf632355bfbf4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a65caec2881ed038f08fbf632355bfbf4">one_by_one_matrix</a> = detail::is_1by1&lt;T&gt;::value</td></tr>
<tr class="memdesc:a65caec2881ed038f08fbf632355bfbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a one-by-one matrix (i.e., one row and one column).  <a href="namespace_open_kalman.html#a65caec2881ed038f08fbf632355bfbf4">More...</a><br /></td></tr>
<tr class="separator:a65caec2881ed038f08fbf632355bfbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc1aa6874bf00181847d0bc6228514b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4fc1aa6874bf00181847d0bc6228514b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4fc1aa6874bf00181847d0bc6228514b">square_matrix</a> = internal::is_square_matrix&lt;T&gt;::value</td></tr>
<tr class="memdesc:a4fc1aa6874bf00181847d0bc6228514b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a matrix is square (i.e., has the same number and type of rows and column).  <a href="namespace_open_kalman.html#a4fc1aa6874bf00181847d0bc6228514b">More...</a><br /></td></tr>
<tr class="separator:a4fc1aa6874bf00181847d0bc6228514b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda49202b6dd92195051ed9db5fcdcaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acda49202b6dd92195051ed9db5fcdcaf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#acda49202b6dd92195051ed9db5fcdcaf">diagonal_matrix</a> = detail::is_diag_matrix_impl&lt;T&gt;::value</td></tr>
<tr class="memdesc:acda49202b6dd92195051ed9db5fcdcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a diagonal matrix.  <a href="namespace_open_kalman.html#acda49202b6dd92195051ed9db5fcdcaf">More...</a><br /></td></tr>
<tr class="separator:acda49202b6dd92195051ed9db5fcdcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63114cb8862cdcff4b5f0660b16a5bec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a63114cb8862cdcff4b5f0660b16a5bec"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a63114cb8862cdcff4b5f0660b16a5bec">self_adjoint_matrix</a></td></tr>
<tr class="memdesc:a63114cb8862cdcff4b5f0660b16a5bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a self-adjoint matrix.  <a href="namespace_open_kalman.html#a63114cb8862cdcff4b5f0660b16a5bec">More...</a><br /></td></tr>
<tr class="separator:a63114cb8862cdcff4b5f0660b16a5bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05da5d495bfe6445599208b60bf12d69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05da5d495bfe6445599208b60bf12d69"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a05da5d495bfe6445599208b60bf12d69">lower_triangular_matrix</a> = detail::is_lt_matrix_impl&lt;T&gt;::value</td></tr>
<tr class="memdesc:a05da5d495bfe6445599208b60bf12d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a lower-triangular matrix.  <a href="namespace_open_kalman.html#a05da5d495bfe6445599208b60bf12d69">More...</a><br /></td></tr>
<tr class="separator:a05da5d495bfe6445599208b60bf12d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5456de7a2e027daca692a5c72dc3540e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5456de7a2e027daca692a5c72dc3540e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5456de7a2e027daca692a5c72dc3540e">upper_triangular_matrix</a> = detail::is_ut_matrix_impl&lt;T&gt;::value</td></tr>
<tr class="memdesc:a5456de7a2e027daca692a5c72dc3540e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is an upper-triangular matrix.  <a href="namespace_open_kalman.html#a5456de7a2e027daca692a5c72dc3540e">More...</a><br /></td></tr>
<tr class="separator:a5456de7a2e027daca692a5c72dc3540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada97c2afb746e33dd806af6f63957fce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada97c2afb746e33dd806af6f63957fce"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ada97c2afb746e33dd806af6f63957fce">triangular_matrix</a> = <a class="el" href="namespace_open_kalman.html#a05da5d495bfe6445599208b60bf12d69">lower_triangular_matrix</a>&lt;T&gt; or <a class="el" href="namespace_open_kalman.html#a5456de7a2e027daca692a5c72dc3540e">upper_triangular_matrix</a>&lt;T&gt;</td></tr>
<tr class="memdesc:ada97c2afb746e33dd806af6f63957fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a triangular matrix (upper or lower).  <a href="namespace_open_kalman.html#ada97c2afb746e33dd806af6f63957fce">More...</a><br /></td></tr>
<tr class="separator:ada97c2afb746e33dd806af6f63957fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2562e4c0918dc2cbf74de6a97d9388cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2562e4c0918dc2cbf74de6a97d9388cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2562e4c0918dc2cbf74de6a97d9388cf">cholesky_form</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__cholesky__form.html">internal::is_cholesky_form</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a2562e4c0918dc2cbf74de6a97d9388cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type has a nested native matrix that is a Cholesky square root.  <a href="namespace_open_kalman.html#a2562e4c0918dc2cbf74de6a97d9388cf">More...</a><br /></td></tr>
<tr class="separator:a2562e4c0918dc2cbf74de6a97d9388cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4a95b16bcf85246cc892ddf51cc9ddfa">element_gettable</a> = <a class="el" href="struct_open_kalman_1_1internal_1_1is__element__gettable.html">internal::is_element_gettable</a>&lt;std::decay_t&lt;T&gt;, N&gt;::value</td></tr>
<tr class="memdesc:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type has elements that can be retrieved with N number of indices.  <a href="namespace_open_kalman.html#a4a95b16bcf85246cc892ddf51cc9ddfa">More...</a><br /></td></tr>
<tr class="separator:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77329c3cd71568cac6bd18c3add8d0c"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ac77329c3cd71568cac6bd18c3add8d0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac77329c3cd71568cac6bd18c3add8d0c">element_settable</a></td></tr>
<tr class="memdesc:ac77329c3cd71568cac6bd18c3add8d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type has elements that can be set with N number of indices.  <a href="namespace_open_kalman.html#ac77329c3cd71568cac6bd18c3add8d0c">More...</a><br /></td></tr>
<tr class="separator:ac77329c3cd71568cac6bd18c3add8d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31943131d380f310b945dc9bac9f9a8a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a31943131d380f310b945dc9bac9f9a8a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a31943131d380f310b945dc9bac9f9a8a">modifiable</a></td></tr>
<tr class="memdesc:a31943131d380f310b945dc9bac9f9a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that U is not obviously incompatible with T, such that assigning U to T might be possible.  <a href="namespace_open_kalman.html#a31943131d380f310b945dc9bac9f9a8a">More...</a><br /></td></tr>
<tr class="separator:a31943131d380f310b945dc9bac9f9a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82301b5eacb294f1e37d3d90624921b"><td class="memTemplParams" colspan="2"><a id="ad82301b5eacb294f1e37d3d90624921b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad82301b5eacb294f1e37d3d90624921b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2">TriangleType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad82301b5eacb294f1e37d3d90624921b">triangle_type_of</a> = detail::triangle_type_of_impl&lt;T&gt;::value</td></tr>
<tr class="memdesc:ad82301b5eacb294f1e37d3d90624921b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derive the TriangleType from the type of the triangular_matrix. <br /></td></tr>
<tr class="separator:ad82301b5eacb294f1e37d3d90624921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac012d357f1dc0a72d7a6fb43d0169998"><td class="memTemplParams" colspan="2"><a id="ac012d357f1dc0a72d7a6fb43d0169998"></a>
template&lt;typename T , std::size_t order&gt; </td></tr>
<tr class="memitem:ac012d357f1dc0a72d7a6fb43d0169998"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac012d357f1dc0a72d7a6fb43d0169998">is_linearized_function_v</a> = <a class="el" href="struct_open_kalman_1_1is__linearized__function.html">is_linearized_function</a>&lt;T, order&gt;::value</td></tr>
<tr class="memdesc:ac012d357f1dc0a72d7a6fb43d0169998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="struct_open_kalman_1_1is__linearized__function.html" title="Whether an object is a linearized function (with defined Jacobian and optionally Hessian functions).">is_linearized_function</a>. <br /></td></tr>
<tr class="separator:ac012d357f1dc0a72d7a6fb43d0169998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7c1869fc91b766eb186c3b8a328644"><td class="memTemplParams" colspan="2"><a id="a0a7c1869fc91b766eb186c3b8a328644"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0a7c1869fc91b766eb186c3b8a328644"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0a7c1869fc91b766eb186c3b8a328644">transformation_input</a></td></tr>
<tr class="memdesc:a0a7c1869fc91b766eb186c3b8a328644"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a transformation input. <br /></td></tr>
<tr class="separator:a0a7c1869fc91b766eb186c3b8a328644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741c1e6dcd7c405a2f747e10fb2e2c02"><td class="memTemplParams" colspan="2"><a id="a741c1e6dcd7c405a2f747e10fb2e2c02"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a741c1e6dcd7c405a2f747e10fb2e2c02"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a741c1e6dcd7c405a2f747e10fb2e2c02">perturbation</a> = <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>&lt;T&gt; or <a class="el" href="namespace_open_kalman.html#a0a7c1869fc91b766eb186c3b8a328644">transformation_input</a>&lt;T&gt;</td></tr>
<tr class="memdesc:a741c1e6dcd7c405a2f747e10fb2e2c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a perturbation. <br /></td></tr>
<tr class="separator:a741c1e6dcd7c405a2f747e10fb2e2c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab6c606169452d88f33b64e3b1ae18fa2"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2">TriangleType</a> { <a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2a81e073b428b50247daba38531dcf412a">lower</a>
, <a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2a0122b4c2c01ee1c698ecc309d2b8eb5a">upper</a>
, <a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2aa0e17e2709a0404ae3d7de03b8ea9093">diagonal</a>
 }</td></tr>
<tr class="memdesc:ab6c606169452d88f33b64e3b1ae18fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a triangular matrix, either lower, upper, or diagonal.  <a href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2">More...</a><br /></td></tr>
<tr class="separator:ab6c606169452d88f33b64e3b1ae18fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Aliases</h2></td></tr>
<tr class="memitem:abc8e1017c2a892423e656ba212290b74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename MatrixTraits&lt;T&gt;::NestedMatrix&gt; </td></tr>
<tr class="memitem:abc8e1017c2a892423e656ba212290b74"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a> = typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; T &gt;::NestedMatrix</td></tr>
<tr class="memdesc:abc8e1017c2a892423e656ba212290b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a type's nested matrix, if it exists.  <a href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">More...</a><br /></td></tr>
<tr class="separator:abc8e1017c2a892423e656ba212290b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c4bdd289f65db14dd2eab442a4efc4"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t rows = MatrixTraits&lt;T&gt;::dimension, std::size_t cols = MatrixTraits&lt;T&gt;::columns, typename Scalar  = typename MatrixTraits&lt;T&gt;::Scalar&gt; </td></tr>
<tr class="memitem:a78c4bdd289f65db14dd2eab442a4efc4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a78c4bdd289f65db14dd2eab442a4efc4">native_matrix_t</a> = typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; T &gt;::template NativeMatrixFrom&lt; rows, cols, Scalar &gt;</td></tr>
<tr class="memdesc:a78c4bdd289f65db14dd2eab442a4efc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a self-contained native matrix, based on and equivalent to parameter T.  <a href="namespace_open_kalman.html#a78c4bdd289f65db14dd2eab442a4efc4">More...</a><br /></td></tr>
<tr class="separator:a78c4bdd289f65db14dd2eab442a4efc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e7a86630ddacf5420ddc348fbffa2d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46e7a86630ddacf5420ddc348fbffa2d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a46e7a86630ddacf5420ddc348fbffa2d">self_contained_t</a> = typename detail::self_contained_impl&lt; std::remove_reference_t&lt; T &gt; &gt;::type</td></tr>
<tr class="memdesc:a46e7a86630ddacf5420ddc348fbffa2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for type, derived from and equivalent to parameter T, that is self-contained.  <a href="namespace_open_kalman.html#a46e7a86630ddacf5420ddc348fbffa2d">More...</a><br /></td></tr>
<tr class="separator:a46e7a86630ddacf5420ddc348fbffa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6babcf2fe72766cbfef2c7082b606b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:aa6babcf2fe72766cbfef2c7082b606b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">passable_t</a> = std::conditional_t&lt; std::is_lvalue_reference_v&lt; T &gt;, T, <a class="el" href="namespace_open_kalman.html#a46e7a86630ddacf5420ddc348fbffa2d">self_contained_t</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:aa6babcf2fe72766cbfef2c7082b606b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a type, derived from and equivalent to parameter T, that can be passed as a function parameter.  <a href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">More...</a><br /></td></tr>
<tr class="separator:aa6babcf2fe72766cbfef2c7082b606b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66c8a3d2e7e2449a727d370262995ef"><td class="memTemplParams" colspan="2">template&lt;typename C , std::size_t N&gt; </td></tr>
<tr class="memitem:ac66c8a3d2e7e2449a727d370262995ef"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">Replicate</a> = typename detail::ReplicateImpl&lt; C, N &gt;::type</td></tr>
<tr class="memdesc:ac66c8a3d2e7e2449a727d370262995ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>Coefficients&lt;C...&gt;</code>, where <code>C</code> is repeated <em>N</em> times.  <a href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">More...</a><br /></td></tr>
<tr class="separator:ac66c8a3d2e7e2449a727d370262995ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fbe21f478b7b06ac97b6eb6f5967c3"><td class="memTemplParams" colspan="2">template&lt;std::size_t size&gt; </td></tr>
<tr class="memitem:ad7fbe21f478b7b06ac97b6eb6f5967c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a> = <a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">Replicate</a>&lt; <a class="el" href="struct_open_kalman_1_1_axis.html">Axis</a>, size &gt;</td></tr>
<tr class="memdesc:ad7fbe21f478b7b06ac97b6eb6f5967c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>Coefficients&lt;Axis...&gt;</code>, where <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> is repeated <code>size</code> times.  <a href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">More...</a><br /></td></tr>
<tr class="separator:ad7fbe21f478b7b06ac97b6eb6f5967c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098e86bc01897e4b391805799008a9f4"><td class="memTemplParams" colspan="2">template&lt;typename ... Coeffs&gt; </td></tr>
<tr class="memitem:a098e86bc01897e4b391805799008a9f4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a098e86bc01897e4b391805799008a9f4">Concatenate</a> = typename detail::ConcatenateImpl&lt; Coeffs... &gt;::type</td></tr>
<tr class="memdesc:a098e86bc01897e4b391805799008a9f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate any number of Coefficients&lt;...&gt; types.  <a href="namespace_open_kalman.html#a098e86bc01897e4b391805799008a9f4">More...</a><br /></td></tr>
<tr class="separator:a098e86bc01897e4b391805799008a9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0239f8b1168cde423e125102a257b3"><td class="memItemLeft" align="right" valign="top"><a id="a8b0239f8b1168cde423e125102a257b3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a8b0239f8b1168cde423e125102a257b3">UnscentedSigmaPoints</a> = SigmaPoints&lt; Unscented&lt;&gt; &gt;</td></tr>
<tr class="memdesc:a8b0239f8b1168cde423e125102a257b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as UnscentedSigmaPointsStateEstimation. <br /></td></tr>
<tr class="separator:a8b0239f8b1168cde423e125102a257b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab7f7071cb157c11253798720be5c7542"><td class="memTemplParams" colspan="2"><a id="ab7f7071cb157c11253798720be5c7542"></a>
template&lt;typename M , typename ... Args, std::enable_if_t&lt;(std::is_convertible_v&lt; Args, typename MatrixTraits&lt; M &gt;::Scalar &gt; and ...) and(sizeof...(Args)==MatrixTraits&lt; M &gt;::dimension *MatrixTraits&lt; M &gt;::columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab7f7071cb157c11253798720be5c7542"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab7f7071cb157c11253798720be5c7542">make_native_matrix</a> (const Args ... args)</td></tr>
<tr class="memdesc:ab7f7071cb157c11253798720be5c7542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a self-contained, native matrix based on the shape of M from a list of coefficients in row-major order. <br /></td></tr>
<tr class="separator:ab7f7071cb157c11253798720be5c7542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131455a38340a120002aca624717d3d4"><td class="memTemplParams" colspan="2">template&lt;typename D , std::enable_if_t&lt; gaussian_distribution&lt; D &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a131455a38340a120002aca624717d3d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a131455a38340a120002aca624717d3d4">make_GaussianDistribution</a> (D &amp;&amp;dist) noexcept</td></tr>
<tr class="memdesc:a131455a38340a120002aca624717d3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution.  <a href="namespace_open_kalman.html#a131455a38340a120002aca624717d3d4">More...</a><br /></td></tr>
<tr class="separator:a131455a38340a120002aca624717d3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="memTemplParams" colspan="2">template&lt;typename re  = std::mt19937, typename M , typename Cov , std::enable_if_t&lt;(not coefficients&lt; re &gt;) and typed_matrix&lt; M &gt; and column_vector&lt; M &gt; and untyped_columns&lt; M &gt; and square_matrix&lt; Cov &gt; and(covariance&lt; Cov &gt; or typed_matrix&lt; Cov &gt;) and(equivalent_to&lt; typename MatrixTraits&lt; M &gt;::RowCoefficients, typename MatrixTraits&lt; Cov &gt;::RowCoefficients &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac2d0c0d4d3f9bab0130dbcd6654617c0">make_GaussianDistribution</a> (M &amp;&amp;<a class="el" href="namespace_open_kalman.html#a2745b3bfff7250ac8d9e0dc79902508c">mean</a>, Cov &amp;&amp;cov) noexcept</td></tr>
<tr class="memdesc:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution.  <a href="namespace_open_kalman.html#ac2d0c0d4d3f9bab0130dbcd6654617c0">More...</a><br /></td></tr>
<tr class="separator:ac2d0c0d4d3f9bab0130dbcd6654617c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f53ae8006d8068435df09f99c8baf0"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename re  = std::mt19937, typename M , typename Cov , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and column_vector&lt; M &gt; and(covariance_nestable&lt; Cov &gt; or typed_matrix_nestable&lt; Cov &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a87f53ae8006d8068435df09f99c8baf0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a87f53ae8006d8068435df09f99c8baf0">make_GaussianDistribution</a> (M &amp;&amp;<a class="el" href="namespace_open_kalman.html#a2745b3bfff7250ac8d9e0dc79902508c">mean</a>, Cov &amp;&amp;cov) noexcept</td></tr>
<tr class="memdesc:a87f53ae8006d8068435df09f99c8baf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution.  <a href="namespace_open_kalman.html#a87f53ae8006d8068435df09f99c8baf0">More...</a><br /></td></tr>
<tr class="separator:a87f53ae8006d8068435df09f99c8baf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a419b046972de2b566cc220dcae618"><td class="memTemplParams" colspan="2">template&lt;typename M , typename Cov , typename re  = std::mt19937, std::enable_if_t&lt; typed_matrix&lt; M &gt; and column_vector&lt; M &gt; and untyped_columns&lt; M &gt; and covariance&lt; Cov &gt; and equivalent_to&lt; typename MatrixTraits&lt; M &gt;::RowCoefficients, typename MatrixTraits&lt; Cov &gt;::RowCoefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a30a419b046972de2b566cc220dcae618"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a30a419b046972de2b566cc220dcae618">make_GaussianDistribution</a> ()</td></tr>
<tr class="memdesc:a30a419b046972de2b566cc220dcae618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default Gaussian distribution.  <a href="namespace_open_kalman.html#a30a419b046972de2b566cc220dcae618">More...</a><br /></td></tr>
<tr class="separator:a30a419b046972de2b566cc220dcae618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c01a83c83d3a23aafb59dcd527daed1"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename M , typename Cov , typename re  = std::mt19937, std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt; and column_vector&lt; M &gt; and covariance_nestable&lt; Cov &gt; and(MatrixTraits&lt; M &gt;::dimension==MatrixTraits&lt; Cov &gt;::dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8c01a83c83d3a23aafb59dcd527daed1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a8c01a83c83d3a23aafb59dcd527daed1">make_GaussianDistribution</a> ()</td></tr>
<tr class="memdesc:a8c01a83c83d3a23aafb59dcd527daed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default Gaussian distribution.  <a href="namespace_open_kalman.html#a8c01a83c83d3a23aafb59dcd527daed1">More...</a><br /></td></tr>
<tr class="separator:a8c01a83c83d3a23aafb59dcd527daed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad137ac22381d6cd2d06a57b96a3f4a83"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename Arg , std::enable_if_t&lt; gaussian_distribution&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad137ac22381d6cd2d06a57b96a3f4a83"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad137ac22381d6cd2d06a57b96a3f4a83">make_self_contained</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:ad137ac22381d6cd2d06a57b96a3f4a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to self-contained version of the distribution.  <a href="namespace_open_kalman.html#ad137ac22381d6cd2d06a57b96a3f4a83">More...</a><br /></td></tr>
<tr class="separator:ad137ac22381d6cd2d06a57b96a3f4a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="memTemplParams" colspan="2"><a id="a6656a830ae8f0446ec8f3bfe5159a90f"></a>
template&lt;typename ... Cs, typename D , std::enable_if_t&lt; gaussian_distribution&lt; D &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6656a830ae8f0446ec8f3bfe5159a90f">split</a> (D &amp;&amp;d) noexcept</td></tr>
<tr class="memdesc:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split distribution. <br /></td></tr>
<tr class="separator:a6656a830ae8f0446ec8f3bfe5159a90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b797c590b3e19ce373b02f7237e4bb1"><td class="memTemplParams" colspan="2"><a id="a4b797c590b3e19ce373b02f7237e4bb1"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4b797c590b3e19ce373b02f7237e4bb1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4b797c590b3e19ce373b02f7237e4bb1">Mean</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; sizeof...(Args)&gt;, Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, sizeof...(Args), 1 &gt;&gt;</td></tr>
<tr class="memdesc:a4b797c590b3e19ce373b02f7237e4bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, deduce a single-column mean with all <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients. <br /></td></tr>
<tr class="separator:a4b797c590b3e19ce373b02f7237e4bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299661af360b08bf64b104c3376f9126"><td class="memTemplParams" colspan="2"><a id="a299661af360b08bf64b104c3376f9126"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a299661af360b08bf64b104c3376f9126"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a299661af360b08bf64b104c3376f9126">EuclideanMean</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">OpenKalman::Axes</a>&lt; sizeof...(Args)&gt;, Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, sizeof...(Args), 1 &gt;&gt;</td></tr>
<tr class="memdesc:a299661af360b08bf64b104c3376f9126"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, construct a single-column Euclidean mean. <br /></td></tr>
<tr class="separator:a299661af360b08bf64b104c3376f9126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c706282524a9765f4fe3cea62fc99c6"><td class="memTemplParams" colspan="2"><a id="a2c706282524a9765f4fe3cea62fc99c6"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2c706282524a9765f4fe3cea62fc99c6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2c706282524a9765f4fe3cea62fc99c6">Covariance</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">internal::constexpr_sqrt</a>(sizeof...(Args))&gt;, <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">Eigen3::SelfAdjointMatrix</a>&lt; Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">internal::constexpr_sqrt</a>(sizeof...(Args)), <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">internal::constexpr_sqrt</a>(sizeof...(Args))&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a2c706282524a9765f4fe3cea62fc99c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, derive a square, self-adjoint matrix. <br /></td></tr>
<tr class="separator:a2c706282524a9765f4fe3cea62fc99c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad575f1ca1f80d5beb7016d6e6ab31790"><td class="memTemplParams" colspan="2"><a id="ad575f1ca1f80d5beb7016d6e6ab31790"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad575f1ca1f80d5beb7016d6e6ab31790"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad575f1ca1f80d5beb7016d6e6ab31790">SquareRootCovariance</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html">SquareRootCovariance</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">internal::constexpr_sqrt</a>(sizeof...(Args))&gt;, <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_triangular_matrix.html">Eigen3::TriangularMatrix</a>&lt; Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">OpenKalman::internal::constexpr_sqrt</a>(sizeof...(Args)), <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">OpenKalman::internal::constexpr_sqrt</a>(sizeof...(Args))&gt;&gt;&gt;</td></tr>
<tr class="memdesc:ad575f1ca1f80d5beb7016d6e6ab31790"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, derive a square, lower triangular matrix. <br /></td></tr>
<tr class="separator:ad575f1ca1f80d5beb7016d6e6ab31790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac70867ae2a7c599ef94a187b72a34eb"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; covariance_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aac70867ae2a7c599ef94a187b72a34eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aac70867ae2a7c599ef94a187b72a34eb">Covariance</a> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">passable_t</a>&lt; M &gt;&gt;</td></tr>
<tr class="memdesc:aac70867ae2a7c599ef94a187b72a34eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> type from a <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>.  <a href="namespace_open_kalman.html#aac70867ae2a7c599ef94a187b72a34eb">More...</a><br /></td></tr>
<tr class="separator:aac70867ae2a7c599ef94a187b72a34eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1167376779e08b44911a5b18134ba1d4"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and covariance_nestable&lt; Arg &gt; and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1167376779e08b44911a5b18134ba1d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1167376779e08b44911a5b18134ba1d4">make_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a1167376779e08b44911a5b18134ba1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>, specifying the coefficients.  <a href="namespace_open_kalman.html#a1167376779e08b44911a5b18134ba1d4">More...</a><br /></td></tr>
<tr class="separator:a1167376779e08b44911a5b18134ba1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae21ef7c840cf37fb755618dd419a221"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and covariance_nestable&lt; Arg &gt; and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension) and(triangle_type !=TriangleType::lower or lower_triangular_matrix&lt; Arg &gt;) and(triangle_type !=TriangleType::upper or upper_triangular_matrix&lt; Arg &gt;) and(triangle_type !=TriangleType::diagonal or diagonal_matrix&lt; Arg &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aae21ef7c840cf37fb755618dd419a221"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aae21ef7c840cf37fb755618dd419a221">make_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:aae21ef7c840cf37fb755618dd419a221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>, specifying the coefficients.  <a href="namespace_open_kalman.html#aae21ef7c840cf37fb755618dd419a221">More...</a><br /></td></tr>
<tr class="separator:aae21ef7c840cf37fb755618dd419a221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1367d0df6f272ee442c2272a228ab8"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance_nestable&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8b1367d0df6f272ee442c2272a228ab8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a8b1367d0df6f272ee442c2272a228ab8">make_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a8b1367d0df6f272ee442c2272a228ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>, with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.  <a href="namespace_open_kalman.html#a8b1367d0df6f272ee442c2272a228ab8">More...</a><br /></td></tr>
<tr class="separator:a8b1367d0df6f272ee442c2272a228ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e11974581182d024289c3df6f00e92b"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6e11974581182d024289c3df6f00e92b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6e11974581182d024289c3df6f00e92b">make_covariance</a> ()</td></tr>
<tr class="memdesc:a6e11974581182d024289c3df6f00e92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a> or <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.  <a href="namespace_open_kalman.html#a6e11974581182d024289c3df6f00e92b">More...</a><br /></td></tr>
<tr class="separator:a6e11974581182d024289c3df6f00e92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f4317db70b740a4b05b154ea7d144e"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a74f4317db70b740a4b05b154ea7d144e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a74f4317db70b740a4b05b154ea7d144e">make_covariance</a> ()</td></tr>
<tr class="memdesc:a74f4317db70b740a4b05b154ea7d144e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> with a nested triangular matrix, from a <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.  <a href="namespace_open_kalman.html#a74f4317db70b740a4b05b154ea7d144e">More...</a><br /></td></tr>
<tr class="separator:a74f4317db70b740a4b05b154ea7d144e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82a27123450aa0fd5266c332bde0362"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af82a27123450aa0fd5266c332bde0362"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af82a27123450aa0fd5266c332bde0362">make_covariance</a> ()</td></tr>
<tr class="memdesc:af82a27123450aa0fd5266c332bde0362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a> or <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>.  <a href="namespace_open_kalman.html#af82a27123450aa0fd5266c332bde0362">More...</a><br /></td></tr>
<tr class="separator:af82a27123450aa0fd5266c332bde0362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f2335ea8a758c0b229c54cadc27aa1"><td class="memTemplParams" colspan="2">template&lt;typename M , typename S , std::enable_if_t&lt; covariance&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a77f2335ea8a758c0b229c54cadc27aa1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a> (M &amp;&amp;m, const S s)</td></tr>
<tr class="separator:a77f2335ea8a758c0b229c54cadc27aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f44bd141f1e2b9b65432a633d9180e2"><td class="memTemplParams" colspan="2">template&lt;typename M , typename S , std::enable_if_t&lt; covariance&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6f44bd141f1e2b9b65432a633d9180e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6f44bd141f1e2b9b65432a633d9180e2">inverse_scale</a> (M &amp;&amp;m, const S s)</td></tr>
<tr class="separator:a6f44bd141f1e2b9b65432a633d9180e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be486e53ad3cb44d7ea46c4201f4ce5"><td class="memTemplParams" colspan="2">template&lt;typename M , typename A , std::enable_if_t&lt; covariance&lt; M &gt; and typed_matrix&lt; A &gt; and equivalent_to&lt; typename MatrixTraits&lt; A &gt;::ColumnCoefficients, typename MatrixTraits&lt; M &gt;::RowCoefficients &gt; and(not euclidean_transformed&lt; A &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3be486e53ad3cb44d7ea46c4201f4ce5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3be486e53ad3cb44d7ea46c4201f4ce5">scale</a> (M &amp;&amp;m, A &amp;&amp;a)</td></tr>
<tr class="memdesc:a3be486e53ad3cb44d7ea46c4201f4ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a covariance by a matrix.  <a href="namespace_open_kalman.html#a3be486e53ad3cb44d7ea46c4201f4ce5">More...</a><br /></td></tr>
<tr class="separator:a3be486e53ad3cb44d7ea46c4201f4ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd840cc6cadb87e6bae5724c66b575a9"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acd840cc6cadb87e6bae5724c66b575a9"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#acd840cc6cadb87e6bae5724c66b575a9">make_native_matrix</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:acd840cc6cadb87e6bae5724c66b575a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef70489b68fd02e29dc2210aeaa4311"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , std::enable_if_t&lt; covariance&lt; A &gt; and typed_matrix&lt; B &gt; and equivalent_to&lt; typename MatrixTraits&lt; A &gt;::RowCoefficients, typename MatrixTraits&lt; B &gt;::RowCoefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3ef70489b68fd02e29dc2210aeaa4311"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3ef70489b68fd02e29dc2210aeaa4311">solve</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept</td></tr>
<tr class="memdesc:a3ef70489b68fd02e29dc2210aeaa4311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a x = b for x (A is a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>, B is a vector type).  <a href="namespace_open_kalman.html#a3ef70489b68fd02e29dc2210aeaa4311">More...</a><br /></td></tr>
<tr class="separator:a3ef70489b68fd02e29dc2210aeaa4311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8ce92ebb39445ad24273396c57ff0b"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0c8ce92ebb39445ad24273396c57ff0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0c8ce92ebb39445ad24273396c57ff0b">LQ_decomposition</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a0c8ce92ebb39445ad24273396c57ff0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c53f3473e7552a36723afca9d5588ad"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2c53f3473e7552a36723afca9d5588ad"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2c53f3473e7552a36723afca9d5588ad">QR_decomposition</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a2c53f3473e7552a36723afca9d5588ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="memTemplParams" colspan="2"><a id="a82c47a34ff6b7584fb93a6ede9db6a12"></a>
template&lt;typename M , typename ... Ms, std::enable_if_t&lt;(covariance&lt; M &gt; and ... and covariance&lt; Ms &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a82c47a34ff6b7584fb93a6ede9db6a12">concatenate</a> (M &amp;&amp;m, Ms &amp;&amp;... mN) noexcept</td></tr>
<tr class="memdesc:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> objects diagonally. <br /></td></tr>
<tr class="separator:a82c47a34ff6b7584fb93a6ede9db6a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf46841af75eee02bfd52c1708831b7"><td class="memTemplParams" colspan="2">template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2bf46841af75eee02bfd52c1708831b7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2bf46841af75eee02bfd52c1708831b7">split_diagonal</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a2bf46841af75eee02bfd52c1708831b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> diagonally.  <a href="namespace_open_kalman.html#a2bf46841af75eee02bfd52c1708831b7">More...</a><br /></td></tr>
<tr class="separator:a2bf46841af75eee02bfd52c1708831b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dba71f80c4270929d21e416f1c8739"><td class="memTemplParams" colspan="2">template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a68dba71f80c4270929d21e416f1c8739"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a68dba71f80c4270929d21e416f1c8739">split_vertical</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a68dba71f80c4270929d21e416f1c8739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> vertically. Result is a tuple of typed matrices.  <a href="namespace_open_kalman.html#a68dba71f80c4270929d21e416f1c8739">More...</a><br /></td></tr>
<tr class="separator:a68dba71f80c4270929d21e416f1c8739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313e2b8a742da23f4623c6bc4c295d5b"><td class="memTemplParams" colspan="2">template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a313e2b8a742da23f4623c6bc4c295d5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a313e2b8a742da23f4623c6bc4c295d5b">split_horizontal</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a313e2b8a742da23f4623c6bc4c295d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> or <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> vertically. Result is a tuple of typed matrices.  <a href="namespace_open_kalman.html#a313e2b8a742da23f4623c6bc4c295d5b">More...</a><br /></td></tr>
<tr class="separator:a313e2b8a742da23f4623c6bc4c295d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9f83dc120f7424fe949f401344960e"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt; and element_gettable&lt; Arg, 2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aab9f83dc120f7424fe949f401344960e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aab9f83dc120f7424fe949f401344960e">get_element</a> (Arg &amp;&amp;arg, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:aab9f83dc120f7424fe949f401344960e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i, j) of a covariance matrix.  <a href="namespace_open_kalman.html#aab9f83dc120f7424fe949f401344960e">More...</a><br /></td></tr>
<tr class="separator:aab9f83dc120f7424fe949f401344960e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed81d91202d9b998733a3be06de9910"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt; and element_gettable&lt; Arg, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7ed81d91202d9b998733a3be06de9910"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a7ed81d91202d9b998733a3be06de9910">get_element</a> (Arg &amp;&amp;arg, const std::size_t i)</td></tr>
<tr class="memdesc:a7ed81d91202d9b998733a3be06de9910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i) of a covariance matrix.  <a href="namespace_open_kalman.html#a7ed81d91202d9b998733a3be06de9910">More...</a><br /></td></tr>
<tr class="separator:a7ed81d91202d9b998733a3be06de9910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d576e04f45d8081c586f69f8b7f96f"><td class="memTemplParams" colspan="2"><a id="ab5d576e04f45d8081c586f69f8b7f96f"></a>
template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; covariance&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and element_settable&lt; Arg, 2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab5d576e04f45d8081c586f69f8b7f96f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab5d576e04f45d8081c586f69f8b7f96f">set_element</a> (Arg &amp;arg, const Scalar s, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:ab5d576e04f45d8081c586f69f8b7f96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i, j) of a covariance matrix. <br /></td></tr>
<tr class="separator:ab5d576e04f45d8081c586f69f8b7f96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a86339bc79fa01578464985b73e03a5"><td class="memTemplParams" colspan="2"><a id="a1a86339bc79fa01578464985b73e03a5"></a>
template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; covariance&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and element_settable&lt; Arg, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1a86339bc79fa01578464985b73e03a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1a86339bc79fa01578464985b73e03a5">set_element</a> (Arg &amp;arg, const Scalar s, const std::size_t i)</td></tr>
<tr class="memdesc:a1a86339bc79fa01578464985b73e03a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i) of a covariance matrix. <br /></td></tr>
<tr class="separator:a1a86339bc79fa01578464985b73e03a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cf22b04919ddaac53d9296aa77be2d"><td class="memTemplParams" colspan="2"><a id="a38cf22b04919ddaac53d9296aa77be2d"></a>
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a38cf22b04919ddaac53d9296aa77be2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a38cf22b04919ddaac53d9296aa77be2d">column</a> (Arg &amp;&amp;arg, const std::size_t index)</td></tr>
<tr class="memdesc:a38cf22b04919ddaac53d9296aa77be2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column <code>index</code> of Arg. <br /></td></tr>
<tr class="separator:a38cf22b04919ddaac53d9296aa77be2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="memTemplParams" colspan="2"><a id="a6e7e42a6fae7659f1f67c68979ba9a95"></a>
template&lt;std::size_t index, typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6e7e42a6fae7659f1f67c68979ba9a95">column</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column <code>index</code> of Arg. Constexpr index version. <br /></td></tr>
<tr class="separator:a6e7e42a6fae7659f1f67c68979ba9a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039f354d5cd736da949ab03453e8e7ec"><td class="memTemplParams" colspan="2"><a id="a039f354d5cd736da949ab03453e8e7ec"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; typed_matrix&lt; V1 &gt; and typed_matrix&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a039f354d5cd736da949ab03453e8e7ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a039f354d5cd736da949ab03453e8e7ec">operator+</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a039f354d5cd736da949ab03453e8e7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two typed matrices. If the operands are of different types, the result will be a regular typed matrix. <br /></td></tr>
<tr class="separator:a039f354d5cd736da949ab03453e8e7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e926152518ac5b9857395881d6495f7"><td class="memTemplParams" colspan="2"><a id="a2e926152518ac5b9857395881d6495f7"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; typed_matrix&lt; V1 &gt; and typed_matrix&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2e926152518ac5b9857395881d6495f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2e926152518ac5b9857395881d6495f7">operator-</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a2e926152518ac5b9857395881d6495f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two typed matrices. The result is a regular typed matrix unless both operands are <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>. <br /></td></tr>
<tr class="separator:a2e926152518ac5b9857395881d6495f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aeb063fca8bd5a6714e9a46749e706"><td class="memTemplParams" colspan="2"><a id="a20aeb063fca8bd5a6714e9a46749e706"></a>
template&lt;typename V , typename S , std::enable_if_t&lt; typed_matrix&lt; V &gt; and std::is_convertible_v&lt; S, const typename MatrixTraits&lt; V &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a20aeb063fca8bd5a6714e9a46749e706"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a20aeb063fca8bd5a6714e9a46749e706">operator*</a> (V &amp;&amp;v, S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>)</td></tr>
<tr class="memdesc:a20aeb063fca8bd5a6714e9a46749e706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a typed matrix by a scalar. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:a20aeb063fca8bd5a6714e9a46749e706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3928da684e7a5ef385a77828f3c3cc14"><td class="memTemplParams" colspan="2"><a id="a3928da684e7a5ef385a77828f3c3cc14"></a>
template&lt;typename V , typename S , std::enable_if_t&lt; typed_matrix&lt; V &gt; and std::is_convertible_v&lt; S, const typename MatrixTraits&lt; V &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3928da684e7a5ef385a77828f3c3cc14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3928da684e7a5ef385a77828f3c3cc14">operator*</a> (S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>, V &amp;&amp;v)</td></tr>
<tr class="memdesc:a3928da684e7a5ef385a77828f3c3cc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a scalar by a typed matrix. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:a3928da684e7a5ef385a77828f3c3cc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b0a24352923b27433819ba40b6394c"><td class="memTemplParams" colspan="2"><a id="a82b0a24352923b27433819ba40b6394c"></a>
template&lt;typename V , typename S , std::enable_if_t&lt; typed_matrix&lt; V &gt; and std::is_convertible_v&lt; S, const typename MatrixTraits&lt; V &gt;::Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a82b0a24352923b27433819ba40b6394c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a82b0a24352923b27433819ba40b6394c">operator/</a> (V &amp;&amp;v, S <a class="el" href="namespace_open_kalman.html#a77f2335ea8a758c0b229c54cadc27aa1">scale</a>)</td></tr>
<tr class="memdesc:a82b0a24352923b27433819ba40b6394c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a typed matrix by a scalar. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:a82b0a24352923b27433819ba40b6394c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51481c7e308adfcf8f33c4891f35618"><td class="memTemplParams" colspan="2"><a id="ae51481c7e308adfcf8f33c4891f35618"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; typed_matrix&lt; V1 &gt; and typed_matrix&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae51481c7e308adfcf8f33c4891f35618"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae51481c7e308adfcf8f33c4891f35618">operator*</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:ae51481c7e308adfcf8f33c4891f35618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a typed matrix by another typed matrix. The result is a regular typed matrix unless the first operand is <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>. <br /></td></tr>
<tr class="separator:ae51481c7e308adfcf8f33c4891f35618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eaac6005b36334fa28a5c223cbe545"><td class="memTemplParams" colspan="2"><a id="a08eaac6005b36334fa28a5c223cbe545"></a>
template&lt;typename V , std::enable_if_t&lt; typed_matrix&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a08eaac6005b36334fa28a5c223cbe545"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a08eaac6005b36334fa28a5c223cbe545">operator-</a> (V &amp;&amp;v)</td></tr>
<tr class="memdesc:a08eaac6005b36334fa28a5c223cbe545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate a vector object. The result is a regular typed matrix unless the operand is <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>. <br /></td></tr>
<tr class="separator:a08eaac6005b36334fa28a5c223cbe545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba759789716e968b7d516cfc2c2efe8"><td class="memTemplParams" colspan="2"><a id="a5ba759789716e968b7d516cfc2c2efe8"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; typed_matrix&lt; V1 &gt; and typed_matrix&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5ba759789716e968b7d516cfc2c2efe8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5ba759789716e968b7d516cfc2c2efe8">operator==</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a5ba759789716e968b7d516cfc2c2efe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator. <br /></td></tr>
<tr class="separator:a5ba759789716e968b7d516cfc2c2efe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="memTemplParams" colspan="2"><a id="ac245a6153e8c8dee4c412d9a86e70b9b"></a>
template&lt;typename V1 , typename V2 , std::enable_if_t&lt; typed_matrix&lt; V1 &gt; and typed_matrix&lt; V2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac245a6153e8c8dee4c412d9a86e70b9b">operator!=</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator. <br /></td></tr>
<tr class="separator:ac245a6153e8c8dee4c412d9a86e70b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64ea73d28077cecfc217139a9d77813"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and((MatrixTraits&lt; Arg &gt;::columns==1) or untyped_columns&lt; Arg &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af64ea73d28077cecfc217139a9d77813"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af64ea73d28077cecfc217139a9d77813">reduce_columns</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:af64ea73d28077cecfc217139a9d77813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean of the column vectors after they are transformed into Euclidean space.  <a href="namespace_open_kalman.html#af64ea73d28077cecfc217139a9d77813">More...</a><br /></td></tr>
<tr class="separator:af64ea73d28077cecfc217139a9d77813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6f25c9190e4658793bb610b179bbc9"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; typed_matrix&lt; A &gt; and(not euclidean_transformed&lt; A &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0e6f25c9190e4658793bb610b179bbc9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0e6f25c9190e4658793bb610b179bbc9">LQ_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:a0e6f25c9190e4658793bb610b179bbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c9b539547601ae4b033c3ffe425b5b"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; typed_matrix&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae8c9b539547601ae4b033c3ffe425b5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae8c9b539547601ae4b033c3ffe425b5b">QR_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:ae8c9b539547601ae4b033c3ffe425b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07f38b9b803ce7be54501d6899eebb1"><td class="memTemplParams" colspan="2"><a id="ac07f38b9b803ce7be54501d6899eebb1"></a>
template&lt;typename V , typename ... Vs, std::enable_if_t&lt;(typed_matrix&lt; V &gt; and ... and typed_matrix&lt; Vs &gt;) and((sizeof...(Vs)==0) or(equivalent_to&lt; typename MatrixTraits&lt; V &gt;::ColumnCoefficients, typename MatrixTraits&lt; Vs &gt;::ColumnCoefficients &gt; and ...)), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac07f38b9b803ce7be54501d6899eebb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac07f38b9b803ce7be54501d6899eebb1">concatenate_vertical</a> (V &amp;&amp;v, Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:ac07f38b9b803ce7be54501d6899eebb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more typed matrices objects vertically. <br /></td></tr>
<tr class="separator:ac07f38b9b803ce7be54501d6899eebb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16f5d48f74dec8a73700b18a26e94b3"><td class="memTemplParams" colspan="2"><a id="ae16f5d48f74dec8a73700b18a26e94b3"></a>
template&lt;typename ... Vs, std::enable_if_t&lt;(typed_matrix&lt; Vs &gt; and ...), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae16f5d48f74dec8a73700b18a26e94b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae16f5d48f74dec8a73700b18a26e94b3">concatenate</a> (Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:ae16f5d48f74dec8a73700b18a26e94b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more typed matrices vertically. (Synonym for concatenate_vertical.) <br /></td></tr>
<tr class="separator:ae16f5d48f74dec8a73700b18a26e94b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c5157500f9c2c2018697ce9fd276d5"><td class="memTemplParams" colspan="2"><a id="ac3c5157500f9c2c2018697ce9fd276d5"></a>
template&lt;typename V , typename ... Vs, std::enable_if_t&lt;(typed_matrix&lt; V &gt; and ... and typed_matrix&lt; Vs &gt;) and((sizeof...(Vs)==0) or(equivalent_to&lt; typename MatrixTraits&lt; V &gt;::RowCoefficients, typename MatrixTraits&lt; Vs &gt;::RowCoefficients &gt; and ...)), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac3c5157500f9c2c2018697ce9fd276d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac3c5157500f9c2c2018697ce9fd276d5">concatenate_horizontal</a> (V &amp;&amp;v, Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:ac3c5157500f9c2c2018697ce9fd276d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more matrix objects vertically. <br /></td></tr>
<tr class="separator:ac3c5157500f9c2c2018697ce9fd276d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba340bb29158708cf93b6e103fbcd6e"><td class="memTemplParams" colspan="2"><a id="acba340bb29158708cf93b6e103fbcd6e"></a>
template&lt;typename V , typename ... Vs, std::enable_if_t&lt;(typed_matrix&lt; V &gt; and ... and typed_matrix&lt; Vs &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acba340bb29158708cf93b6e103fbcd6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#acba340bb29158708cf93b6e103fbcd6e">concatenate_diagonal</a> (V &amp;&amp;v, Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:acba340bb29158708cf93b6e103fbcd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more typed matrices diagonally. <br /></td></tr>
<tr class="separator:acba340bb29158708cf93b6e103fbcd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac00857e744721c29956a56550892a08"><td class="memTemplParams" colspan="2"><a id="aac00857e744721c29956a56550892a08"></a>
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and element_settable&lt; nested_matrix_t&lt; Arg &gt;, 2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aac00857e744721c29956a56550892a08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aac00857e744721c29956a56550892a08">set_element</a> (Arg &amp;arg, const typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; Arg &gt;::Scalar s, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:aac00857e744721c29956a56550892a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i, j) of a typed matrix. <br /></td></tr>
<tr class="separator:aac00857e744721c29956a56550892a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd804a52e5750b0be9c60a34a1c3323"><td class="memTemplParams" colspan="2"><a id="a4fd804a52e5750b0be9c60a34a1c3323"></a>
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and element_settable&lt; nested_matrix_t&lt; Arg &gt;, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4fd804a52e5750b0be9c60a34a1c3323"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4fd804a52e5750b0be9c60a34a1c3323">set_element</a> (Arg &amp;arg, const typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; Arg &gt;::Scalar s, const std::size_t i)</td></tr>
<tr class="memdesc:a4fd804a52e5750b0be9c60a34a1c3323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i) of a typed matrix. <br /></td></tr>
<tr class="separator:a4fd804a52e5750b0be9c60a34a1c3323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2366114bcb1637da7288fb572e738e"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , template&lt; typename Scalar &gt; typename distribution_type = std::normal_distribution, typename random_number_engine  = std::mt19937, typename... Params, std::enable_if_t&lt; typed_matrix&lt; ReturnType &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1b2366114bcb1637da7288fb572e738e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1b2366114bcb1637da7288fb572e738e">randomize</a> (Params...params)</td></tr>
<tr class="separator:a1b2366114bcb1637da7288fb572e738e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545052d9d62e60171a20c7704d65b1a0"><td class="memTemplParams" colspan="2"><a id="a545052d9d62e60171a20c7704d65b1a0"></a>
template&lt;typename V , std::enable_if_t&lt; typed_matrix&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a545052d9d62e60171a20c7704d65b1a0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a545052d9d62e60171a20c7704d65b1a0">operator&lt;&lt;</a> (std::ostream &amp;os, const V &amp;v)</td></tr>
<tr class="memdesc:a545052d9d62e60171a20c7704d65b1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the vector to a stream. <br /></td></tr>
<tr class="separator:a545052d9d62e60171a20c7704d65b1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d51334a0d4ec5eecd1fbc6a7570ae72"><td class="memTemplParams" colspan="2">template&lt;typename V , std::enable_if_t&lt; typed_matrix&lt; V &gt; and not euclidean_transformed&lt; V &gt; and untyped_columns&lt; V &gt; and MatrixTraits&lt; V &gt;::RowCoefficients::dimension==MatrixTraits&lt; V &gt;::dimension, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0d51334a0d4ec5eecd1fbc6a7570ae72"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a0d51334a0d4ec5eecd1fbc6a7570ae72">EuclideanMean</a> (V &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::RowCoefficients, decltype(to_euclidean&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::RowCoefficients &gt;(std::forward&lt; V &gt;(std::declval&lt; V &gt;()).nested_matrix()))&gt;</td></tr>
<tr class="memdesc:a0d51334a0d4ec5eecd1fbc6a7570ae72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a non-Euclidean-transformed typed matrix.  <a href="namespace_open_kalman.html#a0d51334a0d4ec5eecd1fbc6a7570ae72">More...</a><br /></td></tr>
<tr class="separator:a0d51334a0d4ec5eecd1fbc6a7570ae72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48c0170c781745c5abc1e13f83777d3"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::dimension==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa48c0170c781745c5abc1e13f83777d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aa48c0170c781745c5abc1e13f83777d3">make_euclidean_mean</a> (M &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:aa48c0170c781745c5abc1e13f83777d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> from a typed_matrix_nestable, specifying the row coefficients.  <a href="namespace_open_kalman.html#aa48c0170c781745c5abc1e13f83777d3">More...</a><br /></td></tr>
<tr class="separator:aa48c0170c781745c5abc1e13f83777d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6687a8e5791a070fb3bb625687f4b7"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3d6687a8e5791a070fb3bb625687f4b7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3d6687a8e5791a070fb3bb625687f4b7">make_euclidean_mean</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:a3d6687a8e5791a070fb3bb625687f4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> from a typed_matrix_nestable object, with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.  <a href="namespace_open_kalman.html#a3d6687a8e5791a070fb3bb625687f4b7">More...</a><br /></td></tr>
<tr class="separator:a3d6687a8e5791a070fb3bb625687f4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51161ea0e106d97f06ca53662029bf7a"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and untyped_columns&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a51161ea0e106d97f06ca53662029bf7a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a51161ea0e106d97f06ca53662029bf7a">make_euclidean_mean</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a51161ea0e106d97f06ca53662029bf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> from another typed_matrix.  <a href="namespace_open_kalman.html#a51161ea0e106d97f06ca53662029bf7a">More...</a><br /></td></tr>
<tr class="separator:a51161ea0e106d97f06ca53662029bf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae62cc2a04ec13fe3c3a71f9326b4637"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::dimension==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aae62cc2a04ec13fe3c3a71f9326b4637"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aae62cc2a04ec13fe3c3a71f9326b4637">make_euclidean_mean</a> ()</td></tr>
<tr class="memdesc:aae62cc2a04ec13fe3c3a71f9326b4637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, self-contained <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>.  <a href="namespace_open_kalman.html#aae62cc2a04ec13fe3c3a71f9326b4637">More...</a><br /></td></tr>
<tr class="separator:aae62cc2a04ec13fe3c3a71f9326b4637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc328414ecb720005c3c813be752ec3"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3dc328414ecb720005c3c813be752ec3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3dc328414ecb720005c3c813be752ec3">make_euclidean_mean</a> ()</td></tr>
<tr class="memdesc:a3dc328414ecb720005c3c813be752ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a self-contained <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.  <a href="namespace_open_kalman.html#a3dc328414ecb720005c3c813be752ec3">More...</a><br /></td></tr>
<tr class="separator:a3dc328414ecb720005c3c813be752ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67371d0db0c89c7d13983f48b94d66ea"><td class="memTemplParams" colspan="2"><a id="a67371d0db0c89c7d13983f48b94d66ea"></a>
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a67371d0db0c89c7d13983f48b94d66ea"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a67371d0db0c89c7d13983f48b94d66ea">Matrix</a> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_matrix.html">Matrix</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::columns &gt;, <a class="el" href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">passable_t</a>&lt; M &gt;&gt;</td></tr>
<tr class="memdesc:a67371d0db0c89c7d13983f48b94d66ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce parameter types from a typed_matrix_nestable. <br /></td></tr>
<tr class="separator:a67371d0db0c89c7d13983f48b94d66ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff013f3acace99fb1191fd677bdaba67"><td class="memTemplParams" colspan="2">template&lt;typename V , std::enable_if_t&lt; typed_matrix&lt; V &gt; and not euclidean_transformed&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aff013f3acace99fb1191fd677bdaba67"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#aff013f3acace99fb1191fd677bdaba67">Matrix</a> (V &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_matrix.html">Matrix</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::RowCoefficients, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::ColumnCoefficients, <a class="el" href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">passable_t</a>&lt; <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a>&lt; V &gt;&gt;&gt;</td></tr>
<tr class="memdesc:aff013f3acace99fb1191fd677bdaba67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a non-Euclidean-transformed typed matrix.  <a href="namespace_open_kalman.html#aff013f3acace99fb1191fd677bdaba67">More...</a><br /></td></tr>
<tr class="separator:aff013f3acace99fb1191fd677bdaba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e36fbdb948bce537bd17d75114f712"><td class="memTemplParams" colspan="2">template&lt;typename RowCoefficients , typename ColumnCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and coefficients&lt; ColumnCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size) and(MatrixTraits&lt; M &gt;::columns==ColumnCoefficients::size), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a73e36fbdb948bce537bd17d75114f712"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a73e36fbdb948bce537bd17d75114f712">make_matrix</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:a73e36fbdb948bce537bd17d75114f712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from a typed_matrix_nestable, specifying the row and column coefficients.  <a href="namespace_open_kalman.html#a73e36fbdb948bce537bd17d75114f712">More...</a><br /></td></tr>
<tr class="separator:a73e36fbdb948bce537bd17d75114f712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71be5796e548bfdb501444c727d9f372"><td class="memTemplParams" colspan="2">template&lt;typename RowCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a71be5796e548bfdb501444c727d9f372"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a71be5796e548bfdb501444c727d9f372">make_matrix</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:a71be5796e548bfdb501444c727d9f372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from a typed_matrix_nestable, specifying only the row coefficients.  <a href="namespace_open_kalman.html#a71be5796e548bfdb501444c727d9f372">More...</a><br /></td></tr>
<tr class="separator:a71be5796e548bfdb501444c727d9f372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82be03cc51cb7a0b7b8c2eb14c6c0bb"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af82be03cc51cb7a0b7b8c2eb14c6c0bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#af82be03cc51cb7a0b7b8c2eb14c6c0bb">make_matrix</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:af82be03cc51cb7a0b7b8c2eb14c6c0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from a typed_matrix_nestable object, with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.  <a href="namespace_open_kalman.html#af82be03cc51cb7a0b7b8c2eb14c6c0bb">More...</a><br /></td></tr>
<tr class="separator:af82be03cc51cb7a0b7b8c2eb14c6c0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb3bd9bc6f894eb4b03b48b8a0d850c"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afdb3bd9bc6f894eb4b03b48b8a0d850c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#afdb3bd9bc6f894eb4b03b48b8a0d850c">make_matrix</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:afdb3bd9bc6f894eb4b03b48b8a0d850c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from another typed_matrix.  <a href="namespace_open_kalman.html#afdb3bd9bc6f894eb4b03b48b8a0d850c">More...</a><br /></td></tr>
<tr class="separator:afdb3bd9bc6f894eb4b03b48b8a0d850c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5647c719085536c8fa6851836c5d03ea"><td class="memTemplParams" colspan="2">template&lt;typename RowCoefficients , typename ColumnCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and coefficients&lt; ColumnCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size) and(MatrixTraits&lt; M &gt;::columns==ColumnCoefficients::size), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5647c719085536c8fa6851836c5d03ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a5647c719085536c8fa6851836c5d03ea">make_matrix</a> ()</td></tr>
<tr class="memdesc:a5647c719085536c8fa6851836c5d03ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, self-contained <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object.  <a href="namespace_open_kalman.html#a5647c719085536c8fa6851836c5d03ea">More...</a><br /></td></tr>
<tr class="separator:a5647c719085536c8fa6851836c5d03ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa3556236800e6eecb365ea76199ae5"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:affa3556236800e6eecb365ea76199ae5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#affa3556236800e6eecb365ea76199ae5">make_matrix</a> ()</td></tr>
<tr class="memdesc:affa3556236800e6eecb365ea76199ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a self-contained <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.  <a href="namespace_open_kalman.html#affa3556236800e6eecb365ea76199ae5">More...</a><br /></td></tr>
<tr class="separator:affa3556236800e6eecb365ea76199ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4811b89985f03ba5fe3b5c6a54b9e49b"><td class="memTemplParams" colspan="2">template&lt;typename V , std::enable_if_t&lt; typed_matrix_nestable&lt; V &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4811b89985f03ba5fe3b5c6a54b9e49b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a4811b89985f03ba5fe3b5c6a54b9e49b">Mean</a> (V &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">passable_t</a>&lt; V &gt;&gt;</td></tr>
<tr class="memdesc:a4811b89985f03ba5fe3b5c6a54b9e49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a typed_matrix_nestable, assuming axis-only coefficients.  <a href="namespace_open_kalman.html#a4811b89985f03ba5fe3b5c6a54b9e49b">More...</a><br /></td></tr>
<tr class="separator:a4811b89985f03ba5fe3b5c6a54b9e49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74553d9027b3d93c5020f13c0570a8b"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::size==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad74553d9027b3d93c5020f13c0570a8b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ad74553d9027b3d93c5020f13c0570a8b">make_mean</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:ad74553d9027b3d93c5020f13c0570a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> from a typed_matrix_nestable, specifying the row coefficients.  <a href="namespace_open_kalman.html#ad74553d9027b3d93c5020f13c0570a8b">More...</a><br /></td></tr>
<tr class="separator:ad74553d9027b3d93c5020f13c0570a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cb56942738ea287feeb456de8a1ee8"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab6cb56942738ea287feeb456de8a1ee8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ab6cb56942738ea287feeb456de8a1ee8">make_mean</a> (M &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:ab6cb56942738ea287feeb456de8a1ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> from a typed_matrix_nestable object, with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.  <a href="namespace_open_kalman.html#ab6cb56942738ea287feeb456de8a1ee8">More...</a><br /></td></tr>
<tr class="separator:ab6cb56942738ea287feeb456de8a1ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342c91bcf1ffd94505e1c4336f95d43e"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and untyped_columns&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a342c91bcf1ffd94505e1c4336f95d43e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a342c91bcf1ffd94505e1c4336f95d43e">make_mean</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a342c91bcf1ffd94505e1c4336f95d43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> from another typed_matrix.  <a href="namespace_open_kalman.html#a342c91bcf1ffd94505e1c4336f95d43e">More...</a><br /></td></tr>
<tr class="separator:a342c91bcf1ffd94505e1c4336f95d43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258fd14762cd857444878183fc128c73"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==Coefficients::size), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a258fd14762cd857444878183fc128c73"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a258fd14762cd857444878183fc128c73">make_mean</a> ()</td></tr>
<tr class="memdesc:a258fd14762cd857444878183fc128c73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, self-contained <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>.  <a href="namespace_open_kalman.html#a258fd14762cd857444878183fc128c73">More...</a><br /></td></tr>
<tr class="separator:a258fd14762cd857444878183fc128c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abae6f929b546e22c34d58a1595303f"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6abae6f929b546e22c34d58a1595303f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6abae6f929b546e22c34d58a1595303f">make_mean</a> ()</td></tr>
<tr class="memdesc:a6abae6f929b546e22c34d58a1595303f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a self-contained <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.  <a href="namespace_open_kalman.html#a6abae6f929b546e22c34d58a1595303f">More...</a><br /></td></tr>
<tr class="separator:a6abae6f929b546e22c34d58a1595303f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2453977eb5e1c47f1e24d4ef557988eb"><td class="memTemplParams" colspan="2">template&lt;typename M , std::enable_if_t&lt; covariance_nestable&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2453977eb5e1c47f1e24d4ef557988eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a2453977eb5e1c47f1e24d4ef557988eb">SquareRootCovariance</a> (M &amp;&amp;) -&gt; <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html">SquareRootCovariance</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">passable_t</a>&lt; M &gt;&gt;</td></tr>
<tr class="memdesc:a2453977eb5e1c47f1e24d4ef557988eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> type from a <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>.  <a href="namespace_open_kalman.html#a2453977eb5e1c47f1e24d4ef557988eb">More...</a><br /></td></tr>
<tr class="separator:a2453977eb5e1c47f1e24d4ef557988eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3983a57927dc746dcc5a6c877337a686"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and covariance_nestable&lt; Arg &gt; and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3983a57927dc746dcc5a6c877337a686"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a3983a57927dc746dcc5a6c877337a686">make_square_root_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a3983a57927dc746dcc5a6c877337a686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>, specifying the coefficients.  <a href="namespace_open_kalman.html#a3983a57927dc746dcc5a6c877337a686">More...</a><br /></td></tr>
<tr class="separator:a3983a57927dc746dcc5a6c877337a686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9adb3eae588123a5f80eafea891a0c5"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; covariance_nestable&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae9adb3eae588123a5f80eafea891a0c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ae9adb3eae588123a5f80eafea891a0c5">make_square_root_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:ae9adb3eae588123a5f80eafea891a0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>, with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.  <a href="namespace_open_kalman.html#ae9adb3eae588123a5f80eafea891a0c5">More...</a><br /></td></tr>
<tr class="separator:ae9adb3eae588123a5f80eafea891a0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc58f602f72886f980090ec403f86f2e"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , TriangleType triangle_type = TriangleType::lower, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and(not covariance_nestable&lt; Arg &gt;) and(triangle_type==TriangleType::lower or triangle_type==TriangleType::upper) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:adc58f602f72886f980090ec403f86f2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#adc58f602f72886f980090ec403f86f2e">make_square_root_covariance</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:adc58f602f72886f980090ec403f86f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> (with nested triangular matrix) from a self-adjoint <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.  <a href="namespace_open_kalman.html#adc58f602f72886f980090ec403f86f2e">More...</a><br /></td></tr>
<tr class="separator:adc58f602f72886f980090ec403f86f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22473ed4dd2db3f2eaa82a5dbd7e799d"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a22473ed4dd2db3f2eaa82a5dbd7e799d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a22473ed4dd2db3f2eaa82a5dbd7e799d">make_square_root_covariance</a> ()</td></tr>
<tr class="memdesc:a22473ed4dd2db3f2eaa82a5dbd7e799d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.  <a href="namespace_open_kalman.html#a22473ed4dd2db3f2eaa82a5dbd7e799d">More...</a><br /></td></tr>
<tr class="separator:a22473ed4dd2db3f2eaa82a5dbd7e799d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00898738e33dfb03d94f4289d6855633"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a00898738e33dfb03d94f4289d6855633"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a00898738e33dfb03d94f4289d6855633">make_square_root_covariance</a> ()</td></tr>
<tr class="memdesc:a00898738e33dfb03d94f4289d6855633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a> or <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.  <a href="namespace_open_kalman.html#a00898738e33dfb03d94f4289d6855633">More...</a><br /></td></tr>
<tr class="separator:a00898738e33dfb03d94f4289d6855633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2f1e0973fe26e185ec3d80837fcd67"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1e2f1e0973fe26e185ec3d80837fcd67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a1e2f1e0973fe26e185ec3d80837fcd67">make_square_root_covariance</a> ()</td></tr>
<tr class="memdesc:a1e2f1e0973fe26e185ec3d80837fcd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a> or <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>.  <a href="namespace_open_kalman.html#a1e2f1e0973fe26e185ec3d80837fcd67">More...</a><br /></td></tr>
<tr class="separator:a1e2f1e0973fe26e185ec3d80837fcd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memTemplParams" colspan="2"><a id="a82c83df8efb22e49dd3e6f5ea119caef"></a>
template&lt;typename OutputCoefficients , typename In , typename ... Perturbations&gt; </td></tr>
<tr class="memitem:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a82c83df8efb22e49dd3e6f5ea119caef">zero_hessian</a> ()</td></tr>
<tr class="memdesc:a82c83df8efb22e49dd3e6f5ea119caef"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple of zero-filled arrays of Hessian matrices, based on the input and each perturbation term. <br /></td></tr>
<tr class="separator:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memTemplParams" colspan="2"><a id="ac32f98e2f9ea9d21f58ac57b49ee011e"></a>
template&lt;typename OutputCoefficients , typename In , typename ... Perturbations&gt; </td></tr>
<tr class="memitem:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#ac32f98e2f9ea9d21f58ac57b49ee011e">zero_hessian</a> (In &amp;&amp;, Perturbations &amp;&amp;...)</td></tr>
<tr class="memdesc:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple of zero-filled arrays of Hessian matrices, based on the input and each perturbation term. <br /></td></tr>
<tr class="separator:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9934a0fa27adfaf949d994695a13b6af"><td class="memTemplParams" colspan="2">template&lt;typename Trans , typename InDelta , typename ... PsDelta&gt; </td></tr>
<tr class="memitem:a9934a0fa27adfaf949d994695a13b6af"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a9934a0fa27adfaf949d994695a13b6af">FiniteDifferenceLinearization</a> (Trans &amp;&amp;, InDelta &amp;&amp;, PsDelta &amp;&amp;...) -&gt; FiniteDifferenceLinearization&lt; Trans, InDelta, PsDelta... &gt;</td></tr>
<tr class="separator:a9934a0fa27adfaf949d994695a13b6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd655dfd0d89b3b12ece39ab953e061"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename... TaylorDerivatives&gt; </td></tr>
<tr class="memitem:abbd655dfd0d89b3b12ece39ab953e061"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#abbd655dfd0d89b3b12ece39ab953e061">Transformation</a> (Function &amp;&amp;, TaylorDerivatives &amp;&amp;...) -&gt; <a class="el" href="struct_open_kalman_1_1_transformation.html">Transformation</a>&lt; Function, TaylorDerivatives... &gt;</td></tr>
<tr class="separator:abbd655dfd0d89b3b12ece39ab953e061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bcaeb1f9fe73f713397b37d3209e817"><td class="memTemplParams" colspan="2"><a id="a6bcaeb1f9fe73f713397b37d3209e817"></a>
template&lt;typename Function , typename... TaylorDerivatives, std::enable_if_t&lt; not is_linearized_function_v&lt; Function, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a6bcaeb1f9fe73f713397b37d3209e817"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a6bcaeb1f9fe73f713397b37d3209e817">make_Transformation</a> (const Function &amp;f, const TaylorDerivatives &amp;...ds)</td></tr>
<tr class="memdesc:a6bcaeb1f9fe73f713397b37d3209e817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="struct_open_kalman_1_1_transformation.html" title="A transformation from one single-column vector to another.">Transformation</a> from a transformation function (and optionally one or more Taylor series derivatives). <br /></td></tr>
<tr class="separator:a6bcaeb1f9fe73f713397b37d3209e817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f9155e6a8c211c128af8bdc3f02c14"><td class="memTemplParams" colspan="2">template&lt;typename Function , std::enable_if_t&lt; is_linearized_function_v&lt; Function, 1 &gt; and not is_linearized_function_v&lt; Function, 2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a05f9155e6a8c211c128af8bdc3f02c14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman.html#a05f9155e6a8c211c128af8bdc3f02c14">make_Transformation</a> (const Function &amp;f)</td></tr>
<tr class="separator:a05f9155e6a8c211c128af8bdc3f02c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_angle.html">Angle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An angle or any other simple modular value.  <a href="struct_open_kalman_1_1_angle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_axis.html">Axis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A real or integral number, (&minus;&infin;,&infin;).  <a href="struct_open_kalman_1_1_axis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_coefficients.html">Coefficients</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of coefficient types.  <a href="struct_open_kalman_1_1_coefficients.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_coefficients_3_01_c_00_01_cs_01_8_8_8_01_4.html">Coefficients&lt; C, Cs ... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of two or more coefficient types.  <a href="struct_open_kalman_1_1_coefficients_3_01_c_00_01_cs_01_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_coefficients_3_4.html">Coefficients&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An empty set of <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>.  <a href="struct_open_kalman_1_1_coefficients_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A self-adjoint <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> matrix.  <a href="struct_open_kalman_1_1_covariance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_distance.html">Distance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-negative real or integral number, [0,&infin;], representing a distance.  <a href="struct_open_kalman_1_1_distance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_distribution_traits.html">DistributionTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait class for any distribution T.  <a href="struct_open_kalman_1_1_distribution_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>, but the coefficients are transformed into Euclidean space, based on their type.  <a href="struct_open_kalman_1_1_euclidean_mean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_gaussian_distribution.html">GaussianDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian distribution, defined in terms of a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> and a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>.  <a href="struct_open_kalman_1_1_gaussian_distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_identity_transform.html">IdentityTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An identity transform from one statistical distribution to another.  <a href="struct_open_kalman_1_1_identity_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_identity_transformation.html">IdentityTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The identity transformation from one single-column vector to another. Perturbation terms are treated as additive.  <a href="struct_open_kalman_1_1_identity_transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_inclination.html">Inclination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A positive or negative real number &phi; representing an inclination or declination from the horizon.  <a href="struct_open_kalman_1_1_inclination.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1is__linearized__function.html">is_linearized_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an object is a linearized function (with defined Jacobian and optionally Hessian functions).  <a href="struct_open_kalman_1_1is__linearized__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_kalman_filter.html">KalmanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using one or more statistical transforms.  <a href="struct_open_kalman_1_1_kalman_filter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_kalman_filter_3_01_process_transform_00_01_measurement_transform_01_4.html">KalmanFilter&lt; ProcessTransform, MeasurementTransform &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using a different statistical transform for the process and the measurement.  <a href="struct_open_kalman_1_1_kalman_filter_3_01_process_transform_00_01_measurement_transform_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_kalman_filter_3_01_transform_01_4.html">KalmanFilter&lt; Transform &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using the same transform for the process and the measurement.  <a href="struct_open_kalman_1_1_kalman_filter_3_01_transform_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_linearized_transform.html">LinearizedTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linearized transform, using a 1st or 2nd order Taylor approximation of a linear transformation.  <a href="struct_open_kalman_1_1_linearized_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_linear_transform.html">LinearTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear transformation from one statistical distribution to another.  <a href="struct_open_kalman_1_1_linear_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_linear_transformation.html">LinearTransformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear transformation from one single-column vector to another.  <a href="struct_open_kalman_1_1_linear_transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix with typed rows and columns.  <a href="struct_open_kalman_1_1_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type trait class for any matrix T.  <a href="struct_open_kalman_1_1_matrix_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of one or more column vectors, each representing a statistical mean.  <a href="struct_open_kalman_1_1_mean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_mixture_of_continuous_distributions.html">MixtureOfContinuousDistributions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_monte_carlo_transform.html">MonteCarloTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Monte Carlo transform from one Gaussian distribution to another. Uses ideas from Chan, Tony F.; Golub, Gene H.; LeVeque, Randall J. (1979), "Updating Formulae and a Pairwise Algorithm for Computing Sample Variances." Technical Report STAN-CS-79-773, Department of Computer Science, Stanford University. <a href="http://i.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf">http://i.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf</a>.  <a href="struct_open_kalman_1_1_monte_carlo_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_particle_distribution.html">ParticleDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribution of particles.  <a href="struct_open_kalman_1_1_particle_distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_polar.html">Polar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic coefficient group reflecting polar coordinates.  <a href="struct_open_kalman_1_1_polar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_recursive_least_squares_transform.html">RecursiveLeastSquaresTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates a recursive least squares error distribution of parameters, with a forgetting factor λ. Useful for parameter estimation, where the parameter is expected to possibly drift over time.  <a href="struct_open_kalman_1_1_recursive_least_squares_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_sample_points_transform.html">SamplePointsTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled points transform. Compatible with unscented transform and cubature transform. As implemented in, e.g., E. Wan &amp; R. van der Merwe, "The unscented Kalman filter for nonlinear estimation," in Proc. of IEEE Symposium (AS-SPCC), pp. 153-158. See also R. van der Merwe &amp; E. Wan, "The Square-Root Unscented Kalman Filter for State and Parameter-Estimation in Proc. Acoustics, Speech, and Signal Processing (ICASSP'01), 2001, pp. 3461-64.  <a href="struct_open_kalman_1_1_sample_points_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_spherical.html">Spherical</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An atomic coefficient group reflecting spherical coordinates.  <a href="struct_open_kalman_1_1_spherical.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_square_root_covariance.html">SquareRootCovariance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The upper or lower triangle Cholesky factor (square root) of a covariance matrix.  <a href="struct_open_kalman_1_1_square_root_covariance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_transformation.html">Transformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A transformation from one single-column vector to another.  <a href="struct_open_kalman_1_1_transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_transform_base.html">TransformBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base for all transforms.  <a href="struct_open_kalman_1_1_transform_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_unscented_parameters_parameter_estimation.html">UnscentedParametersParameterEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unscented parameters for use in parameter estimation.  <a href="struct_open_kalman_1_1_unscented_parameters_parameter_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_unscented_parameters_state_estimation.html">UnscentedParametersStateEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unscented parameters for use in state estimation (the default).  <a href="struct_open_kalman_1_1_unscented_parameters_state_estimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace for all OpenKalman-specific classes and methods. </p>
</div><h2 class="groupheader">Variable Documentation</h2>
<a id="a2562e4c0918dc2cbf74de6a97d9388cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2562e4c0918dc2cbf74de6a97d9388cf">&#9670;&nbsp;</a></span>cholesky_form</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::cholesky_form = <a class="el" href="struct_open_kalman_1_1internal_1_1is__cholesky__form.html">internal::is_cholesky_form</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this is true, then nested_matrix_t&lt;T&gt; is true. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00959">959</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="af847ece5eb2e6d50df847573c505b852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af847ece5eb2e6d50df847573c505b852">&#9670;&nbsp;</a></span>coefficients</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::coefficients = detail::is_coefficients&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Atomic coefficient groups are coefficients or groups of coefficients that function as a unit, and cannot be separated. They may be combined into composite coefficients by passing them as template parameters to <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>. These include <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>, <a class="el" href="struct_open_kalman_1_1_distance.html" title="A non-negative real or integral number, [0,∞], representing a distance.">Distance</a>, <a class="el" href="struct_open_kalman_1_1_angle.html" title="An angle or any other simple modular value.">Angle</a>, <a class="el" href="struct_open_kalman_1_1_inclination.html" title="A positive or negative real number φ representing an inclination or declination from the horizon.">Inclination</a>, <a class="el" href="struct_open_kalman_1_1_polar.html" title="An atomic coefficient group reflecting polar coordinates.">Polar</a>, and <a class="el" href="struct_open_kalman_1_1_spherical.html" title="An atomic coefficient group reflecting spherical coordinates.">Spherical</a>.</p>
<p>Composite coefficients are specializations of the class <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>, which has the purpose of grouping other atomic or composite coefficients. Composite coefficients can, themselves, comprise groups of other composite components. Composite coefficients are of the form Coefficients&lt;Cs...&gt;. <b>Examples</b>:</p><ul>
<li><a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a></li>
<li>Polar&lt;Distance, angle::Radians&gt;</li>
<li>Coefficients&lt;Axis, angle::Radians&gt;</li>
<li><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>&lt;Spherical&lt;angle::Degrees, inclination::degrees, Distance&gt;, <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>, <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>&gt; </li>
</ul>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00096">96</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a77f3b5f0d758aec7db59022e845abed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f3b5f0d758aec7db59022e845abed1">&#9670;&nbsp;</a></span>column_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::column_vector = <a class="el" href="namespace_open_kalman.html#a11e454bc99a03d730955077ca215479e">untyped_columns</a>&lt;T&gt; and detail::has_one_column&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If T is a typed_matrix, its column must be of type <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00344">344</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="acc62cd53d66b676058de97da3caaca3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc62cd53d66b676058de97da3caaca3b">&#9670;&nbsp;</a></span>covariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::covariance = <a class="el" href="namespace_open_kalman.html#a4bf939b25b2e4bfc1162f21533ae490e">square_root_covariance</a>&lt;T&gt; or detail::is_sa_covariance&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00396">396</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a19898d83f3f0b722b834acac97f7c17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19898d83f3f0b722b834acac97f7c17e">&#9670;&nbsp;</a></span>covariance_nestable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::covariance_nestable = <a class="el" href="struct_open_kalman_1_1internal_1_1is__covariance__nestable.html">internal::is_covariance_nestable</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00193">193</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="acda49202b6dd92195051ed9db5fcdcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda49202b6dd92195051ed9db5fcdcaf">&#9670;&nbsp;</a></span>diagonal_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::diagonal_matrix = detail::is_diag_matrix_impl&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00761">761</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a80760930fc0db06999a2dce3dd4b53f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80760930fc0db06999a2dce3dd4b53f0">&#9670;&nbsp;</a></span>distribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::distribution = <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00434">434</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a4a95b16bcf85246cc892ddf51cc9ddfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a95b16bcf85246cc892ddf51cc9ddfa">&#9670;&nbsp;</a></span>element_gettable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::element_gettable = <a class="el" href="struct_open_kalman_1_1internal_1_1is__element__gettable.html">internal::is_element_gettable</a>&lt;std::decay_t&lt;T&gt;, N&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00992">992</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="ac77329c3cd71568cac6bd18c3add8d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77329c3cd71568cac6bd18c3add8d0c">&#9670;&nbsp;</a></span>element_settable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::element_settable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= internal::is_element_settable&lt;T, N&gt;::value and</div>
<div class="line">    (not std::is_const_v&lt;std::remove_reference_t&lt;T&gt;&gt;)</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l01025">1025</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a78584a279011110fd315cbf73ca2fe36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78584a279011110fd315cbf73ca2fe36">&#9670;&nbsp;</a></span>equivalent_to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::equivalent_to = <a class="el" href="struct_open_kalman_1_1internal_1_1is__equivalent__to.html">internal::is_equivalent_to</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets of coefficients are equivalent if they are treated functionally the same.</p><ul>
<li>Any coefficient or group of coefficients is equivalent to itself.</li>
<li>Coefficient&lt;Ts...&gt; is equivalent to Coefficient&lt;Us...&gt;, if each Ts is equivalent to its respective Us.</li>
<li>Coefficient&lt;T&gt; is equivalent to T, and vice versa. <dl class="section user"><dt>Example:</dt><dd><code>equivalent_to&lt;<a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>, <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>&lt;<a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>&gt;&gt; </code></dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00129">129</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a50c621b67811a5ba3abe325f75618cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c621b67811a5ba3abe325f75618cd8">&#9670;&nbsp;</a></span>euclidean_mean</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::euclidean_mean = detail::is_euclidean_mean&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00232">232</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a434bc44aa1de7faf3cac40cca8944b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434bc44aa1de7faf3cac40cca8944b44">&#9670;&nbsp;</a></span>euclidean_transformed</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::euclidean_transformed = detail::is_euclidean_transformed&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00259">259</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="af9367eb4d7b08c961db76037c1926531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9367eb4d7b08c961db76037c1926531">&#9670;&nbsp;</a></span>gaussian_distribution</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::gaussian_distribution = detail::is_gaussian_distribution&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00422">422</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a79246e358d47951c68ade232002bdecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79246e358d47951c68ade232002bdecb">&#9670;&nbsp;</a></span>identity_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::identity_matrix = <a class="el" href="struct_open_kalman_1_1internal_1_1is__identity__matrix.html">internal::is_identity_matrix</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00657">657</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a05da5d495bfe6445599208b60bf12d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05da5d495bfe6445599208b60bf12d69">&#9670;&nbsp;</a></span>lower_triangular_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::lower_triangular_matrix = detail::is_lt_matrix_impl&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00840">840</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a2745b3bfff7250ac8d9e0dc79902508c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2745b3bfff7250ac8d9e0dc79902508c">&#9670;&nbsp;</a></span>mean</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::mean = detail::is_mean&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00180">180</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a31943131d380f310b945dc9bac9f9a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31943131d380f310b945dc9bac9f9a8a">&#9670;&nbsp;</a></span>modifiable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::modifiable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    internal::is_modifiable&lt;T, U&gt;::value and internal::is_modifiable_native&lt;T, U&gt;::value</div>
</div><!-- fragment --><p>The result is true unless there is an incompatibility of some kind that would prevent assignment. Examples of such incompatibility are if T is constant or has a nested constant type, if T and U have a different shape or scalar type, or if T and U differ as to being self-adjoint, triangular, diagonal, zero, or identity. Even if this concept is true, a compile-time error is still possible. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l01070">1070</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a65caec2881ed038f08fbf632355bfbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65caec2881ed038f08fbf632355bfbf4">&#9670;&nbsp;</a></span>one_by_one_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::one_by_one_matrix = detail::is_1by1&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00686">686</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a163a7971e4b4684e1793a209c83f5688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163a7971e4b4684e1793a209c83f5688">&#9670;&nbsp;</a></span>prefix_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::prefix_of = <a class="el" href="struct_open_kalman_1_1internal_1_1is__prefix__of.html">internal::is_prefix_of</a>&lt;T, U&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If T is a prefix of U, then U is equivalent_to concatenating T with the remaining part of U. C is a prefix of Coefficients&lt;C, Cs...&gt; for any coefficients Cs. T is a prefix of U if equivalent_to&lt;T, U&gt;. <a class="el" href="struct_open_kalman_1_1_coefficients_3_4.html" title="An empty set of Coefficients.">Coefficients&lt;&gt;</a> is a prefix of any set of coefficients. </p><dl class="section user"><dt>Example:</dt><dd><code>prefix_of&lt;<a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>&lt;<a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>&gt;, <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>&lt;<a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>, <a class="el" href="namespace_open_kalman_1_1angle.html#a83281632e5031d7542ef229623b292a9" title="An angle measured in radians [-π,π).">angle::Radians</a>&gt;&gt; </code></dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00162">162</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a63114cb8862cdcff4b5f0660b16a5bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63114cb8862cdcff4b5f0660b16a5bec">&#9670;&nbsp;</a></span>self_adjoint_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::self_adjoint_matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    internal::is_self_adjoint_matrix&lt;std::decay_t&lt;T&gt;&gt;::value or diagonal_matrix&lt;T&gt;</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00793">793</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a8b841cd9db4d9a19b89529d1aed58b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b841cd9db4d9a19b89529d1aed58b03">&#9670;&nbsp;</a></span>self_contained</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::self_contained</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line">    internal::is_self_contained&lt;std::decay_t&lt;T&gt;&gt;::value and (not std::is_lvalue_reference_v&lt;T&gt;)</div>
</div><!-- fragment --><p>A value is self-contained if it can be created in a function and returned as the result. An <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> matrix type is self-contained if it is not an lvalue reference and its wrapped native matrix is self-contained. The matrix library interface will specify which native matrices and expressions are self-contained. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00595">595</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a4fc1aa6874bf00181847d0bc6228514b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fc1aa6874bf00181847d0bc6228514b">&#9670;&nbsp;</a></span>square_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::square_matrix = internal::is_square_matrix&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If T is a <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>, the row coefficients must also be <a class="el" href="namespace_open_kalman.html#a78584a279011110fd315cbf73ca2fe36">equivalent_to</a> the column coefficients. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00713">713</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a4bf939b25b2e4bfc1162f21533ae490e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bf939b25b2e4bfc1162f21533ae490e">&#9670;&nbsp;</a></span>square_root_covariance</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::square_root_covariance = detail::is_square_root_covariance&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00370">370</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="ada97c2afb746e33dd806af6f63957fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada97c2afb746e33dd806af6f63957fce">&#9670;&nbsp;</a></span>triangular_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::triangular_matrix = <a class="el" href="namespace_open_kalman.html#a05da5d495bfe6445599208b60bf12d69">lower_triangular_matrix</a>&lt;T&gt; or <a class="el" href="namespace_open_kalman.html#a5456de7a2e027daca692a5c72dc3540e">upper_triangular_matrix</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00903">903</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="ae19962a38a87cd8c8003e48f42150145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19962a38a87cd8c8003e48f42150145">&#9670;&nbsp;</a></span>typed_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::typed_matrix = <a class="el" href="namespace_open_kalman.html#a2745b3bfff7250ac8d9e0dc79902508c">mean</a>&lt;T&gt; or <a class="el" href="namespace_open_kalman.html#a50c621b67811a5ba3abe325f75618cd8">euclidean_mean</a>&lt;T&gt; or detail::is_matrix&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00285">285</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a5245fbf912b12a279acb815fcf7650d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5245fbf912b12a279acb815fcf7650d9">&#9670;&nbsp;</a></span>typed_matrix_nestable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::typed_matrix_nestable = <a class="el" href="struct_open_kalman_1_1internal_1_1is__typed__matrix__nestable.html">internal::is_typed_matrix_nestable</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00224">224</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="a11e454bc99a03d730955077ca215479e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e454bc99a03d730955077ca215479e">&#9670;&nbsp;</a></span>untyped_columns</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::untyped_columns = detail::has_untyped_columns&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T must be either a native matrix or its columns must all have type <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00318">318</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="a5456de7a2e027daca692a5c72dc3540e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5456de7a2e027daca692a5c72dc3540e">&#9670;&nbsp;</a></span>upper_triangular_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::upper_triangular_matrix = detail::is_ut_matrix_impl&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00886">886</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="ae2d3de4ef2635e290fd9640db5721563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d3de4ef2635e290fd9640db5721563">&#9670;&nbsp;</a></span>wrapped_mean</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::wrapped_mean = detail::is_wrapped_mean&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00206">206</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<a id="ae46b30e35dee139fe206951335c1b4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46b30e35dee139fe206951335c1b4ec">&#9670;&nbsp;</a></span>zero_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::zero_matrix = <a class="el" href="struct_open_kalman_1_1internal_1_1is__zero__matrix.html">internal::is_zero_matrix</a>&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00627">627</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ab6c606169452d88f33b64e3b1ae18fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6c606169452d88f33b64e3b1ae18fa2">&#9670;&nbsp;</a></span>TriangleType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_open_kalman.html#ab6c606169452d88f33b64e3b1ae18fa2">OpenKalman::TriangleType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab6c606169452d88f33b64e3b1ae18fa2a81e073b428b50247daba38531dcf412a"></a>lower&#160;</td><td class="fielddoc"><p>The lower-left triangle. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab6c606169452d88f33b64e3b1ae18fa2a0122b4c2c01ee1c698ecc309d2b8eb5a"></a>upper&#160;</td><td class="fielddoc"><p>The upper-right triangle. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab6c606169452d88f33b64e3b1ae18fa2aa0e17e2709a0404ae3d7de03b8ea9093"></a>diagonal&#160;</td><td class="fielddoc"><p>The diagonal elements of the matrix. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00557">557</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Aliases</h2>
<a id="ad7fbe21f478b7b06ac97b6eb6f5967c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7fbe21f478b7b06ac97b6eb6f5967c3">&#9670;&nbsp;</a></span>Axes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">OpenKalman::Axes</a> = typedef <a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">Replicate</a>&lt;<a class="el" href="struct_open_kalman_1_1_axis.html">Axis</a>, size&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">size</td><td>The number of Axes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="coefficient-types_2_coefficients_8hpp_source.html#l00334">334</a> of file <a class="el" href="coefficient-types_2_coefficients_8hpp_source.html">Coefficients.hpp</a>.</p>

</div>
</div>
<a id="a098e86bc01897e4b391805799008a9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098e86bc01897e4b391805799008a9f4">&#9670;&nbsp;</a></span>Concatenate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Coeffs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#a098e86bc01897e4b391805799008a9f4">OpenKalman::Concatenate</a> = typedef typename detail::ConcatenateImpl&lt;Coeffs...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Example:</p><div class="fragment"><div class="line"> Concatenate&lt;Coefficients&lt;angle::Radians&gt;, Coefficients&lt;Axis, Distance&gt;&gt; ==</div>
<div class="line">Coefficients&lt;angle::Radians, Axis, Distance&gt; </div>
</div><!-- fragment --><p>. </p>

<p class="definition">Definition at line <a class="el" href="coefficient__forward-declarations_8hpp_source.html#l00400">400</a> of file <a class="el" href="coefficient__forward-declarations_8hpp_source.html">coefficient_forward-declarations.hpp</a>.</p>

</div>
</div>
<a id="a78c4bdd289f65db14dd2eab442a4efc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c4bdd289f65db14dd2eab442a4efc4">&#9670;&nbsp;</a></span>native_matrix_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t rows = MatrixTraits&lt;T&gt;::dimension, std::size_t cols = MatrixTraits&lt;T&gt;::columns, typename Scalar  = typename MatrixTraits&lt;T&gt;::Scalar&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#a78c4bdd289f65db14dd2eab442a4efc4">OpenKalman::native_matrix_t</a> = typedef typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt;T&gt;::template NativeMatrixFrom&lt;rows, cols, Scalar&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type from which the native matrix is derived. </td></tr>
    <tr><td class="paramname">rows</td><td>Number of rows in the native matrix (defaults to the number of rows in T). </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns in the native matrix (defaults to the number of columns in T). </td></tr>
    <tr><td class="paramname">Scalar</td><td>Scalar type of the matrix (defaults to the Scalar type of T). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00529">529</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="abc8e1017c2a892423e656ba212290b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8e1017c2a892423e656ba212290b74">&#9670;&nbsp;</a></span>nested_matrix_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = typename MatrixTraits&lt;T&gt;::NestedMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">OpenKalman::nested_matrix_t</a> = typedef typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt;T&gt;::NestedMatrix</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Only participates in overload resolution if the type has a nested matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A type that is a wrapper for a nested matrix. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forward-traits_8hpp_source.html#l00513">513</a> of file <a class="el" href="forward-traits_8hpp_source.html">forward-traits.hpp</a>.</p>

</div>
</div>
<a id="aa6babcf2fe72766cbfef2c7082b606b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6babcf2fe72766cbfef2c7082b606b2">&#9670;&nbsp;</a></span>passable_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">OpenKalman::passable_t</a> = typedef std::conditional_t&lt;std::is_lvalue_reference_v&lt;T&gt;, T, <a class="el" href="namespace_open_kalman.html#a46e7a86630ddacf5420ddc348fbffa2d">self_contained_t</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type in question. </td></tr>
    <tr><td class="paramname">Ts</td><td>Other types (optional) that must also be lvalue references if T is not self-contained.  A passable type T is either an lvalue reference (and all other Ts are also lvalue references) or is <a class="el" href="namespace_open_kalman.html#a46e7a86630ddacf5420ddc348fbffa2d">self_contained_t</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00512">512</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<a id="ac66c8a3d2e7e2449a727d370262995ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66c8a3d2e7e2449a727d370262995ef">&#9670;&nbsp;</a></span>Replicate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#ac66c8a3d2e7e2449a727d370262995ef">OpenKalman::Replicate</a> = typedef typename detail::ReplicateImpl&lt;C, N&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>The coefficient to be repeated. </td></tr>
    <tr><td class="paramname">N</td><td>The number of times to repeat coefficient C. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="coefficient-types_2_coefficients_8hpp_source.html#l00326">326</a> of file <a class="el" href="coefficient-types_2_coefficients_8hpp_source.html">Coefficients.hpp</a>.</p>

</div>
</div>
<a id="a46e7a86630ddacf5420ddc348fbffa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e7a86630ddacf5420ddc348fbffa2d">&#9670;&nbsp;</a></span>self_contained_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_open_kalman.html#a46e7a86630ddacf5420ddc348fbffa2d">OpenKalman::self_contained_t</a> = typedef typename detail::self_contained_impl&lt;std::remove_reference_t&lt;T&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this alias to obtain a type, equivalent to T, that can safely be returned from a function. </p>

<p class="definition">Definition at line <a class="el" href="traits_8hpp_source.html#l00497">497</a> of file <a class="el" href="traits_8hpp_source.html">traits.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aac70867ae2a7c599ef94a187b72a34eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac70867ae2a7c599ef94a187b72a34eb">&#9670;&nbsp;</a></span>Covariance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; covariance_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_covariance.html">OpenKalman::Covariance</a> </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_open_kalman_1_1_covariance.html">Covariance</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">passable_t</a>&lt; M &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deduce <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> type from a square <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.</p>
<p>Deduce <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> type from a square <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>. </p>

</div>
</div>
<a id="a0d51334a0d4ec5eecd1fbc6a7570ae72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d51334a0d4ec5eecd1fbc6a7570ae72">&#9670;&nbsp;</a></span>EuclideanMean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , std::enable_if_t&lt; typed_matrix&lt; V &gt; and not euclidean_transformed&lt; V &gt; and untyped_columns&lt; V &gt; and MatrixTraits&lt; V &gt;::RowCoefficients::dimension==MatrixTraits&lt; V &gt;::dimension, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">OpenKalman::EuclideanMean</a> </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html">EuclideanMean</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::RowCoefficients, decltype(to_euclidean&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::RowCoefficients &gt;(std::forward&lt; V &gt;(std::declval&lt; V &gt;()).nested_matrix()))&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deduce template parameters from a typed_matrix_nestable, assuming axis-only coefficients.</p>
<p>Deduce template parameters from a Euclidean-transformed typed matrix. </p>

</div>
</div>
<a id="a9934a0fa27adfaf949d994695a13b6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9934a0fa27adfaf949d994695a13b6af">&#9670;&nbsp;</a></span>FiniteDifferenceLinearization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Trans , typename InDelta , typename ... PsDelta&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::FiniteDifferenceLinearization </td>
          <td>(</td>
          <td class="paramtype">Trans &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InDelta &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PsDelta &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  FiniteDifferenceLinearization&lt; Trans, InDelta, PsDelta... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deduction guide </p>

</div>
</div>
<a id="a7ed81d91202d9b998733a3be06de9910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed81d91202d9b998733a3be06de9910">&#9670;&nbsp;</a></span>get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt; and element_gettable&lt; Arg, 1 &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::get_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get element (i) of a typed matrix. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00411">411</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="aab9f83dc120f7424fe949f401344960e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9f83dc120f7424fe949f401344960e">&#9670;&nbsp;</a></span>get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt; and element_gettable&lt; Arg, 2 &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::get_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get element (i, j) of a typed matrix. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00398">398</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a6f44bd141f1e2b9b65432a633d9180e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f44bd141f1e2b9b65432a633d9180e2">&#9670;&nbsp;</a></span>inverse_scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename S , std::enable_if_t&lt; covariance&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::inverse_scale </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale a covariance by the inverse of a scalar factor. Equivalent by division by the square of a scalar. For a square root covariance, this is equivalent to division by the scalar. </p>

<p class="definition">Definition at line <a class="el" href="covariance-arithmetic_8hpp_source.html#l00538">538</a> of file <a class="el" href="covariance-arithmetic_8hpp_source.html">covariance-arithmetic.hpp</a>.</p>

</div>
</div>
<a id="a0e6f25c9190e4658793bb610b179bbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6f25c9190e4658793bb610b179bbc9">&#9670;&nbsp;</a></span>LQ_decomposition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; typed_matrix&lt; A &gt; and(not euclidean_transformed&lt; A &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::LQ_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an LQ decomposition of matrix A=[L|0]Q, where L is a lower-triangular matrix, and Q is orthogonal. Returns L as a Cholesky lower-triangular <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>. All column coefficients must be axes, and A cannot be Euclidean-transformed. </p>

<p class="definition">Definition at line <a class="el" href="typed-matrix-overloads_8hpp_source.html#l00265">265</a> of file <a class="el" href="typed-matrix-overloads_8hpp_source.html">typed-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="a0c8ce92ebb39445ad24273396c57ff0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8ce92ebb39445ad24273396c57ff0b">&#9670;&nbsp;</a></span>LQ_decomposition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::LQ_decomposition </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an LQ decomposition of matrix A=[L,0]Q, where L is a lower-triangular matrix, and Q is orthogonal. Returns L as a lower-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00225">225</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a6e11974581182d024289c3df6f00e92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e11974581182d024289c3df6f00e92b">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>, with nested triangular type based on a <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>.</p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> based on a nested triangle, with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l01208">1208</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a74f4317db70b740a4b05b154ea7d144e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f4317db70b740a4b05b154ea7d144e">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l01232">1232</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="af82a27123450aa0fd5266c332bde0362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82a27123450aa0fd5266c332bde0362">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>, based on a <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>.</p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a non-square-root <a class="el" href="namespace_open_kalman.html#acc62cd53d66b676058de97da3caaca3b">covariance</a>.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  The coefficients will be <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l01253">1253</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a1167376779e08b44911a5b18134ba1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1167376779e08b44911a5b18134ba1d4">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and covariance_nestable&lt; Arg &gt; and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>, with a nested triangular matrix, from a <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>.</p>
<p>Make a default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> (with nested triangular matrix) from a self-adjoint <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.</p>
<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a self-adjoint <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>, specifying the coefficients.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a> with size matching <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A square <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a> with size matching <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Arg</td><td>A square, self-adjoint <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l01053">1053</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="aae21ef7c840cf37fb755618dd419a221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae21ef7c840cf37fb755618dd419a221">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and covariance_nestable&lt; Arg &gt; and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension) and(triangle_type !=TriangleType::lower or lower_triangular_matrix&lt; Arg &gt;) and(triangle_type !=TriangleType::upper or upper_triangular_matrix&lt; Arg &gt;) and(triangle_type !=TriangleType::diagonal or diagonal_matrix&lt; Arg &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> (with nested triangular matrix) from a self-adjoint <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower, diagonal). </td></tr>
    <tr><td class="paramname">Arg</td><td>A <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a> with size matching <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Arg</td><td>A square, self-adjoint <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a> with size matching <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l01080">1080</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a8b1367d0df6f272ee442c2272a228ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1367d0df6f272ee442c2272a228ab8">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance_nestable&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>.</p>
<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> based on another non-square-root <a class="el" href="namespace_open_kalman.html#acc62cd53d66b676058de97da3caaca3b">covariance</a>.</p>
<p>Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a self-adjoint <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>, using default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A square <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_covariance_8hpp_source.html#l01098">1098</a> of file <a class="el" href="_covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="aae62cc2a04ec13fe3c3a71f9326b4637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae62cc2a04ec13fe3c3a71f9326b4637">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::dimension==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new matrix is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_euclidean_mean_8hpp_source.html#l00385">385</a> of file <a class="el" href="_euclidean_mean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="a3dc328414ecb720005c3c813be752ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc328414ecb720005c3c813be752ec3">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new Euclidean mean is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_euclidean_mean_8hpp_source.html#l00403">403</a> of file <a class="el" href="_euclidean_mean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="a51161ea0e106d97f06ca53662029bf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51161ea0e106d97f06ca53662029bf7a">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and untyped_columns&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A typed_matrix (i.e., <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a>, <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>, or <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_euclidean_mean_8hpp_source.html#l00361">361</a> of file <a class="el" href="_euclidean_mean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="aa48c0170c781745c5abc1e13f83777d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48c0170c781745c5abc1e13f83777d3">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::dimension==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>A typed_matrix_nestable with size matching ColumnCoefficients. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_euclidean_mean_8hpp_source.html#l00329">329</a> of file <a class="el" href="_euclidean_mean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="a3d6687a8e5791a070fb3bb625687f4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6687a8e5791a070fb3bb625687f4b7">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_euclidean_mean_8hpp_source.html#l00344">344</a> of file <a class="el" href="_euclidean_mean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="a30a419b046972de2b566cc220dcae618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a419b046972de2b566cc220dcae618">&#9670;&nbsp;</a></span>make_GaussianDistribution() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename Cov , typename re  = std::mt19937, std::enable_if_t&lt; typed_matrix&lt; M &gt; and column_vector&lt; M &gt; and untyped_columns&lt; M &gt; and covariance&lt; Cov &gt; and equivalent_to&lt; typename MatrixTraits&lt; M &gt;::RowCoefficients, typename MatrixTraits&lt; Cov &gt;::RowCoefficients &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_GaussianDistribution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>. </td></tr>
    <tr><td class="paramname">Cov</td><td>A <a class="el" href="namespace_open_kalman.html#acc62cd53d66b676058de97da3caaca3b">covariance</a>. </td></tr>
    <tr><td class="paramname">re</td><td>A random number engine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a> or <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>. </td></tr>
    <tr><td class="paramname">Cov</td><td>A <a class="el" href="namespace_open_kalman.html#acc62cd53d66b676058de97da3caaca3b">covariance</a> or <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>. </td></tr>
    <tr><td class="paramname">re</td><td>A random number engine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload excludes the case in which M is <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a> <em>and</em> Cov is <a class="el" href="namespace_open_kalman.html#acc62cd53d66b676058de97da3caaca3b">covariance</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_gaussian_distribution_8hpp_source.html#l00682">682</a> of file <a class="el" href="_gaussian_distribution_8hpp_source.html">GaussianDistribution.hpp</a>.</p>

</div>
</div>
<a id="a8c01a83c83d3a23aafb59dcd527daed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c01a83c83d3a23aafb59dcd527daed1">&#9670;&nbsp;</a></span>make_GaussianDistribution() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename M , typename Cov , typename re  = std::mt19937, std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt; and column_vector&lt; M &gt; and covariance_nestable&lt; Cov &gt; and(MatrixTraits&lt; M &gt;::dimension==MatrixTraits&lt; Cov &gt;::dimension), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_GaussianDistribution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The types of the coefficients for the distribution. </td></tr>
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a> </td></tr>
    <tr><td class="paramname">Cov</td><td>A <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>. </td></tr>
    <tr><td class="paramname">re</td><td>A random number engine </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="_gaussian_distribution_8hpp_source.html#l00747">747</a> of file <a class="el" href="_gaussian_distribution_8hpp_source.html">GaussianDistribution.hpp</a>.</p>

</div>
</div>
<a id="a131455a38340a120002aca624717d3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131455a38340a120002aca624717d3d4">&#9670;&nbsp;</a></span>make_GaussianDistribution() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D , std::enable_if_t&lt; gaussian_distribution&lt; D &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_GaussianDistribution </td>
          <td>(</td>
          <td class="paramtype">D &amp;&amp;&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>Another <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_gaussian_distribution_8hpp_source.html#l00523">523</a> of file <a class="el" href="_gaussian_distribution_8hpp_source.html">GaussianDistribution.hpp</a>.</p>

</div>
</div>
<a id="ac2d0c0d4d3f9bab0130dbcd6654617c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d0c0d4d3f9bab0130dbcd6654617c0">&#9670;&nbsp;</a></span>make_GaussianDistribution() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename re  = std::mt19937, typename M , typename Cov , std::enable_if_t&lt;(not coefficients&lt; re &gt;) and typed_matrix&lt; M &gt; and column_vector&lt; M &gt; and untyped_columns&lt; M &gt; and square_matrix&lt; Cov &gt; and(covariance&lt; Cov &gt; or typed_matrix&lt; Cov &gt;) and(equivalent_to&lt; typename MatrixTraits&lt; M &gt;::RowCoefficients, typename MatrixTraits&lt; Cov &gt;::RowCoefficients &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_GaussianDistribution </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cov &amp;&amp;&#160;</td>
          <td class="paramname"><em>cov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">re</td><td>A random number engine. </td></tr>
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>. </td></tr>
    <tr><td class="paramname">Cov</td><td>A <a class="el" href="namespace_open_kalman.html#acc62cd53d66b676058de97da3caaca3b">covariance</a> or <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">re</td><td>A random number engine. </td></tr>
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>. </td></tr>
    <tr><td class="paramname">Cov</td><td>A <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a> or <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">re</td><td>A random number engine. </td></tr>
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>. </td></tr>
    <tr><td class="paramname">Cov</td><td>A <a class="el" href="namespace_open_kalman.html#acc62cd53d66b676058de97da3caaca3b">covariance</a>, <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>, <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>, or <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_gaussian_distribution_8hpp_source.html#l00547">547</a> of file <a class="el" href="_gaussian_distribution_8hpp_source.html">GaussianDistribution.hpp</a>.</p>

</div>
</div>
<a id="a87f53ae8006d8068435df09f99c8baf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f53ae8006d8068435df09f99c8baf0">&#9670;&nbsp;</a></span>make_GaussianDistribution() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename re  = std::mt19937, typename M , typename Cov , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and column_vector&lt; M &gt; and(covariance_nestable&lt; Cov &gt; or typed_matrix_nestable&lt; Cov &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_GaussianDistribution </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cov &amp;&amp;&#160;</td>
          <td class="paramname"><em>cov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The types of the coefficients for the distribution. </td></tr>
    <tr><td class="paramname">re</td><td>A random number engine. </td></tr>
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>. </td></tr>
    <tr><td class="paramname">Cov</td><td>A <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a> or <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespace_open_kalman.html#af9367eb4d7b08c961db76037c1926531">gaussian_distribution</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="_gaussian_distribution_8hpp_source.html#l00647">647</a> of file <a class="el" href="_gaussian_distribution_8hpp_source.html">GaussianDistribution.hpp</a>.</p>

</div>
</div>
<a id="a5647c719085536c8fa6851836c5d03ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5647c719085536c8fa6851836c5d03ea">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RowCoefficients , typename ColumnCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and coefficients&lt; ColumnCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size) and(MatrixTraits&lt; M &gt;::columns==ColumnCoefficients::size), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RowCoefficients</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">ColumnCoefficients</td><td>The coefficient types corresponding to the columns. </td></tr>
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new matrix is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00465">465</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="affa3556236800e6eecb365ea76199ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affa3556236800e6eecb365ea76199ae5">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new matrix is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00482">482</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="afdb3bd9bc6f894eb4b03b48b8a0d850c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb3bd9bc6f894eb4b03b48b8a0d850c">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A typed_matrix (i.e., <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a>, <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>, or <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00436">436</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="a73e36fbdb948bce537bd17d75114f712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e36fbdb948bce537bd17d75114f712">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RowCoefficients , typename ColumnCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and coefficients&lt; ColumnCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size) and(MatrixTraits&lt; M &gt;::columns==ColumnCoefficients::size), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RowCoefficients</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">ColumnCoefficients</td><td>The coefficient types corresponding to the columns. </td></tr>
    <tr><td class="paramname">M</td><td>A typed_matrix_nestable with size matching RowCoefficients and ColumnCoefficients. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00365">365</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="a71be5796e548bfdb501444c727d9f372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71be5796e548bfdb501444c727d9f372">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RowCoefficients , typename M , std::enable_if_t&lt; coefficients&lt; RowCoefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==RowCoefficients::size), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The column coefficients are default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RowCoefficients</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>A typed_matrix_nestable with size matching RowCoefficients and ColumnCoefficients. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00385">385</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="af82be03cc51cb7a0b7b8c2eb14c6c0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82be03cc51cb7a0b7b8c2eb14c6c0bb">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> object from a covariance object.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>A covariance object (i.e., <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>, <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_matrix_8hpp_source.html#l00401">401</a> of file <a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="a258fd14762cd857444878183fc128c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258fd14762cd857444878183fc128c73">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(MatrixTraits&lt; M &gt;::dimension==Coefficients::size), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new matrix is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_mean_8hpp_source.html#l00508">508</a> of file <a class="el" href="_mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="a6abae6f929b546e22c34d58a1595303f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abae6f929b546e22c34d58a1595303f">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new mean is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_mean_8hpp_source.html#l00525">525</a> of file <a class="el" href="_mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="a342c91bcf1ffd94505e1c4336f95d43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342c91bcf1ffd94505e1c4336f95d43e">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and untyped_columns&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A typed_matrix (i.e., <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a>, <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a>, or <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a>). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_mean_8hpp_source.html#l00483">483</a> of file <a class="el" href="_mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="ad74553d9027b3d93c5020f13c0570a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74553d9027b3d93c5020f13c0570a8b">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename M , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; M &gt; and(Coefficients::size==MatrixTraits&lt; M &gt;::dimension), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>A typed_matrix_nestable with size matching ColumnCoefficients. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_mean_8hpp_source.html#l00448">448</a> of file <a class="el" href="_mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="ab6cb56942738ea287feeb456de8a1ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cb56942738ea287feeb456de8a1ee8">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; typed_matrix_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_mean_8hpp_source.html#l00466">466</a> of file <a class="el" href="_mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="acd840cc6cadb87e6bae5724c66b575a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd840cc6cadb87e6bae5724c66b575a9">&#9670;&nbsp;</a></span>make_native_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::make_native_matrix </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert to a self-contained <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> matrix.</p>
<p>Convert to a self-contained <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> matrix (wrapping any angles, if necessary). </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00068">68</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="ad137ac22381d6cd2d06a57b96a3f4a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad137ac22381d6cd2d06a57b96a3f4a83">&#9670;&nbsp;</a></span>make_self_contained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename Arg , std::enable_if_t&lt; gaussian_distribution&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::make_self_contained </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert vector object to self-contained version (wrapping any angles).</p>
<p>Convert to self-contained version of the covariance matrix.</p>
<p>If any types Ts are included, Arg is considered self-contained if every Ts is an lvalue reference. This is to allow a function to return a non-self-contained value so long as it depends on an lvalue reference to a variable that is accessible to the context in which the function is called. </p>

<p class="definition">Definition at line <a class="el" href="_gaussian_distribution_8hpp_source.html#l00815">815</a> of file <a class="el" href="_gaussian_distribution_8hpp_source.html">GaussianDistribution.hpp</a>.</p>

</div>
</div>
<a id="a22473ed4dd2db3f2eaa82a5dbd7e799d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22473ed4dd2db3f2eaa82a5dbd7e799d">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , TriangleType triangle_type, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l01088">1088</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="a00898738e33dfb03d94f4289d6855633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00898738e33dfb03d94f4289d6855633">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> based on a <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>.</p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>, with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l01109">1109</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="a1e2f1e0973fe26e185ec3d80837fcd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2f1e0973fe26e185ec3d80837fcd67">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt;(covariance_nestable&lt; Arg &gt; or typed_matrix_nestable&lt; Arg &gt;) and square_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> based on a <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>.</p>
<p>Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a <a class="el" href="namespace_open_kalman.html#a4bf939b25b2e4bfc1162f21533ae490e">square_root_covariance</a>.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.  The coefficients will be <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l01133">1133</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="a3983a57927dc746dcc5a6c877337a686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3983a57927dc746dcc5a6c877337a686">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and covariance_nestable&lt; Arg &gt; and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>.</p>
<p>Make a default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a self-adjoint <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a> with size matching <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Arg</td><td>A square, self-adjoint <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l01002">1002</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="ae9adb3eae588123a5f80eafea891a0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9adb3eae588123a5f80eafea891a0c5">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance_nestable&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> based on another <a class="el" href="namespace_open_kalman.html#a4bf939b25b2e4bfc1162f21533ae490e">square_root_covariance</a>.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A <a class="el" href="namespace_open_kalman.html#a19898d83f3f0b722b834acac97f7c17e">covariance_nestable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l01020">1020</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="adc58f602f72886f980090ec403f86f2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc58f602f72886f980090ec403f86f2e">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , TriangleType triangle_type = TriangleType::lower, typename Arg , std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and typed_matrix_nestable&lt; Arg &gt; and(not covariance_nestable&lt; Arg &gt;) and(triangle_type==TriangleType::lower or triangle_type==TriangleType::upper) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::dimension) and(Coefficients::size==MatrixTraits&lt; Arg &gt;::columns), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Arg</td><td>A square, self-adjoint <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a> with size matching <a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_square_root_covariance_8hpp_source.html#l01047">1047</a> of file <a class="el" href="_square_root_covariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="a05f9155e6a8c211c128af8bdc3f02c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f9155e6a8c211c128af8bdc3f02c14">&#9670;&nbsp;</a></span>make_Transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , std::enable_if_t&lt; is_linearized_function_v&lt; Function, 1 &gt; and not is_linearized_function_v&lt; Function, 2 &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_Transformation </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a transformation from a first-order linearized transformation defining a Jacobian function. Substitution failure if the transformation function is polymorphic.</p>
<p>Make a transformation from a second-order linearized transformation defining Jacobian and Hessian functions. Substitution failure if the transformation function is polymorphic. </p>

<p class="definition">Definition at line <a class="el" href="_transformation_8hpp_source.html#l00244">244</a> of file <a class="el" href="_transformation_8hpp_source.html">Transformation.hpp</a>.</p>

</div>
</div>
<a id="aff013f3acace99fb1191fd677bdaba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff013f3acace99fb1191fd677bdaba67">&#9670;&nbsp;</a></span>Matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , std::enable_if_t&lt; typed_matrix&lt; V &gt; and not euclidean_transformed&lt; V &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_matrix.html">OpenKalman::Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_open_kalman_1_1_matrix.html">Matrix</a>&lt; typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::RowCoefficients, typename <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::ColumnCoefficients, <a class="el" href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">passable_t</a>&lt; <a class="el" href="namespace_open_kalman.html#abc8e1017c2a892423e656ba212290b74">nested_matrix_t</a>&lt; V &gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deduce parameter types from a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>.</p>
<p>Deduce template parameters from a Euclidean-transformed typed matrix. </p>

</div>
</div>
<a id="a4811b89985f03ba5fe3b5c6a54b9e49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4811b89985f03ba5fe3b5c6a54b9e49b">&#9670;&nbsp;</a></span>Mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , std::enable_if_t&lt; typed_matrix_nestable&lt; V &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_mean.html">OpenKalman::Mean</a> </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_open_kalman_1_1_mean.html">Mean</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; V &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">passable_t</a>&lt; V &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deduce template parameters from a Euclidean-transformed typed matrix.</p>
<p>Deduce template parameters from a non-Euclidean-transformed typed matrix. </p>

</div>
</div>
<a id="ae8c9b539547601ae4b033c3ffe425b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c9b539547601ae4b033c3ffe425b5b">&#9670;&nbsp;</a></span>QR_decomposition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; typed_matrix&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a QR decomposition of matrix A=Q[U|0], where U is an upper-triangular matrix, and Q is orthogonal. Returns U as a Cholesky upper-triangular <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>. All row coefficients must be axes. </p>

<p class="definition">Definition at line <a class="el" href="typed-matrix-overloads_8hpp_source.html#l00281">281</a> of file <a class="el" href="typed-matrix-overloads_8hpp_source.html">typed-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="a2c53f3473e7552a36723afca9d5588ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c53f3473e7552a36723afca9d5588ad">&#9670;&nbsp;</a></span>QR_decomposition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; covariance&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a QR decomposition of matrix A=Q[U,0], where U is an upper-triangular matrix, and Q is orthogonal. Returns L as an upper-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00241">241</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a1b2366114bcb1637da7288fb572e738e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2366114bcb1637da7288fb572e738e">&#9670;&nbsp;</a></span>randomize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , template&lt; typename Scalar &gt; typename distribution_type = std::normal_distribution, typename random_number_engine  = std::mt19937, typename... Params, std::enable_if_t&lt; typed_matrix&lt; ReturnType &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::randomize </td>
          <td>(</td>
          <td class="paramtype">Params...&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill a typed matrix with random values selected from a random distribution. The Gaussian distribution has zero mean and standard deviation sigma (1, if not specified). </p>

<p class="definition">Definition at line <a class="el" href="typed-matrix-overloads_8hpp_source.html#l00907">907</a> of file <a class="el" href="typed-matrix-overloads_8hpp_source.html">typed-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="af64ea73d28077cecfc217139a9d77813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64ea73d28077cecfc217139a9d77813">&#9670;&nbsp;</a></span>reduce_columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; typed_matrix&lt; Arg &gt; and((MatrixTraits&lt; Arg &gt;::columns==1) or untyped_columns&lt; Arg &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::reduce_columns </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="typed-matrix-overloads_8hpp_source.html#l00229">229</a> of file <a class="el" href="typed-matrix-overloads_8hpp_source.html">typed-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="a3be486e53ad3cb44d7ea46c4201f4ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be486e53ad3cb44d7ea46c4201f4ce5">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename A , std::enable_if_t&lt; covariance&lt; M &gt; and typed_matrix&lt; A &gt; and equivalent_to&lt; typename MatrixTraits&lt; A &gt;::ColumnCoefficients, typename MatrixTraits&lt; M &gt;::RowCoefficients &gt; and(not euclidean_transformed&lt; A &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::scale </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespace_open_kalman.html#acc62cd53d66b676058de97da3caaca3b">covariance</a>. </td></tr>
    <tr><td class="paramname">A</td><td>A <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>.  A scaled covariance Arg is A * Arg * adjoint(A). A scaled square root covariance L or U is also scaled accordingly, so that scale(L * adjoint(L)) = A * L * adjoint(L) * adjoint(A) or scale(adjoint(U) * U) = A * adjoint(U) * U * adjoint(A). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="covariance-arithmetic_8hpp_source.html#l00573">573</a> of file <a class="el" href="covariance-arithmetic_8hpp_source.html">covariance-arithmetic.hpp</a>.</p>

</div>
</div>
<a id="a77f2335ea8a758c0b229c54cadc27aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f2335ea8a758c0b229c54cadc27aa1">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , typename S , std::enable_if_t&lt; covariance&lt; M &gt; and std::is_convertible_v&lt; S, typename MatrixTraits&lt; M &gt;::Scalar &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::scale </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale a covariance by a factor. Equivalent to multiplication by the square of a scalar. For a square root covariance, this is equivalent to multiplication by the scalar. </p>

<p class="definition">Definition at line <a class="el" href="covariance-arithmetic_8hpp_source.html#l00513">513</a> of file <a class="el" href="covariance-arithmetic_8hpp_source.html">covariance-arithmetic.hpp</a>.</p>

</div>
</div>
<a id="a3ef70489b68fd02e29dc2210aeaa4311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef70489b68fd02e29dc2210aeaa4311">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , std::enable_if_t&lt; covariance&lt; A &gt; and typed_matrix&lt; B &gt; and equivalent_to&lt; typename MatrixTraits&lt; A &gt;::RowCoefficients, typename MatrixTraits&lt; B &gt;::RowCoefficients &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::solve </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Solves AX = B for X, where X and B are means of the same type, and A is a square matrix with compatible types. If wrapping occurs, it will be both before for B and after for the X result. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00196">196</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a2bf46841af75eee02bfd52c1708831b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf46841af75eee02bfd52c1708831b7">&#9670;&nbsp;</a></span>split_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_diagonal </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split typed matrix into one or more typed matrices diagonally. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00354">354</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a313e2b8a742da23f4623c6bc4c295d5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313e2b8a742da23f4623c6bc4c295d5b">&#9670;&nbsp;</a></span>split_horizontal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_horizontal </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split typed matrix into one or more typed matrices horizontally. Column coefficients must all be <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a>.</p>
<p>Split typed matrix into one or more typed matrices horizontally. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00383">383</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a68dba71f80c4270929d21e416f1c8739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dba71f80c4270929d21e416f1c8739">&#9670;&nbsp;</a></span>split_vertical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Cs, typename M , std::enable_if_t&lt; covariance&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::split_vertical </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split typed matrix into one or more typed matrices vertically. </p>

<p class="definition">Definition at line <a class="el" href="covariance-overloads_8hpp_source.html#l00368">368</a> of file <a class="el" href="covariance-overloads_8hpp_source.html">covariance-overloads.hpp</a>.</p>

</div>
</div>
<a id="a2453977eb5e1c47f1e24d4ef557988eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2453977eb5e1c47f1e24d4ef557988eb">&#9670;&nbsp;</a></span>SquareRootCovariance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M , std::enable_if_t&lt; covariance_nestable&lt; M &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_square_root_covariance.html">OpenKalman::SquareRootCovariance</a> </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html">SquareRootCovariance</a>&lt; <a class="el" href="namespace_open_kalman.html#ad7fbe21f478b7b06ac97b6eb6f5967c3">Axes</a>&lt; <a class="el" href="struct_open_kalman_1_1_matrix_traits.html">MatrixTraits</a>&lt; M &gt;::dimension &gt;, <a class="el" href="namespace_open_kalman.html#aa6babcf2fe72766cbfef2c7082b606b2">passable_t</a>&lt; M &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deduce <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> type from a square <a class="el" href="namespace_open_kalman.html#a5245fbf912b12a279acb815fcf7650d9">typed_matrix_nestable</a>.</p>
<p>Deduce <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> type from a square <a class="el" href="namespace_open_kalman.html#ae19962a38a87cd8c8003e48f42150145">typed_matrix</a>. </p>

</div>
</div>
<a id="abbd655dfd0d89b3b12ece39ab953e061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd655dfd0d89b3b12ece39ab953e061">&#9670;&nbsp;</a></span>Transformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename... TaylorDerivatives&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_open_kalman_1_1_transformation.html">OpenKalman::Transformation</a> </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TaylorDerivatives &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="struct_open_kalman_1_1_transformation.html">Transformation</a>&lt; Function, TaylorDerivatives... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deduction guides </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_open_kalman.html">OpenKalman</a></li>
    <li class="footer">Generated on Sat Mar 27 2021 20:52:53 for OpenKalman by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0 </li>
  </ul>
</div>
</body>
</html>
