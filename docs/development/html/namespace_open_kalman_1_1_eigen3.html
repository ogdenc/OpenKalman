<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenKalman: OpenKalman::Eigen3 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenKalman
   </div>
   <div id="projectbrief">An open-source, heading-only library for Kalman filters and other recursive filters</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespace_open_kalman_1_1_eigen3.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#typedef-members">Aliases</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">OpenKalman::Eigen3 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for all <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> interface definitions.  
<a href="namespace_open_kalman_1_1_eigen3.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_open_kalman_1_1_eigen3_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespace_open_kalman_1_1_eigen3_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for definitions internal to the <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> interface library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4213585dbf9ef23d61030a68523a827b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4213585dbf9ef23d61030a68523a827b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a4213585dbf9ef23d61030a68523a827b">eigen_native</a></td></tr>
<tr class="memdesc:a4213585dbf9ef23d61030a68523a827b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a native <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> matrix.  <a href="namespace_open_kalman_1_1_eigen3.html#a4213585dbf9ef23d61030a68523a827b">More...</a><br /></td></tr>
<tr class="separator:a4213585dbf9ef23d61030a68523a827b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1300ee43daf6076f8cfd0d2f822fe020"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1300ee43daf6076f8cfd0d2f822fe020"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a1300ee43daf6076f8cfd0d2f822fe020">eigen_self_adjoint_expr</a> = detail::is_eigen_self_adjoint_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:a1300ee43daf6076f8cfd0d2f822fe020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace19dd487311d8b674643ba2bb5513f3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace19dd487311d8b674643ba2bb5513f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ace19dd487311d8b674643ba2bb5513f3">eigen_triangular_expr</a> = detail::is_eigen_triangular_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:ace19dd487311d8b674643ba2bb5513f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d408b48a797fea59c2b1e5ecd532920"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8d408b48a797fea59c2b1e5ecd532920"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a8d408b48a797fea59c2b1e5ecd532920">eigen_diagonal_expr</a> = detail::is_eigen_diagonal_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:a8d408b48a797fea59c2b1e5ecd532920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a476c4cfb61d510f7d8b9773ad9527"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8a476c4cfb61d510f7d8b9773ad9527"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#aa8a476c4cfb61d510f7d8b9773ad9527">eigen_zero_expr</a> = detail::is_eigen_zero_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:aa8a476c4cfb61d510f7d8b9773ad9527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6a888caf6f486dadc2bafa6f526d6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf6a888caf6f486dadc2bafa6f526d6c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#aaf6a888caf6f486dadc2bafa6f526d6c">from_euclidean_expr</a> = detail::is_from_euclidean_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:aaf6a888caf6f486dadc2bafa6f526d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a369957b46435f66ac4cfd93eaa7f3e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1a369957b46435f66ac4cfd93eaa7f3e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a1a369957b46435f66ac4cfd93eaa7f3e">to_euclidean_expr</a> = detail::is_to_euclidean_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:a1a369957b46435f66ac4cfd93eaa7f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eea295d94923c613e461e6ec8d0c52b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5eea295d94923c613e461e6ec8d0c52b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a5eea295d94923c613e461e6ec8d0c52b">euclidean_expr</a> = <a class="el" href="namespace_open_kalman_1_1_eigen3.html#aaf6a888caf6f486dadc2bafa6f526d6c">from_euclidean_expr</a>&lt;T&gt; or <a class="el" href="namespace_open_kalman_1_1_eigen3.html#a1a369957b46435f66ac4cfd93eaa7f3e">to_euclidean_expr</a>&lt;T&gt;</td></tr>
<tr class="separator:a5eea295d94923c613e461e6ec8d0c52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cd699ad3fe06896706df1346cc4152"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a75cd699ad3fe06896706df1346cc4152"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a75cd699ad3fe06896706df1346cc4152">eigen_matrix</a> = <a class="el" href="namespace_open_kalman_1_1_eigen3.html#a4213585dbf9ef23d61030a68523a827b">eigen_native</a>&lt;T&gt; or <a class="el" href="namespace_open_kalman_1_1_eigen3.html#aa8a476c4cfb61d510f7d8b9773ad9527">eigen_zero_expr</a>&lt;T&gt;</td></tr>
<tr class="separator:a75cd699ad3fe06896706df1346cc4152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823cfdc848031e09f1b405d796220d90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a823cfdc848031e09f1b405d796220d90"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a823cfdc848031e09f1b405d796220d90">upper_storage_triangle</a> = detail::is_upper_storage_triangle&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:a823cfdc848031e09f1b405d796220d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6821f8a9abf88a0994495139d95b0d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba6821f8a9abf88a0994495139d95b0d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#aba6821f8a9abf88a0994495139d95b0d">lower_storage_triangle</a> = detail::is_lower_storage_triangle&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="separator:aba6821f8a9abf88a0994495139d95b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Aliases</h2></td></tr>
<tr class="memitem:ab5caa435d3ad3fbf96cdf5025dbb1742"><td class="memTemplParams" colspan="2"><a id="ab5caa435d3ad3fbf96cdf5025dbb1742"></a>
template&lt;typename NestedMatrix &gt; </td></tr>
<tr class="memitem:ab5caa435d3ad3fbf96cdf5025dbb1742"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ab5caa435d3ad3fbf96cdf5025dbb1742">IdentityMatrix</a> = Eigen::CwiseNullaryOp&lt; Eigen::internal::scalar_identity_op&lt; typename NestedMatrix::Scalar &gt;, NestedMatrix &gt;</td></tr>
<tr class="memdesc:ab5caa435d3ad3fbf96cdf5025dbb1742"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for the <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> identity matrix. <br /></td></tr>
<tr class="separator:ab5caa435d3ad3fbf96cdf5025dbb1742"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a254ef68edfc93e94556975d3635e640a"><td class="memTemplParams" colspan="2">template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a254ef68edfc93e94556975d3635e640a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a254ef68edfc93e94556975d3635e640a">make_matrix</a> (Args ... args)</td></tr>
<tr class="memdesc:a254ef68edfc93e94556975d3635e640a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a one-column <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> from a list of coefficients, with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.  <a href="namespace_open_kalman_1_1_eigen3.html#a254ef68edfc93e94556975d3635e640a">More...</a><br /></td></tr>
<tr class="separator:a254ef68edfc93e94556975d3635e640a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60ae4e5bdee892abe4344e998cd0e4a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename RowCoefficients , typename ColumnCoefficients  = RowCoefficients, std::enable_if_t&lt; std::is_arithmetic_v&lt; Scalar &gt; and coefficients&lt; RowCoefficients &gt; and coefficients&lt; ColumnCoefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac60ae4e5bdee892abe4344e998cd0e4a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ac60ae4e5bdee892abe4344e998cd0e4a">make_matrix</a> ()</td></tr>
<tr class="memdesc:ac60ae4e5bdee892abe4344e998cd0e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> based on a scalar type and row and column coefficients.  <a href="namespace_open_kalman_1_1_eigen3.html#ac60ae4e5bdee892abe4344e998cd0e4a">More...</a><br /></td></tr>
<tr class="separator:ac60ae4e5bdee892abe4344e998cd0e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c9a6b195d8d4fbae6ba1878c1bb335e"><td class="memTemplParams" colspan="2">template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0c9a6b195d8d4fbae6ba1878c1bb335e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a0c9a6b195d8d4fbae6ba1878c1bb335e">make_mean</a> (Args ... args)</td></tr>
<tr class="memdesc:a0c9a6b195d8d4fbae6ba1878c1bb335e"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a one-column <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> from a list of coefficients, with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.  <a href="namespace_open_kalman_1_1_eigen3.html#a0c9a6b195d8d4fbae6ba1878c1bb335e">More...</a><br /></td></tr>
<tr class="separator:a0c9a6b195d8d4fbae6ba1878c1bb335e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab958f7a462b5c8a0f8a0b27fcfd8e971"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Coefficients , std::size_t cols = 1, std::enable_if_t&lt; std::is_arithmetic_v&lt; Scalar &gt; and coefficients&lt; Coefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab958f7a462b5c8a0f8a0b27fcfd8e971"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ab958f7a462b5c8a0f8a0b27fcfd8e971">make_mean</a> ()</td></tr>
<tr class="memdesc:ab958f7a462b5c8a0f8a0b27fcfd8e971"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> based on a scalar type, a set of row coefficients, and a number of columns.  <a href="namespace_open_kalman_1_1_eigen3.html#ab958f7a462b5c8a0f8a0b27fcfd8e971">More...</a><br /></td></tr>
<tr class="separator:ab958f7a462b5c8a0f8a0b27fcfd8e971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace928597d23cded16c159a1929748fa4"><td class="memTemplParams" colspan="2">template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ace928597d23cded16c159a1929748fa4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ace928597d23cded16c159a1929748fa4">make_euclidean_mean</a> (Args ... args) noexcept</td></tr>
<tr class="memdesc:ace928597d23cded16c159a1929748fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a one-column <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> from a list of coefficients, with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.  <a href="namespace_open_kalman_1_1_eigen3.html#ace928597d23cded16c159a1929748fa4">More...</a><br /></td></tr>
<tr class="separator:ace928597d23cded16c159a1929748fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28355caa34a0d30cb75e07dea788f49b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Coefficients , std::size_t cols = 1, std::enable_if_t&lt; std::is_arithmetic_v&lt; Scalar &gt; and coefficients&lt; Coefficients &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a28355caa34a0d30cb75e07dea788f49b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a28355caa34a0d30cb75e07dea788f49b">make_euclidean_mean</a> ()</td></tr>
<tr class="memdesc:a28355caa34a0d30cb75e07dea788f49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> based on a scalar type, row coefficients, and a number of columns.  <a href="namespace_open_kalman_1_1_eigen3.html#a28355caa34a0d30cb75e07dea788f49b">More...</a><br /></td></tr>
<tr class="separator:a28355caa34a0d30cb75e07dea788f49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928f12401b0fce7dae651a934008030a"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , TriangleType triangle_type, typename Scalar  = double, std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and(triangle_type==TriangleType::lower or triangle_type==TriangleType::upper) and std::is_arithmetic_v&lt; Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a928f12401b0fce7dae651a934008030a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a928f12401b0fce7dae651a934008030a">make_covariance</a> ()</td></tr>
<tr class="memdesc:a928f12401b0fce7dae651a934008030a"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>, with nested triangular type, from a list of coefficients.  <a href="namespace_open_kalman_1_1_eigen3.html#a928f12401b0fce7dae651a934008030a">More...</a><br /></td></tr>
<tr class="separator:a928f12401b0fce7dae651a934008030a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c71ab9b79246e22a2834dce8c360c51"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , TriangleType triangle_type = TriangleType::lower, typename Scalar  = double, std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and(triangle_type==TriangleType::lower or triangle_type==TriangleType::upper) and std::is_arithmetic_v&lt; Scalar &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3c71ab9b79246e22a2834dce8c360c51"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a3c71ab9b79246e22a2834dce8c360c51">make_square_root_covariance</a> ()</td></tr>
<tr class="memdesc:a3c71ab9b79246e22a2834dce8c360c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a list of coefficients.  <a href="namespace_open_kalman_1_1_eigen3.html#a3c71ab9b79246e22a2834dce8c360c51">More...</a><br /></td></tr>
<tr class="separator:a3c71ab9b79246e22a2834dce8c360c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72cc88064aa1729df7d7b09ae554bebe"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a72cc88064aa1729df7d7b09ae554bebe"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a72cc88064aa1729df7d7b09ae554bebe">make_native_matrix</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a72cc88064aa1729df7d7b09ae554bebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e16a8d6ebf133a37fad616756a92cc"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a40e16a8d6ebf133a37fad616756a92cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a40e16a8d6ebf133a37fad616756a92cc">make_self_contained</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a40e16a8d6ebf133a37fad616756a92cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to self-contained version of the matrix.  <a href="namespace_open_kalman_1_1_eigen3.html#a40e16a8d6ebf133a37fad616756a92cc">More...</a><br /></td></tr>
<tr class="separator:a40e16a8d6ebf133a37fad616756a92cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fa7ebc6d79d4db4418c65e9603b4cf"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; from_euclidean_expr&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af5fa7ebc6d79d4db4418c65e9603b4cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#af5fa7ebc6d79d4db4418c65e9603b4cf">to_euclidean</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:af5fa7ebc6d79d4db4418c65e9603b4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d390585998024a682e322f235c0c708"><td class="memTemplParams" colspan="2">template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; from_euclidean_expr&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8d390585998024a682e322f235c0c708"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a8d390585998024a682e322f235c0c708">wrap_angles</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a8d390585998024a682e322f235c0c708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1b813053fe755883d24c7a1933c96c"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , std::enable_if_t&lt; euclidean_expr&lt; A &gt; and eigen_matrix&lt; B &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8d1b813053fe755883d24c7a1933c96c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a8d1b813053fe755883d24c7a1933c96c">solve</a> (A &amp;&amp;a, B &amp;&amp;b) noexcept</td></tr>
<tr class="separator:a8d1b813053fe755883d24c7a1933c96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e68e2f00653ec30dffdea1a77853f2f"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; euclidean_expr&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1e68e2f00653ec30dffdea1a77853f2f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a1e68e2f00653ec30dffdea1a77853f2f">LQ_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:a1e68e2f00653ec30dffdea1a77853f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497d7ef2f9c7ff140038d1e101c11899"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a497d7ef2f9c7ff140038d1e101c11899"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a497d7ef2f9c7ff140038d1e101c11899">QR_decomposition</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="separator:a497d7ef2f9c7ff140038d1e101c11899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28af8b2669223699d2f4a19903cb2d48"><td class="memTemplParams" colspan="2">template&lt;typename V , typename ... Vs, std::enable_if_t&lt;(to_euclidean_expr&lt; V &gt; and ... and to_euclidean_expr&lt; Vs &gt;) or(from_euclidean_expr&lt; V &gt; and ... and from_euclidean_expr&lt; Vs &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a28af8b2669223699d2f4a19903cb2d48"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a28af8b2669223699d2f4a19903cb2d48">concatenate_vertical</a> (V &amp;&amp;v, Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:a28af8b2669223699d2f4a19903cb2d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more EuclideanExpr objects vertically.  <a href="namespace_open_kalman_1_1_eigen3.html#a28af8b2669223699d2f4a19903cb2d48">More...</a><br /></td></tr>
<tr class="separator:a28af8b2669223699d2f4a19903cb2d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7be967305c09eb5cf5ae7c0b29a2c5"><td class="memTemplParams" colspan="2">template&lt;typename V , typename ... Vs, std::enable_if_t&lt;(to_euclidean_expr&lt; V &gt; and ... and to_euclidean_expr&lt; Vs &gt;) or(from_euclidean_expr&lt; V &gt; and ... and from_euclidean_expr&lt; Vs &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:add7be967305c09eb5cf5ae7c0b29a2c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#add7be967305c09eb5cf5ae7c0b29a2c5">concatenate_horizontal</a> (V &amp;&amp;v, Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:add7be967305c09eb5cf5ae7c0b29a2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more EuclideanExpr objects horizontally.  <a href="namespace_open_kalman_1_1_eigen3.html#add7be967305c09eb5cf5ae7c0b29a2c5">More...</a><br /></td></tr>
<tr class="separator:add7be967305c09eb5cf5ae7c0b29a2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbefa89d53756a3a8d2bf8d3b324a028"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:acbefa89d53756a3a8d2bf8d3b324a028"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#acbefa89d53756a3a8d2bf8d3b324a028">split_vertical</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:acbefa89d53756a3a8d2bf8d3b324a028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into one or more Euclidean expressions vertically.  <a href="namespace_open_kalman_1_1_eigen3.html#acbefa89d53756a3a8d2bf8d3b324a028">More...</a><br /></td></tr>
<tr class="separator:acbefa89d53756a3a8d2bf8d3b324a028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2dafab2bccd64e00f1938aa98987938"><td class="memTemplParams" colspan="2">template&lt;typename F , bool , typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ae2dafab2bccd64e00f1938aa98987938"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ae2dafab2bccd64e00f1938aa98987938">split_vertical</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:ae2dafab2bccd64e00f1938aa98987938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into one or more Euclidean expressions vertically.  <a href="namespace_open_kalman_1_1_eigen3.html#ae2dafab2bccd64e00f1938aa98987938">More...</a><br /></td></tr>
<tr class="separator:ae2dafab2bccd64e00f1938aa98987938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71465ec5623615f13128c205cc69431"><td class="memTemplParams" colspan="2">template&lt;typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and(coefficients&lt; Cs &gt; and ...), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad71465ec5623615f13128c205cc69431"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ad71465ec5623615f13128c205cc69431">split_vertical</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:ad71465ec5623615f13128c205cc69431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into one or more Euclidean expressions vertically.  <a href="namespace_open_kalman_1_1_eigen3.html#ad71465ec5623615f13128c205cc69431">More...</a><br /></td></tr>
<tr class="separator:ad71465ec5623615f13128c205cc69431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0b55888df2839382ee04cb80505158"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3f0b55888df2839382ee04cb80505158"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a3f0b55888df2839382ee04cb80505158">split_horizontal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a3f0b55888df2839382ee04cb80505158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into one or more Euclidean expressions horizontally.  <a href="namespace_open_kalman_1_1_eigen3.html#a3f0b55888df2839382ee04cb80505158">More...</a><br /></td></tr>
<tr class="separator:a3f0b55888df2839382ee04cb80505158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2dd314550c781b9787caf468eb996d"><td class="memTemplParams" colspan="2">template&lt;typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and(coefficients&lt; Cs &gt; and ...), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aab2dd314550c781b9787caf468eb996d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#aab2dd314550c781b9787caf468eb996d">split_horizontal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:aab2dd314550c781b9787caf468eb996d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into one or more Euclidean expressions horizontally.  <a href="namespace_open_kalman_1_1_eigen3.html#aab2dd314550c781b9787caf468eb996d">More...</a><br /></td></tr>
<tr class="separator:aab2dd314550c781b9787caf468eb996d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9ead984aa7bb1198e7575fb67574ff"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8f9ead984aa7bb1198e7575fb67574ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a8f9ead984aa7bb1198e7575fb67574ff">split_diagonal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a8f9ead984aa7bb1198e7575fb67574ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into one or more Euclidean expressions diagonally. The valuated expression must be square.  <a href="namespace_open_kalman_1_1_eigen3.html#a8f9ead984aa7bb1198e7575fb67574ff">More...</a><br /></td></tr>
<tr class="separator:a8f9ead984aa7bb1198e7575fb67574ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffba4a479480e5a0e9fd48d71634dc3"><td class="memTemplParams" colspan="2">template&lt;typename F , bool , typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7ffba4a479480e5a0e9fd48d71634dc3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a7ffba4a479480e5a0e9fd48d71634dc3">split_diagonal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a7ffba4a479480e5a0e9fd48d71634dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into one or more Euclidean expressions diagonally. The valuated expression must be square.  <a href="namespace_open_kalman_1_1_eigen3.html#a7ffba4a479480e5a0e9fd48d71634dc3">More...</a><br /></td></tr>
<tr class="separator:a7ffba4a479480e5a0e9fd48d71634dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5720846529fd822cec40bce7393b20"><td class="memTemplParams" colspan="2">template&lt;typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and(coefficients&lt; Cs &gt; and ...), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4d5720846529fd822cec40bce7393b20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a4d5720846529fd822cec40bce7393b20">split_diagonal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a4d5720846529fd822cec40bce7393b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into one or more Euclidean expressions diagonally. The valuated expression must be square.  <a href="namespace_open_kalman_1_1_eigen3.html#a4d5720846529fd822cec40bce7393b20">More...</a><br /></td></tr>
<tr class="separator:a4d5720846529fd822cec40bce7393b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3586bb1bfaaeb0c2ca362c2b77a167f0"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and element_gettable&lt; nested_matrix_t&lt; Arg &gt;, 2 &gt; and(not to_euclidean_expr&lt; nested_matrix_t&lt; Arg &gt;&gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3586bb1bfaaeb0c2ca362c2b77a167f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a3586bb1bfaaeb0c2ca362c2b77a167f0">get_element</a> (Arg &amp;&amp;arg, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:a3586bb1bfaaeb0c2ca362c2b77a167f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i, j) of <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_to_euclidean_expr.html" title="An expression that transforms coefficients into Euclidean space for proper wrapping.">ToEuclideanExpr</a> or <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_from_euclidean_expr.html" title="An expression that transforms angular or other modular coefficients back from Euclidean space.">FromEuclideanExpr</a> matrix arg.  <a href="namespace_open_kalman_1_1_eigen3.html#a3586bb1bfaaeb0c2ca362c2b77a167f0">More...</a><br /></td></tr>
<tr class="separator:a3586bb1bfaaeb0c2ca362c2b77a167f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af4344acb6f825cd4692282765fe1d5"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and element_gettable&lt; nested_matrix_t&lt; Arg &gt;, 1 &gt; and(not to_euclidean_expr&lt; nested_matrix_t&lt; Arg &gt;&gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1af4344acb6f825cd4692282765fe1d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a1af4344acb6f825cd4692282765fe1d5">get_element</a> (Arg &amp;&amp;arg, const std::size_t i)</td></tr>
<tr class="memdesc:a1af4344acb6f825cd4692282765fe1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i) of one-column <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_to_euclidean_expr.html" title="An expression that transforms coefficients into Euclidean space for proper wrapping.">ToEuclideanExpr</a> or <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_from_euclidean_expr.html" title="An expression that transforms angular or other modular coefficients back from Euclidean space.">FromEuclideanExpr</a> matrix arg.  <a href="namespace_open_kalman_1_1_eigen3.html#a1af4344acb6f825cd4692282765fe1d5">More...</a><br /></td></tr>
<tr class="separator:a1af4344acb6f825cd4692282765fe1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50497d8dae63621aee41c59dd017cb56"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and std::is_convertible_v&lt; Scalar, typename MatrixTraits&lt; Arg &gt;::Scalar &gt; and not to_euclidean_expr&lt; nested_matrix_t&lt; Arg &gt;&gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and MatrixTraits&lt; Arg &gt;::RowCoefficients::axes_only and element_settable&lt; nested_matrix_t&lt; Arg &gt;, 2 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a50497d8dae63621aee41c59dd017cb56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a50497d8dae63621aee41c59dd017cb56">set_element</a> (Arg &amp;arg, const Scalar s, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:a50497d8dae63621aee41c59dd017cb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i, j) of <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_to_euclidean_expr.html" title="An expression that transforms coefficients into Euclidean space for proper wrapping.">ToEuclideanExpr</a> or <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_from_euclidean_expr.html" title="An expression that transforms angular or other modular coefficients back from Euclidean space.">FromEuclideanExpr</a> matrix arg if coefficients are only axes.  <a href="namespace_open_kalman_1_1_eigen3.html#a50497d8dae63621aee41c59dd017cb56">More...</a><br /></td></tr>
<tr class="separator:a50497d8dae63621aee41c59dd017cb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5c36cca718e6c44e3081778f1d44b9"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and std::is_convertible_v&lt; Scalar, typename MatrixTraits&lt; Arg &gt;::Scalar &gt; and not to_euclidean_expr&lt; nested_matrix_t&lt; Arg &gt;&gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and MatrixTraits&lt; Arg &gt;::RowCoefficients::axes_only and element_settable&lt; nested_matrix_t&lt; Arg &gt;, 1 &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aff5c36cca718e6c44e3081778f1d44b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#aff5c36cca718e6c44e3081778f1d44b9">set_element</a> (Arg &amp;arg, const Scalar s, const std::size_t i)</td></tr>
<tr class="memdesc:aff5c36cca718e6c44e3081778f1d44b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set element (i) of <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_to_euclidean_expr.html" title="An expression that transforms coefficients into Euclidean space for proper wrapping.">ToEuclideanExpr</a> or <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_from_euclidean_expr.html" title="An expression that transforms angular or other modular coefficients back from Euclidean space.">FromEuclideanExpr</a> matrix arg if coefficients are only axes.  <a href="namespace_open_kalman_1_1_eigen3.html#aff5c36cca718e6c44e3081778f1d44b9">More...</a><br /></td></tr>
<tr class="separator:aff5c36cca718e6c44e3081778f1d44b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6c3b8a617930c6f44f164c6069fa3f"><td class="memTemplParams" colspan="2"><a id="a7e6c3b8a617930c6f44f164c6069fa3f"></a>
template&lt;std::size_t index, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a7e6c3b8a617930c6f44f164c6069fa3f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a7e6c3b8a617930c6f44f164c6069fa3f">column</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a7e6c3b8a617930c6f44f164c6069fa3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column <code>index</code> of Arg. Constexpr index version. <br /></td></tr>
<tr class="separator:a7e6c3b8a617930c6f44f164c6069fa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e10ebc64d6c4cb16307f79fe1dc1d5"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , template&lt; typename Scalar &gt; typename distribution_type = std::normal_distribution, typename random_number_engine  = std::mt19937, typename... Params, std::enable_if_t&lt; euclidean_expr&lt; ReturnType &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a95e10ebc64d6c4cb16307f79fe1dc1d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a95e10ebc64d6c4cb16307f79fe1dc1d5">randomize</a> (Params...params)</td></tr>
<tr class="separator:a95e10ebc64d6c4cb16307f79fe1dc1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a15d893ae0a0c3f51bdce5cd36cf10"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , std::size_t dimension, std::size_t columns = 1, typename ... Args, std::enable_if_t&lt; std::is_arithmetic_v&lt; Scalar &gt; and(std::is_convertible_v&lt; Args, Scalar &gt; and ...) and(sizeof...(Args)==dimension *columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a89a15d893ae0a0c3f51bdce5cd36cf10"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a89a15d893ae0a0c3f51bdce5cd36cf10">make_native_matrix</a> (const Args ... args)</td></tr>
<tr class="separator:a89a15d893ae0a0c3f51bdce5cd36cf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6d199e3f727fd414240f55358babc0"><td class="memTemplParams" colspan="2">template&lt;std::size_t dimension, std::size_t columns = 1, typename ... Args, std::enable_if_t&lt;(std::is_arithmetic_v&lt; Args &gt; and ...) and(sizeof...(Args)==dimension *columns), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aff6d199e3f727fd414240f55358babc0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#aff6d199e3f727fd414240f55358babc0">make_native_matrix</a> (const Args ... args)</td></tr>
<tr class="memdesc:aff6d199e3f727fd414240f55358babc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a native <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> matrix from a list of coefficients in row-major order.  <a href="namespace_open_kalman_1_1_eigen3.html#aff6d199e3f727fd414240f55358babc0">More...</a><br /></td></tr>
<tr class="separator:aff6d199e3f727fd414240f55358babc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a1c726349900040c32f91d5613d242"><td class="memTemplParams" colspan="2"><a id="a11a1c726349900040c32f91d5613d242"></a>
template&lt;typename ... Args, std::enable_if_t&lt; std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a11a1c726349900040c32f91d5613d242"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a11a1c726349900040c32f91d5613d242">make_native_matrix</a> (const Args ... args)</td></tr>
<tr class="memdesc:a11a1c726349900040c32f91d5613d242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a native <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> 1-column vector from a list of coefficients in row-major order. <br /></td></tr>
<tr class="separator:a11a1c726349900040c32f91d5613d242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a4e9c73dead8cfb0c7b4053d8f1d61"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B , std::enable_if_t&lt; eigen_matrix&lt; A &gt; and eigen_matrix&lt; B &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad8a4e9c73dead8cfb0c7b4053d8f1d61"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ad8a4e9c73dead8cfb0c7b4053d8f1d61">solve</a> (const A &amp;a, const B &amp;b)</td></tr>
<tr class="memdesc:ad8a4e9c73dead8cfb0c7b4053d8f1d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the equation AX = B for X. A is a diagonal matrix.  <a href="namespace_open_kalman_1_1_eigen3.html#ad8a4e9c73dead8cfb0c7b4053d8f1d61">More...</a><br /></td></tr>
<tr class="separator:ad8a4e9c73dead8cfb0c7b4053d8f1d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c2b6e93710caa2a2ad99029271d928"><td class="memTemplParams" colspan="2">template&lt;typename Arg , std::enable_if_t&lt; eigen_native&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a81c2b6e93710caa2a2ad99029271d928"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a81c2b6e93710caa2a2ad99029271d928">reduce_columns</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a81c2b6e93710caa2a2ad99029271d928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a column vector by taking the mean of each row in a set of column vectors.  <a href="namespace_open_kalman_1_1_eigen3.html#a81c2b6e93710caa2a2ad99029271d928">More...</a><br /></td></tr>
<tr class="separator:a81c2b6e93710caa2a2ad99029271d928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80481f0fb6c9e501127cc94af618729"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; eigen_native&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad80481f0fb6c9e501127cc94af618729"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ad80481f0fb6c9e501127cc94af618729">LQ_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:ad80481f0fb6c9e501127cc94af618729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a173007a7a7b04da8c85533ed38a210"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; eigen_native&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8a173007a7a7b04da8c85533ed38a210"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a8a173007a7a7b04da8c85533ed38a210">QR_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:a8a173007a7a7b04da8c85533ed38a210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24018b3631626078a5925a7e57442343"><td class="memTemplParams" colspan="2">template&lt;typename V , typename ... Vs, std::enable_if_t&lt;((eigen_matrix&lt; V &gt; or eigen_self_adjoint_expr&lt; V &gt; or eigen_triangular_expr&lt; V &gt; or eigen_diagonal_expr&lt; V &gt; or from_euclidean_expr&lt; V &gt;) and ... and(eigen_matrix&lt; Vs &gt; or eigen_self_adjoint_expr&lt; Vs &gt; or eigen_triangular_expr&lt; Vs &gt; or eigen_diagonal_expr&lt; Vs &gt; or from_euclidean_expr&lt; Vs &gt;)) and(not(eigen_diagonal_expr&lt; V &gt; and ... and eigen_diagonal_expr&lt; Vs &gt;)) and(not(from_euclidean_expr&lt; V &gt; and ... and from_euclidean_expr&lt; Vs &gt;)) and(not(eigen_self_adjoint_expr&lt; V &gt; and ... and eigen_self_adjoint_expr&lt; Vs &gt;)) and(not(eigen_triangular_expr&lt; V &gt; and ... and eigen_triangular_expr&lt; Vs &gt;)), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a24018b3631626078a5925a7e57442343"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a24018b3631626078a5925a7e57442343">concatenate_diagonal</a> (V &amp;&amp;v, Vs &amp;&amp;... vs) noexcept</td></tr>
<tr class="memdesc:a24018b3631626078a5925a7e57442343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more Eigen::MatrixBase objects diagonally.  <a href="namespace_open_kalman_1_1_eigen3.html#a24018b3631626078a5925a7e57442343">More...</a><br /></td></tr>
<tr class="separator:a24018b3631626078a5925a7e57442343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81be6a4f7c1dd83cc9e7bed633b29433"><td class="memTemplParams" colspan="2">template&lt;typename F , bool euclidean, typename RC , typename... RCs, typename Arg , std::enable_if_t&lt; eigen_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a81be6a4f7c1dd83cc9e7bed633b29433"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a81be6a4f7c1dd83cc9e7bed633b29433">split_vertical</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:a81be6a4f7c1dd83cc9e7bed633b29433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a81ba1ce1a4ea9b08b43852710cf7e"><td class="memTemplParams" colspan="2">template&lt;typename F , typename CC , typename... CCs, typename Arg , std::enable_if_t&lt; eigen_matrix&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab8a81ba1ce1a4ea9b08b43852710cf7e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ab8a81ba1ce1a4ea9b08b43852710cf7e">split_horizontal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:ab8a81ba1ce1a4ea9b08b43852710cf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54a8210943f63a85fb79b1651c14182"><td class="memTemplParams" colspan="2">template&lt;typename F , bool euclidean, typename C , typename... Cs, typename Arg , std::enable_if_t&lt; eigen_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af54a8210943f63a85fb79b1651c14182"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#af54a8210943f63a85fb79b1651c14182">split_diagonal</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="separator:af54a8210943f63a85fb79b1651c14182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3b22f8f4edac3d594f13fa11f83444"><td class="memTemplParams" colspan="2"><a id="a9a3b22f8f4edac3d594f13fa11f83444"></a>
template&lt;typename Arg , std::enable_if_t&lt; eigen_native&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a9a3b22f8f4edac3d594f13fa11f83444"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a9a3b22f8f4edac3d594f13fa11f83444">get_element</a> (const Arg &amp;arg, const std::size_t i, const std::size_t j)</td></tr>
<tr class="memdesc:a9a3b22f8f4edac3d594f13fa11f83444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i, j) of matrix arg. <br /></td></tr>
<tr class="separator:a9a3b22f8f4edac3d594f13fa11f83444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6477e1613fd22aae58dbfc57c117841"><td class="memTemplParams" colspan="2"><a id="aa6477e1613fd22aae58dbfc57c117841"></a>
template&lt;typename Arg , std::enable_if_t&lt; eigen_native&lt; Arg &gt; and MatrixTraits&lt; Arg &gt;::columns==1, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa6477e1613fd22aae58dbfc57c117841"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#aa6477e1613fd22aae58dbfc57c117841">get_element</a> (const Arg &amp;arg, const std::size_t i)</td></tr>
<tr class="memdesc:aa6477e1613fd22aae58dbfc57c117841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get element (i) of one-column matrix arg. <br /></td></tr>
<tr class="separator:aa6477e1613fd22aae58dbfc57c117841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfa4d456e05849bb9ab3b0e56dfc65d"><td class="memTemplParams" colspan="2"><a id="a8dfa4d456e05849bb9ab3b0e56dfc65d"></a>
template&lt;typename Arg , std::enable_if_t&lt; eigen_native&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8dfa4d456e05849bb9ab3b0e56dfc65d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a8dfa4d456e05849bb9ab3b0e56dfc65d">column</a> (Arg &amp;&amp;arg, const std::size_t index)</td></tr>
<tr class="memdesc:a8dfa4d456e05849bb9ab3b0e56dfc65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return column <code>index</code> of Arg. <br /></td></tr>
<tr class="separator:a8dfa4d456e05849bb9ab3b0e56dfc65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953012881d72bf25a25a087f3eb52a26"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , template&lt; typename &gt; typename distribution_type = std::normal_distribution, typename random_number_engine  = std::mt19937, typename... Params, std::enable_if_t&lt; eigen_matrix&lt; ReturnType &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a953012881d72bf25a25a087f3eb52a26"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a953012881d72bf25a25a087f3eb52a26">randomize</a> (Params &amp;&amp;...params)</td></tr>
<tr class="separator:a953012881d72bf25a25a087f3eb52a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227224e3e0a35d9498371fc6c137f0cd"><td class="memTemplParams" colspan="2"><a id="a227224e3e0a35d9498371fc6c137f0cd"></a>
template&lt;typename... Ts, typename Arg , std::enable_if_t&lt; Eigen3::eigen_diagonal_expr&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a227224e3e0a35d9498371fc6c137f0cd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a227224e3e0a35d9498371fc6c137f0cd">make_self_contained</a> (Arg &amp;&amp;arg) noexcept</td></tr>
<tr class="memdesc:a227224e3e0a35d9498371fc6c137f0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert to self_contained version. <br /></td></tr>
<tr class="separator:a227224e3e0a35d9498371fc6c137f0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd398ef2fa5e1b4e3a8a79d65ae4b25"><td class="memTemplParams" colspan="2"><a id="a4cd398ef2fa5e1b4e3a8a79d65ae4b25"></a>
template&lt;typename Arg , std::enable_if_t&lt; Eigen3::eigen_diagonal_expr&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a4cd398ef2fa5e1b4e3a8a79d65ae4b25"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a4cd398ef2fa5e1b4e3a8a79d65ae4b25">LQ_decomposition</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a4cd398ef2fa5e1b4e3a8a79d65ae4b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an LQ decomposition. Since it is diagonal, it returns the matrix unchanged. <br /></td></tr>
<tr class="separator:a4cd398ef2fa5e1b4e3a8a79d65ae4b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012047294017da2ed474b117e95afec4"><td class="memTemplParams" colspan="2"><a id="a012047294017da2ed474b117e95afec4"></a>
template&lt;typename Arg , std::enable_if_t&lt; Eigen3::eigen_diagonal_expr&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a012047294017da2ed474b117e95afec4"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a012047294017da2ed474b117e95afec4">QR_decomposition</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a012047294017da2ed474b117e95afec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a QR decomposition. Since it is diagonal, it returns the matrix unchanged. <br /></td></tr>
<tr class="separator:a012047294017da2ed474b117e95afec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda54550c3ae101cf184feb9c741a4f1"><td class="memTemplParams" colspan="2"><a id="afda54550c3ae101cf184feb9c741a4f1"></a>
template&lt;typename ... Args, std::enable_if_t&lt; std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:afda54550c3ae101cf184feb9c741a4f1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#afda54550c3ae101cf184feb9c741a4f1">SelfAdjointMatrix</a> (Args ...) -&gt; <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">SelfAdjointMatrix</a>&lt; Eigen::Matrix&lt; std::decay_t&lt; std::common_type_t&lt; Args... &gt;&gt;, <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">OpenKalman::internal::constexpr_sqrt</a>(sizeof...(Args)), <a class="el" href="namespace_open_kalman_1_1internal.html#a0de6ea03b16d31991db9843df173d674">OpenKalman::internal::constexpr_sqrt</a>(sizeof...(Args))&gt;, TriangleType::lower &gt;</td></tr>
<tr class="memdesc:afda54550c3ae101cf184feb9c741a4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, deduce a square, self-adjoint matrix. <br /></td></tr>
<tr class="separator:afda54550c3ae101cf184feb9c741a4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a30b32549d0a5f1e8138643ef13071b"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; Eigen3::eigen_self_adjoint_expr&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5a30b32549d0a5f1e8138643ef13071b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a5a30b32549d0a5f1e8138643ef13071b">QR_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:a5a30b32549d0a5f1e8138643ef13071b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad719d3ead30f7983801900b6225feac8"><td class="memTemplParams" colspan="2"><a id="ad719d3ead30f7983801900b6225feac8"></a>
template&lt;TriangleType t = TriangleType::lower, typename M , std::enable_if_t&lt; eigen_matrix&lt; M &gt; or eigen_diagonal_expr&lt; M &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad719d3ead30f7983801900b6225feac8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ad719d3ead30f7983801900b6225feac8">make_EigenTriangularMatrix</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:ad719d3ead30f7983801900b6225feac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, deduce a square, lower triangular matrix. <br /></td></tr>
<tr class="separator:ad719d3ead30f7983801900b6225feac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3622eb8c8e3ae9e4ef7280f2c50d18e2"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; Eigen3::eigen_triangular_expr&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a3622eb8c8e3ae9e4ef7280f2c50d18e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a3622eb8c8e3ae9e4ef7280f2c50d18e2">LQ_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:a3622eb8c8e3ae9e4ef7280f2c50d18e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57174029ea3969f2e57da1c8cc5b3fc"><td class="memTemplParams" colspan="2">template&lt;typename A , std::enable_if_t&lt; Eigen3::eigen_triangular_expr&lt; A &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad57174029ea3969f2e57da1c8cc5b3fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#ad57174029ea3969f2e57da1c8cc5b3fc">QR_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:ad57174029ea3969f2e57da1c8cc5b3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1517656da29a76c8f164b04e058ce012"><td class="memTemplParams" colspan="2"><a id="a1517656da29a76c8f164b04e058ce012"></a>
template&lt;typename Arg , std::enable_if_t&lt; Eigen3::eigen_zero_expr&lt; Arg &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a1517656da29a76c8f164b04e058ce012"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a1517656da29a76c8f164b04e058ce012">get_element</a> (const Arg &amp;, const std::size_t, const std::size_t)</td></tr>
<tr class="memdesc:a1517656da29a76c8f164b04e058ce012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element of a <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_zero_matrix.html" title="A wrapper type for an Eigen zero matrix.">ZeroMatrix</a> matrix. Always 0. <br /></td></tr>
<tr class="separator:a1517656da29a76c8f164b04e058ce012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e581a715b4bff7ac0a91dfcfe546caf"><td class="memTemplParams" colspan="2"><a id="a2e581a715b4bff7ac0a91dfcfe546caf"></a>
template&lt;typename Arg , std::enable_if_t&lt; Eigen3::eigen_zero_expr&lt; Arg &gt; and MatrixTraits&lt; Arg &gt;::columns==1, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2e581a715b4bff7ac0a91dfcfe546caf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_open_kalman_1_1_eigen3.html#a2e581a715b4bff7ac0a91dfcfe546caf">get_element</a> (const Arg &amp;, const std::size_t)</td></tr>
<tr class="memdesc:a2e581a715b4bff7ac0a91dfcfe546caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an element of a one-column <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_zero_matrix.html" title="A wrapper type for an Eigen zero matrix.">ZeroMatrix</a> matrix. Always 0. <br /></td></tr>
<tr class="separator:a2e581a715b4bff7ac0a91dfcfe546caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_diagonal_matrix.html">DiagonalMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagonal matrix, based on an <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> matrix.  <a href="struct_open_kalman_1_1_eigen3_1_1_diagonal_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_from_euclidean_expr.html">FromEuclideanExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression that transforms angular or other modular coefficients back from Euclidean space.  <a href="struct_open_kalman_1_1_eigen3_1_1_from_euclidean_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html">SelfAdjointMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A self-adjoint matrix, based on an <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> matrix.  <a href="struct_open_kalman_1_1_eigen3_1_1_self_adjoint_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_to_euclidean_expr.html">ToEuclideanExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression that transforms coefficients into Euclidean space for proper wrapping.  <a href="struct_open_kalman_1_1_eigen3_1_1_to_euclidean_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_triangular_matrix.html">TriangularMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A triangular matrix, based on an <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> matrix.  <a href="struct_open_kalman_1_1_eigen3_1_1_triangular_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_open_kalman_1_1_eigen3_1_1_zero_matrix.html">ZeroMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper type for an <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> zero matrix.  <a href="struct_open_kalman_1_1_eigen3_1_1_zero_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"></div><h2 class="groupheader">Variable Documentation</h2>
<a id="a8d408b48a797fea59c2b1e5ecd532920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d408b48a797fea59c2b1e5ecd532920">&#9670;&nbsp;</a></span>eigen_diagonal_expr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::Eigen3::eigen_diagonal_expr = detail::is_eigen_diagonal_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A diagonal matrix based on the <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> library. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eigen3-traits_8hpp_source.html#l00087">87</a> of file <a class="el" href="eigen3-traits_8hpp_source.html">eigen3-traits.hpp</a>.</p>

</div>
</div>
<a id="a75cd699ad3fe06896706df1346cc4152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cd699ad3fe06896706df1346cc4152">&#9670;&nbsp;</a></span>eigen_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::Eigen3::eigen_matrix = <a class="el" href="namespace_open_kalman_1_1_eigen3.html#a4213585dbf9ef23d61030a68523a827b">eigen_native</a>&lt;T&gt; or <a class="el" href="namespace_open_kalman_1_1_eigen3.html#aa8a476c4cfb61d510f7d8b9773ad9527">eigen_zero_expr</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>T is either a native <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> matrix or a zero <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> matrix. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eigen3-traits_8hpp_source.html#l00177">177</a> of file <a class="el" href="eigen3-traits_8hpp_source.html">eigen3-traits.hpp</a>.</p>

</div>
</div>
<a id="a4213585dbf9ef23d61030a68523a827b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4213585dbf9ef23d61030a68523a827b">&#9670;&nbsp;</a></span>eigen_native</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::Eigen3::eigen_native</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= std::is_base_of_v&lt;Eigen::MatrixBase&lt;std::decay_t&lt;T&gt;&gt;, std::decay_t&lt;T&gt;&gt; and</div>
<div class="line">      (not std::is_base_of_v&lt;internal::Eigen3Base&lt;std::decay_t&lt;T&gt;&gt;, std::decay_t&lt;T&gt;&gt;)</div>
</div><!-- fragment --><p>This includes any class in the <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> library descending from Eigen::MatrixBase. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-traits_8hpp_source.html#l00030">30</a> of file <a class="el" href="eigen3-matrix-traits_8hpp_source.html">eigen3-matrix-traits.hpp</a>.</p>

</div>
</div>
<a id="a1300ee43daf6076f8cfd0d2f822fe020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1300ee43daf6076f8cfd0d2f822fe020">&#9670;&nbsp;</a></span>eigen_self_adjoint_expr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::Eigen3::eigen_self_adjoint_expr = detail::is_eigen_self_adjoint_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type T is a self-adjoint matrix based on the <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> library. /note This is a concept when compiled with c++20, and a constexpr bool in c++17. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-traits_8hpp_source.html#l00043">43</a> of file <a class="el" href="eigen3-traits_8hpp_source.html">eigen3-traits.hpp</a>.</p>

</div>
</div>
<a id="ace19dd487311d8b674643ba2bb5513f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace19dd487311d8b674643ba2bb5513f3">&#9670;&nbsp;</a></span>eigen_triangular_expr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::Eigen3::eigen_triangular_expr = detail::is_eigen_triangular_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A triangular matrix based on the <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> library. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eigen3-traits_8hpp_source.html#l00065">65</a> of file <a class="el" href="eigen3-traits_8hpp_source.html">eigen3-traits.hpp</a>.</p>

</div>
</div>
<a id="aa8a476c4cfb61d510f7d8b9773ad9527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a476c4cfb61d510f7d8b9773ad9527">&#9670;&nbsp;</a></span>eigen_zero_expr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::Eigen3::eigen_zero_expr = detail::is_eigen_zero_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A zero matrix based on the <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> library. (All coefficients are zero.) </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eigen3-traits_8hpp_source.html#l00109">109</a> of file <a class="el" href="eigen3-traits_8hpp_source.html">eigen3-traits.hpp</a>.</p>

</div>
</div>
<a id="a5eea295d94923c613e461e6ec8d0c52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eea295d94923c613e461e6ec8d0c52b">&#9670;&nbsp;</a></span>euclidean_expr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::Eigen3::euclidean_expr = <a class="el" href="namespace_open_kalman_1_1_eigen3.html#aaf6a888caf6f486dadc2bafa6f526d6c">from_euclidean_expr</a>&lt;T&gt; or <a class="el" href="namespace_open_kalman_1_1_eigen3.html#a1a369957b46435f66ac4cfd93eaa7f3e">to_euclidean_expr</a>&lt;T&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Either from_euclidean_expr or to_euclidean_expr. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eigen3-traits_8hpp_source.html#l00165">165</a> of file <a class="el" href="eigen3-traits_8hpp_source.html">eigen3-traits.hpp</a>.</p>

</div>
</div>
<a id="aaf6a888caf6f486dadc2bafa6f526d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6a888caf6f486dadc2bafa6f526d6c">&#9670;&nbsp;</a></span>from_euclidean_expr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::Eigen3::from_euclidean_expr = detail::is_from_euclidean_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An expression converting each column vector in a Euclidean <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> matrix from Euclidean space. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eigen3-traits_8hpp_source.html#l00131">131</a> of file <a class="el" href="eigen3-traits_8hpp_source.html">eigen3-traits.hpp</a>.</p>

</div>
</div>
<a id="aba6821f8a9abf88a0994495139d95b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba6821f8a9abf88a0994495139d95b0d">&#9670;&nbsp;</a></span>lower_storage_triangle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::Eigen3::lower_storage_triangle = detail::is_lower_storage_triangle&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A self-adjoint matrix that stores data in the lower triangle. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eigen3-traits_8hpp_source.html#l00221">221</a> of file <a class="el" href="eigen3-traits_8hpp_source.html">eigen3-traits.hpp</a>.</p>

</div>
</div>
<a id="a1a369957b46435f66ac4cfd93eaa7f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a369957b46435f66ac4cfd93eaa7f3e">&#9670;&nbsp;</a></span>to_euclidean_expr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::Eigen3::to_euclidean_expr = detail::is_to_euclidean_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An expression converting each column vector in an <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> matrix to Euclidean space. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eigen3-traits_8hpp_source.html#l00153">153</a> of file <a class="el" href="eigen3-traits_8hpp_source.html">eigen3-traits.hpp</a>.</p>

</div>
</div>
<a id="a823cfdc848031e09f1b405d796220d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823cfdc848031e09f1b405d796220d90">&#9670;&nbsp;</a></span>upper_storage_triangle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::Eigen3::upper_storage_triangle = detail::is_upper_storage_triangle&lt;std::decay_t&lt;T&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A self-adjoint matrix that stores data in the upper triangle. </p><dl class="section note"><dt>Note</dt><dd>This is a concept when compiled with c++20, and a constexpr bool in c++17. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eigen3-traits_8hpp_source.html#l00199">199</a> of file <a class="el" href="eigen3-traits_8hpp_source.html">eigen3-traits.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a24018b3631626078a5925a7e57442343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24018b3631626078a5925a7e57442343">&#9670;&nbsp;</a></span>concatenate_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename ... Vs, std::enable_if_t&lt;((eigen_matrix&lt; V &gt; or eigen_self_adjoint_expr&lt; V &gt; or eigen_triangular_expr&lt; V &gt; or eigen_diagonal_expr&lt; V &gt; or from_euclidean_expr&lt; V &gt;) and ... and(eigen_matrix&lt; Vs &gt; or eigen_self_adjoint_expr&lt; Vs &gt; or eigen_triangular_expr&lt; Vs &gt; or eigen_diagonal_expr&lt; Vs &gt; or from_euclidean_expr&lt; Vs &gt;)) and(not(eigen_diagonal_expr&lt; V &gt; and ... and eigen_diagonal_expr&lt; Vs &gt;)) and(not(from_euclidean_expr&lt; V &gt; and ... and from_euclidean_expr&lt; Vs &gt;)) and(not(eigen_self_adjoint_expr&lt; V &gt; and ... and eigen_self_adjoint_expr&lt; Vs &gt;)) and(not(eigen_triangular_expr&lt; V &gt; and ... and eigen_triangular_expr&lt; Vs &gt;)), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::Eigen3::concatenate_diagonal </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Concatenate diagonally. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-overloads_8hpp_source.html#l00490">490</a> of file <a class="el" href="eigen3-matrix-overloads_8hpp_source.html">eigen3-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="add7be967305c09eb5cf5ae7c0b29a2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7be967305c09eb5cf5ae7c0b29a2c5">&#9670;&nbsp;</a></span>concatenate_horizontal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename ... Vs, std::enable_if_t&lt;(to_euclidean_expr&lt; V &gt; and ... and to_euclidean_expr&lt; Vs &gt;) or(from_euclidean_expr&lt; V &gt; and ... and from_euclidean_expr&lt; Vs &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::Eigen3::concatenate_horizontal </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Concatenate one or more Eigen::MatrixBase objects horizontally. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00305">305</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a28af8b2669223699d2f4a19903cb2d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28af8b2669223699d2f4a19903cb2d48">&#9670;&nbsp;</a></span>concatenate_vertical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename ... Vs, std::enable_if_t&lt;(to_euclidean_expr&lt; V &gt; and ... and to_euclidean_expr&lt; Vs &gt;) or(from_euclidean_expr&lt; V &gt; and ... and from_euclidean_expr&lt; Vs &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::Eigen3::concatenate_vertical </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Concatenate one or more Eigen::MatrixBase objects vertically. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00278">278</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a1af4344acb6f825cd4692282765fe1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af4344acb6f825cd4692282765fe1d5">&#9670;&nbsp;</a></span>get_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and element_gettable&lt; nested_matrix_t&lt; Arg &gt;, 1 &gt; and(not to_euclidean_expr&lt; nested_matrix_t&lt; Arg &gt;&gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::get_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get element (i) of diagonal matrix arg.</p>
<p>Get element (i) of diagonal self-adjoint or triangular matrix.</p>
<p>Get element (i) of FromEuclideanExpr(ToEuclideanExpr) matrix. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00584">584</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a3586bb1bfaaeb0c2ca362c2b77a167f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3586bb1bfaaeb0c2ca362c2b77a167f0">&#9670;&nbsp;</a></span>get_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and element_gettable&lt; nested_matrix_t&lt; Arg &gt;, 2 &gt; and(not to_euclidean_expr&lt; nested_matrix_t&lt; Arg &gt;&gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::get_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get element (i, j) of diagonal matrix arg.</p>
<p>Get element (i, j) of a self-adjoint or triangular matrix that is also diagonal.</p>
<p>Get element (i, j) of triangular matrix arg.</p>
<p>Get element (i, j) of self-adjoint matrix arg.</p>
<p>Get element (i, j) of FromEuclideanExpr(ToEuclideanExpr) matrix. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00548">548</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a1e68e2f00653ec30dffdea1a77853f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e68e2f00653ec30dffdea1a77853f2f">&#9670;&nbsp;</a></span>LQ_decomposition() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; euclidean_expr&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::LQ_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an LQ decomposition of matrix A=[L,0]Q, L is a lower-triangular matrix, and Q is orthogonal. Returns L as a triangular matrix.</p>
<p>Perform an LQ decomposition of matrix A=[L,0]Q, L is a lower-triangular matrix, and Q is orthogonal. Returns L as a lower-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00246">246</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="ad80481f0fb6c9e501127cc94af618729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80481f0fb6c9e501127cc94af618729">&#9670;&nbsp;</a></span>LQ_decomposition() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; eigen_native&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto OpenKalman::Eigen3::LQ_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an LQ decomposition of matrix A=[L,0]Q, L is a lower-triangular matrix, and Q is orthogonal. Returns L as a lower-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-overloads_8hpp_source.html#l00320">320</a> of file <a class="el" href="eigen3-matrix-overloads_8hpp_source.html">eigen3-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="a3622eb8c8e3ae9e4ef7280f2c50d18e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3622eb8c8e3ae9e4ef7280f2c50d18e2">&#9670;&nbsp;</a></span>LQ_decomposition() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; Eigen3::eigen_triangular_expr&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::Eigen3::LQ_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an LQ decomposition of matrix A=[L,0]Q, where L is a lower-triangular matrix, and Q is orthogonal. Returns L as a lower-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="_triangular_matrix_8hpp_source.html#l00621">621</a> of file <a class="el" href="_triangular_matrix_8hpp_source.html">TriangularMatrix.hpp</a>.</p>

</div>
</div>
<a id="a928f12401b0fce7dae651a934008030a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928f12401b0fce7dae651a934008030a">&#9670;&nbsp;</a></span>make_covariance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , TriangleType triangle_type, typename Scalar  = double, std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and(triangle_type==TriangleType::lower or triangle_type==TriangleType::upper) and std::is_arithmetic_v&lt; Scalar &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::Eigen3::OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>, specifying the coefficients.</p>
<p>For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> with nested triangular matrix.</p>
<p>For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a list of coefficients, with default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> coefficients.</p>
<p>For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a>, with nested triangular type, from a list of coefficients.</p>
<p>For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a <a class="el" href="struct_open_kalman_1_1_covariance.html" title="A self-adjoint Covariance matrix.">Covariance</a> from a list of coefficients, specifying the coefficients.</p>
<dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). The number of coefficients must equal Coefficients::size * Coefficients::size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). The number of coefficients must equal Coefficients::size * Coefficients::size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). The number of coefficients must be the square of an integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). The number of coefficients must be the square of an integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Scalar</td><td>The scalar type (integral or floating-point).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Scalar</td><td>The scalar type (integral or floating-point). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="default-overloads_8hpp_source.html#l00354">354</a> of file <a class="el" href="default-overloads_8hpp_source.html">default-overloads.hpp</a>.</p>

</div>
</div>
<a id="a28355caa34a0d30cb75e07dea788f49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28355caa34a0d30cb75e07dea788f49b">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Coefficients , std::size_t cols = 1, std::enable_if_t&lt; std::is_arithmetic_v&lt; Scalar &gt; and coefficients&lt; Coefficients &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::Eigen3::OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a <a class="el" href="struct_open_kalman_1_1_euclidean_mean.html" title="Similar to a Mean, but the coefficients are transformed into Euclidean space, based on their type.">EuclideanMean</a> from a list of coefficients, specifying the row coefficients.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type (integral or floating-point). </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). The number of coefficients must be divisible by Coefficients::dimension. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="default-overloads_8hpp_source.html#l00221">221</a> of file <a class="el" href="default-overloads_8hpp_source.html">default-overloads.hpp</a>.</p>

</div>
</div>
<a id="ace928597d23cded16c159a1929748fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace928597d23cded16c159a1929748fa4">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="default-overloads_8hpp_source.html#l00201">201</a> of file <a class="el" href="default-overloads_8hpp_source.html">default-overloads.hpp</a>.</p>

</div>
</div>
<a id="ac60ae4e5bdee892abe4344e998cd0e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60ae4e5bdee892abe4344e998cd0e4a">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename RowCoefficients , typename ColumnCoefficients  = RowCoefficients, std::enable_if_t&lt; std::is_arithmetic_v&lt; Scalar &gt; and coefficients&lt; RowCoefficients &gt; and coefficients&lt; ColumnCoefficients &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::Eigen3::OpenKalman::make_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a <a class="el" href="struct_open_kalman_1_1_matrix.html" title="A matrix with typed rows and columns.">Matrix</a> from a list of coefficients, specifying the row and column coefficients.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type (integral or floating-point). </td></tr>
    <tr><td class="paramname">RowCoefficients</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">ColumnCoefficients</td><td>The coefficient types corresponding to the columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RowCoefficients</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">ColumnCoefficients</td><td>The coefficient types corresponding to the columns. </td></tr>
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). The number of coefficients must equal RowCoefficients::size * ColumnCoefficients::size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="default-overloads_8hpp_source.html#l00092">92</a> of file <a class="el" href="default-overloads_8hpp_source.html">default-overloads.hpp</a>.</p>

</div>
</div>
<a id="a254ef68edfc93e94556975d3635e640a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254ef68edfc93e94556975d3635e640a">&#9670;&nbsp;</a></span>make_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::make_matrix </td>
          <td>(</td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="default-overloads_8hpp_source.html#l00070">70</a> of file <a class="el" href="default-overloads_8hpp_source.html">default-overloads.hpp</a>.</p>

</div>
</div>
<a id="ab958f7a462b5c8a0f8a0b27fcfd8e971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab958f7a462b5c8a0f8a0b27fcfd8e971">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Coefficients , std::size_t cols = 1, std::enable_if_t&lt; std::is_arithmetic_v&lt; Scalar &gt; and coefficients&lt; Coefficients &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::Eigen3::OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a <a class="el" href="struct_open_kalman_1_1_mean.html" title="A set of one or more column vectors, each representing a statistical mean.">Mean</a> from a list of coefficients, specifying the row coefficients.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>A scalar type (integral or floating-point). </td></tr>
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">cols</td><td>The number of columns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). The number of coefficients must be divisible by Coefficients::size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="default-overloads_8hpp_source.html#l00157">157</a> of file <a class="el" href="default-overloads_8hpp_source.html">default-overloads.hpp</a>.</p>

</div>
</div>
<a id="a0c9a6b195d8d4fbae6ba1878c1bb335e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c9a6b195d8d4fbae6ba1878c1bb335e">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Args, std::enable_if_t&lt;(sizeof...(Args) &gt; 0) and std::conjunction_v&lt; std::is_arithmetic&lt; Args &gt;... &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::make_mean </td>
          <td>(</td>
          <td class="paramtype">Args ...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="default-overloads_8hpp_source.html#l00137">137</a> of file <a class="el" href="default-overloads_8hpp_source.html">default-overloads.hpp</a>.</p>

</div>
</div>
<a id="a72cc88064aa1729df7d7b09ae554bebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72cc88064aa1729df7d7b09ae554bebe">&#9670;&nbsp;</a></span>make_native_matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::Eigen3::make_native_matrix </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert to a self-contained <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> matrix. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00038">38</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a89a15d893ae0a0c3f51bdce5cd36cf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a15d893ae0a0c3f51bdce5cd36cf10">&#9670;&nbsp;</a></span>make_native_matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , std::size_t dimension, std::size_t columns = 1, typename ... Args, std::enable_if_t&lt; std::is_arithmetic_v&lt; Scalar &gt; and(std::is_convertible_v&lt; Args, Scalar &gt; and ...) and(sizeof...(Args)==dimension *columns), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::make_native_matrix </td>
          <td>(</td>
          <td class="paramtype">const Args ...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a native <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> matrix from a list of coefficients in row-major order. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The scalar type of the matrix. </td></tr>
    <tr><td class="paramname">dimension</td><td>The number of rows. </td></tr>
    <tr><td class="paramname">columns</td><td>The number of columns. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-overloads_8hpp_source.html#l00034">34</a> of file <a class="el" href="eigen3-matrix-overloads_8hpp_source.html">eigen3-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="aff6d199e3f727fd414240f55358babc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6d199e3f727fd414240f55358babc0">&#9670;&nbsp;</a></span>make_native_matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t dimension, std::size_t columns = 1, typename ... Args, std::enable_if_t&lt;(std::is_arithmetic_v&lt; Args &gt; and ...) and(sizeof...(Args)==dimension *columns), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::make_native_matrix </td>
          <td>(</td>
          <td class="paramtype">const Args ...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-overloads_8hpp_source.html#l00053">53</a> of file <a class="el" href="eigen3-matrix-overloads_8hpp_source.html">eigen3-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="a40e16a8d6ebf133a37fad616756a92cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e16a8d6ebf133a37fad616756a92cc">&#9670;&nbsp;</a></span>make_self_contained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::Eigen3::make_self_contained </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert to self-contained version of the special matrix.</p>
<p>Convert to function-returnable version of the matrix. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00061">61</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a3c71ab9b79246e22a2834dce8c360c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c71ab9b79246e22a2834dce8c360c51">&#9670;&nbsp;</a></span>make_square_root_covariance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , TriangleType triangle_type = TriangleType::lower, typename Scalar  = double, std::enable_if_t&lt; coefficients&lt; Coefficients &gt; and(triangle_type==TriangleType::lower or triangle_type==TriangleType::upper) and std::is_arithmetic_v&lt; Scalar &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::Eigen3::OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a writable, uninitialized <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a>.</p>
<p>For <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a>: Make a default <a class="el" href="struct_open_kalman_1_1_axis.html" title="A real or integral number, (−∞,∞).">Axis</a> <a class="el" href="struct_open_kalman_1_1_square_root_covariance.html" title="The upper or lower triangle Cholesky factor (square root) of a covariance matrix.">SquareRootCovariance</a> from a list of coefficients.</p>
<p>Only the coefficients in the associated upper or lower triangle are significant. </p><dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). The number of coefficients must equal Coefficients::size * Coefficients::size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Args</td><td>A list of numerical coefficients (either integral or floating-point). The number of coefficients must be the square of an integer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is imported into the <a class="el" href="namespace_open_kalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> namespace if <a class="el" href="namespace_open_kalman_1_1_eigen3.html" title="Namespace for all Eigen3 interface definitions.">Eigen3</a> is the first-included interface. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a></td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Scalar</td><td>The scalar type (integral or floating-point). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="default-overloads_8hpp_source.html#l00460">460</a> of file <a class="el" href="default-overloads_8hpp_source.html">default-overloads.hpp</a>.</p>

</div>
</div>
<a id="a8a173007a7a7b04da8c85533ed38a210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a173007a7a7b04da8c85533ed38a210">&#9670;&nbsp;</a></span>QR_decomposition() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; eigen_native&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto OpenKalman::Eigen3::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a QR decomposition of matrix A=Q[U,0], U is a upper-triangular matrix, and Q is orthogonal. Returns U as an upper-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-overloads_8hpp_source.html#l00358">358</a> of file <a class="el" href="eigen3-matrix-overloads_8hpp_source.html">eigen3-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="a5a30b32549d0a5f1e8138643ef13071b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a30b32549d0a5f1e8138643ef13071b">&#9670;&nbsp;</a></span>QR_decomposition() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; Eigen3::eigen_self_adjoint_expr&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a QR decomposition of matrix A=Q[U,0], U is a upper-triangular matrix, and Q is orthogonal. Returns U as an upper-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="_self_adjoint_matrix_8hpp_source.html#l00661">661</a> of file <a class="el" href="_self_adjoint_matrix_8hpp_source.html">SelfAdjointMatrix.hpp</a>.</p>

</div>
</div>
<a id="ad57174029ea3969f2e57da1c8cc5b3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57174029ea3969f2e57da1c8cc5b3fc">&#9670;&nbsp;</a></span>QR_decomposition() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , std::enable_if_t&lt; Eigen3::eigen_triangular_expr&lt; A &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::Eigen3::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a QR decomposition of matrix A=Q[U,0], where U is an upper-triangular matrix, and Q is orthogonal. Returns U as an upper-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="_triangular_matrix_8hpp_source.html#l00638">638</a> of file <a class="el" href="_triangular_matrix_8hpp_source.html">TriangularMatrix.hpp</a>.</p>

</div>
</div>
<a id="a497d7ef2f9c7ff140038d1e101c11899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497d7ef2f9c7ff140038d1e101c11899">&#9670;&nbsp;</a></span>QR_decomposition() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a QR decomposition of matrix A=Q[U,0], U is a upper-triangular matrix, and Q is orthogonal. Returns U as an upper-triangular matrix. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00262">262</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a953012881d72bf25a25a087f3eb52a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953012881d72bf25a25a087f3eb52a26">&#9670;&nbsp;</a></span>randomize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , template&lt; typename &gt; typename distribution_type = std::normal_distribution, typename random_number_engine  = std::mt19937, typename... Params, std::enable_if_t&lt; eigen_matrix&lt; ReturnType &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::randomize </td>
          <td>(</td>
          <td class="paramtype">Params &amp;&amp;...&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill an <a class="el" href="namespace_eigen.html" title="Eigen3&#39;s native namespace.">Eigen</a> matrix with random values selected from a random distribution. The Gaussian distribution has mean zero and a scalar standard deviation sigma (== 1, if not specified). </p>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-overloads_8hpp_source.html#l01244">1244</a> of file <a class="el" href="eigen3-matrix-overloads_8hpp_source.html">eigen3-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="a95e10ebc64d6c4cb16307f79fe1dc1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e10ebc64d6c4cb16307f79fe1dc1d5">&#9670;&nbsp;</a></span>randomize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , template&lt; typename Scalar &gt; typename distribution_type = std::normal_distribution, typename random_number_engine  = std::mt19937, typename... Params, std::enable_if_t&lt; euclidean_expr&lt; ReturnType &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::randomize </td>
          <td>(</td>
          <td class="paramtype">Params...&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill a matrix of to-Euclidean- or from_euclidean-transformed values selected from a random distribution. The Gaussian distribution has zero mean and standard deviation sigma (1, if not specified).</p>
<p>Fill the diagonal of a square matrix with random values selected from a random distribution. The Gaussian distribution has zero mean and standard deviation sigma (1, if not specified). </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00985">985</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a81c2b6e93710caa2a2ad99029271d928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c2b6e93710caa2a2ad99029271d928">&#9670;&nbsp;</a></span>reduce_columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; eigen_native&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::Eigen3::reduce_columns </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a column vector from a diagnoal matrix. (Same as nested_matrix()). </p>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-overloads_8hpp_source.html#l00297">297</a> of file <a class="el" href="eigen3-matrix-overloads_8hpp_source.html">eigen3-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="aff5c36cca718e6c44e3081778f1d44b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5c36cca718e6c44e3081778f1d44b9">&#9670;&nbsp;</a></span>set_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and std::is_convertible_v&lt; Scalar, typename MatrixTraits&lt; Arg &gt;::Scalar &gt; and not to_euclidean_expr&lt; nested_matrix_t&lt; Arg &gt;&gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and MatrixTraits&lt; Arg &gt;::RowCoefficients::axes_only and element_settable&lt; nested_matrix_t&lt; Arg &gt;, 1 &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenKalman::Eigen3::set_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set element (i) of matrix arg to s.</p>
<p>Set element (i) of diagonal self-adjoint or triangular matrix.</p>
<p>Set element (i) of one-column matrix arg to s.</p>
<p>Set element (i) of arg in FromEuclideanExpr(ToEuclideanExpr(arg)) to s, where arg is a single-column vector.</p>
<p>This function sets the nested matrix, not the wrapped resulting matrix. For example, if the coefficient is Polar&lt;Distance, angle::Radians&gt; and the initial value of a single-column vector is {-1., pi/2}, then set_element(arg, pi/4, 1) will replace p/2 with pi/4 to yield {-1., pi/4} in the nested matrix. The resulting wrapped expression will yield {1., -3*pi/4}. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The matrix to set. </td></tr>
    <tr><td class="paramname">Scalar</td><td>The value to set the coefficient to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row of the coefficient. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00704">704</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a50497d8dae63621aee41c59dd017cb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50497d8dae63621aee41c59dd017cb56">&#9670;&nbsp;</a></span>set_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Scalar , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and std::is_convertible_v&lt; Scalar, typename MatrixTraits&lt; Arg &gt;::Scalar &gt; and not to_euclidean_expr&lt; nested_matrix_t&lt; Arg &gt;&gt; and not std::is_const_v&lt; std::remove_reference_t&lt; Arg &gt;&gt; and MatrixTraits&lt; Arg &gt;::RowCoefficients::axes_only and element_settable&lt; nested_matrix_t&lt; Arg &gt;, 2 &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OpenKalman::Eigen3::set_element </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set element (i, j) of a self-adjoint or triangular matrix that is also diagonal.</p>
<p>Set element (i, j) of triangular matrix arg to s.</p>
<p>Set element (i, j) of self-adjoint matrix arg to s.</p>
<p>Set element (i, j) of matrix arg to s.</p>
<p>Set element (i, j) of arg in FromEuclideanExpr(ToEuclideanExpr(arg)) to s.</p>
<p>This function sets the nested matrix, not the wrapped resulting matrix. For example, if the coefficient is Polar&lt;Distance, angle::Radians&gt; and the initial value of a single-column vector is {-1., pi/2}, then set_element(arg, pi/4, 1, 0) will replace p/2 with pi/4 to yield {-1., pi/4} in the nested matrix. The resulting wrapped expression will yield {1., -3*pi/4}. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The matrix to set. </td></tr>
    <tr><td class="paramname">Scalar</td><td>The value to set the coefficient to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row of the coefficient. </td></tr>
    <tr><td class="paramname">j</td><td>The column of the coefficient. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00681">681</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a8d1b813053fe755883d24c7a1933c96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1b813053fe755883d24c7a1933c96c">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , std::enable_if_t&lt; euclidean_expr&lt; A &gt; and eigen_matrix&lt; B &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::solve </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Solves AX = B for X (A is a regular matrix type, and B is a Euclidean expression). A must be invertible. (Does not check.) </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00220">220</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="ad8a4e9c73dead8cfb0c7b4053d8f1d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a4e9c73dead8cfb0c7b4053d8f1d61">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B , std::enable_if_t&lt; eigen_matrix&lt; A &gt; and eigen_matrix&lt; B &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::solve </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const B &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Solve the equation AX = B for X. A is an invertible square matrix. (Does not check that A is invertible.) Uses the square LU decomposition. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-overloads_8hpp_source.html#l00274">274</a> of file <a class="el" href="eigen3-matrix-overloads_8hpp_source.html">eigen3-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="a8f9ead984aa7bb1198e7575fb67574ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9ead984aa7bb1198e7575fb67574ff">&#9670;&nbsp;</a></span>split_diagonal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::split_diagonal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a self-adjoint, triangular, or diagonal matrix diagonally.</p>
<p>Split a self-adjoint or triangular matrix diagonally.</p>
<p>Split a diagonal matrix diagonally.</p>
<p>Split a matrix vertically (case in which there is no split).</p>
<p>Split into one or more Euclidean expressions diagonally. The expression (which must be square) is evaluated to a self_contained matrix first. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of rows in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Number of rows in the second and subsequent cuts.</td></tr>
  </table>
  </dd>
</dl>
<p>Split a matrix diagonally. Must be a square matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">Cs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for the second and subsequent cuts.</td></tr>
  </table>
  </dd>
</dl>
<p>Split a matrix diagonally. Must be a square matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of rows and columns in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Numbers of rows and columns in the second and subsequent cuts. </td></tr>
    <tr><td class="paramname">F</td><td>An object having a static call() method to which the result is applied before creating the tuple. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00474">474</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a7ffba4a479480e5a0e9fd48d71634dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffba4a479480e5a0e9fd48d71634dc3">&#9670;&nbsp;</a></span>split_diagonal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , bool , typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::split_diagonal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a matrix vertically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>A class with a static <code>call</code> member to which the result is applied before creating the tuple. </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">Cs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for each of the second and subsequent cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00491">491</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a4d5720846529fd822cec40bce7393b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5720846529fd822cec40bce7393b20">&#9670;&nbsp;</a></span>split_diagonal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and(coefficients&lt; Cs &gt; and ...), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::split_diagonal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a self-adjoint, triangular, or diagonal matrix diagonally. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00506">506</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="af54a8210943f63a85fb79b1651c14182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af54a8210943f63a85fb79b1651c14182">&#9670;&nbsp;</a></span>split_diagonal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , bool euclidean, typename C , typename... Cs, typename Arg , std::enable_if_t&lt; eigen_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::split_diagonal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a matrix diagonally and invoke function F on each segment, returning a tuple. Must be a square matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>An object having a static call() method to which the result is applied before creating the tuple. </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">Cs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for each of the second and subsequent cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-overloads_8hpp_source.html#l00731">731</a> of file <a class="el" href="eigen3-matrix-overloads_8hpp_source.html">eigen3-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="a3f0b55888df2839382ee04cb80505158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0b55888df2839382ee04cb80505158">&#9670;&nbsp;</a></span>split_horizontal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::split_horizontal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a self-adjoint, triangular, or diagonal matrix horizontally.</p>
<p>Split a self-adjoint, triangular, or diagonal matrix horizontally, returning a regular matrix.</p>
<p>Split into one or more Euclidean expressions horizontally. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of columns in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Number of columns in the second and subsequent cuts.</td></tr>
  </table>
  </dd>
</dl>
<p>Split a matrix horizontally. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CC</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">CCs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for the second and subsequent cuts.</td></tr>
  </table>
  </dd>
</dl>
<p>Split a matrix horizontally. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of columns in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Numbers of columns in the second and subsequent cuts. </td></tr>
    <tr><td class="paramname">F</td><td>An object having a static call() method to which the result is applied before creating the tuple. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00429">429</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="aab2dd314550c781b9787caf468eb996d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2dd314550c781b9787caf468eb996d">&#9670;&nbsp;</a></span>split_horizontal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and(coefficients&lt; Cs &gt; and ...), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::split_horizontal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a self-adjoint, triangular, or diagonal matrix horizontally.</p>
<p>Split a matrix horizontally (case in which there is no split). </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00445">445</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="ab8a81ba1ce1a4ea9b08b43852710cf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a81ba1ce1a4ea9b08b43852710cf7e">&#9670;&nbsp;</a></span>split_horizontal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename CC , typename... CCs, typename Arg , std::enable_if_t&lt; eigen_matrix&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::split_horizontal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a matrix horizontally and invoke function F on each segment, returning a tuple. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CC</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">CCs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for each of the second and subsequent cuts. </td></tr>
    <tr><td class="paramname">F</td><td>An object having a static call() method to which the result is applied before creating the tuple. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-overloads_8hpp_source.html#l00646">646</a> of file <a class="el" href="eigen3-matrix-overloads_8hpp_source.html">eigen3-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="acbefa89d53756a3a8d2bf8d3b324a028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbefa89d53756a3a8d2bf8d3b324a028">&#9670;&nbsp;</a></span>split_vertical() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::split_vertical </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a self-adjoint, triangular, or diagonal matrix diagonally.</p>
<p>Split a self-adjoint, triangular, or diagonal matrix vertically, returning a regular matrix.</p>
<p>Split a matrix vertically (case in which there is no split).</p>
<p>Split into one or more Euclidean expressions vertically. The expression is evaluated to a self_contained matrix first. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of rows in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Number of rows in the second and subsequent cuts.</td></tr>
  </table>
  </dd>
</dl>
<p>Split a matrix vertically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RC</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">RCs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for the second and subsequent cuts.</td></tr>
  </table>
  </dd>
</dl>
<p>Split a matrix vertically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">cut</td><td>Number of rows in the first cut. </td></tr>
    <tr><td class="paramname">cuts</td><td>Numbers of rows in the second and subsequent cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00362">362</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="ae2dafab2bccd64e00f1938aa98987938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2dafab2bccd64e00f1938aa98987938">&#9670;&nbsp;</a></span>split_vertical() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , bool , typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and not coefficients&lt; F &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::split_vertical </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a matrix vertically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>A class with a static <code>call</code> member to which the result is applied before creating the tuple. </td></tr>
    <tr><td class="paramname">RCs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for each of the cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00379">379</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="ad71465ec5623615f13128c205cc69431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71465ec5623615f13128c205cc69431">&#9670;&nbsp;</a></span>split_vertical() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Cs, typename Arg , std::enable_if_t&lt; euclidean_expr&lt; Arg &gt; and(coefficients&lt; Cs &gt; and ...), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::split_vertical </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a self-adjoint, triangular, or diagonal matrix diagonally. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00392">392</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a81be6a4f7c1dd83cc9e7bed633b29433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81be6a4f7c1dd83cc9e7bed633b29433">&#9670;&nbsp;</a></span>split_vertical() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , bool euclidean, typename RC , typename... RCs, typename Arg , std::enable_if_t&lt; eigen_matrix&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::Eigen3::split_vertical </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a matrix vertically. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>A class with a static <code>call</code> member to which the result is applied before creating the tuple. </td></tr>
    <tr><td class="paramname">euclidean</td><td>Whether coefficients RC and RCs are transformed to Euclidean space. </td></tr>
    <tr><td class="paramname">RC</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for the first cut. </td></tr>
    <tr><td class="paramname">RCs</td><td><a class="el" href="struct_open_kalman_1_1_coefficients.html" title="A set of coefficient types.">Coefficients</a> for each of the second and subsequent cuts. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="eigen3-matrix-overloads_8hpp_source.html#l00545">545</a> of file <a class="el" href="eigen3-matrix-overloads_8hpp_source.html">eigen3-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="af5fa7ebc6d79d4db4418c65e9603b4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fa7ebc6d79d4db4418c65e9603b4cf">&#9670;&nbsp;</a></span>to_euclidean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , std::enable_if_t&lt; from_euclidean_expr&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::Eigen3::to_euclidean </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Special case for converting a matrix to Euclidean form. This is a shortcut. Returns the nested matrix of the argument, because <a class="el" href="struct_open_kalman_1_1_eigen3_1_1_to_euclidean_expr.html" title="An expression that transforms coefficients into Euclidean space for proper wrapping.">ToEuclideanExpr</a>&lt;FromEuclideanExpr&lt;M&gt;&gt; reduces to M. </p>

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00086">86</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
<a id="a8d390585998024a682e322f235c0c708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d390585998024a682e322f235c0c708">&#9670;&nbsp;</a></span>wrap_angles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Coefficients , typename Arg , std::enable_if_t&lt; from_euclidean_expr&lt; Arg &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::Eigen3::wrap_angles </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html#l00144">144</a> of file <a class="el" href="eigen3-euclidean-overloads_8hpp_source.html">eigen3-euclidean-overloads.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_open_kalman.html">OpenKalman</a></li><li class="navelem"><a class="el" href="namespace_open_kalman_1_1_eigen3.html">Eigen3</a></li>
    <li class="footer">Generated on Sun Dec 6 2020 19:54:45 for OpenKalman by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0 </li>
  </ul>
</div>
</body>
</html>
