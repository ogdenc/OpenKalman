<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OpenKalman: OpenKalman Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenKalman
   </div>
   <div id="projectbrief">An open-source, heading-only library for Kalman filters and other recursive filters</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceOpenKalman.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#typedef-members">Aliases</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">OpenKalman Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The root namespace for <a class="el" href="namespaceOpenKalman.html" title="The root namespace for OpenKalman.">OpenKalman</a>.  
<a href="namespaceOpenKalman.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceOpenKalman_1_1Eigen3"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman_1_1Eigen3.html">Eigen3</a></td></tr>
<tr class="memdesc:namespaceOpenKalman_1_1Eigen3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for all Eigen3-specific definitions, not intended for use outside of <a class="el" href="namespaceOpenKalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> development. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceOpenKalman_1_1interface"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman_1_1interface.html">interface</a></td></tr>
<tr class="memdesc:namespaceOpenKalman_1_1interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root namespace for <a class="el" href="namespaceOpenKalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> interface types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceOpenKalman_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespaceOpenKalman_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for internal definitions, not intended for use outside of <a class="el" href="namespaceOpenKalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> development. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceOpenKalman_1_1values"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman_1_1values.html">values</a></td></tr>
<tr class="memdesc:namespaceOpenKalman_1_1values"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root namespace for <a class="el" href="namespaceOpenKalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> values (e.g., <a class="el" href="structOpenKalman_1_1values_1_1constant__coefficient.html">constant_coefficient</a>, <a class="el" href="structOpenKalman_1_1values_1_1constant__diagonal__coefficient.html">constant_diagonal_coefficient</a>). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceOpenKalman_1_1vector__space__descriptors"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman_1_1vector__space__descriptors.html">vector_space_descriptors</a></td></tr>
<tr class="memdesc:namespaceOpenKalman_1_1vector__space__descriptors"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root namespace for <a class="el" href="namespaceOpenKalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> objects. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a30391ef8ac72c2cbb79acee7ab1fd90f"><td class="memItemLeft" align="right" valign="top"><a id="a30391ef8ac72c2cbb79acee7ab1fd90f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a30391ef8ac72c2cbb79acee7ab1fd90f">ColumnCoefficients</a></td></tr>
<tr class="memdesc:a30391ef8ac72c2cbb79acee7ab1fd90f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar type for this matrix. <br /></td></tr>
<tr class="separator:a30391ef8ac72c2cbb79acee7ab1fd90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc30bf9b131fc1d4e0895845363541f"><td class="memTemplParams" colspan="2"><a id="a8bc30bf9b131fc1d4e0895845363541f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8bc30bf9b131fc1d4e0895845363541f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a8bc30bf9b131fc1d4e0895845363541f">constant_adapter</a> = detail::is_constant_adapter&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a8bc30bf9b131fc1d4e0895845363541f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a ConstantAdapter. <br /></td></tr>
<tr class="separator:a8bc30bf9b131fc1d4e0895845363541f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e05d8f11c347daec5284ef85eb95d9c"><td class="memTemplParams" colspan="2"><a id="a2e05d8f11c347daec5284ef85eb95d9c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e05d8f11c347daec5284ef85eb95d9c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2e05d8f11c347daec5284ef85eb95d9c">eigen_diagonal_expr</a> = detail::is_eigen_diagonal_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a2e05d8f11c347daec5284ef85eb95d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a diagonal matrix based on the Eigen library (i.e., DiaginalMatrix). <br /></td></tr>
<tr class="separator:a2e05d8f11c347daec5284ef85eb95d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574528d7b77b72e81b1d2406ea50a49f"><td class="memTemplParams" colspan="2"><a id="a574528d7b77b72e81b1d2406ea50a49f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a574528d7b77b72e81b1d2406ea50a49f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a574528d7b77b72e81b1d2406ea50a49f">eigen_self_adjoint_expr</a> = detail::is_eigen_self_adjoint_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a574528d7b77b72e81b1d2406ea50a49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a self-adjoint matrix based on the Eigen library (i.e., SelfAdjointMatrix). <br /></td></tr>
<tr class="separator:a574528d7b77b72e81b1d2406ea50a49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805ae3d7b8e453f084b1949098e25da8"><td class="memTemplParams" colspan="2"><a id="a805ae3d7b8e453f084b1949098e25da8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a805ae3d7b8e453f084b1949098e25da8"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a805ae3d7b8e453f084b1949098e25da8">eigen_triangular_expr</a> = detail::is_eigen_triangular_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a805ae3d7b8e453f084b1949098e25da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a triangular matrix based on the Eigen library (i.e., TriangularMatrix). <br /></td></tr>
<tr class="separator:a805ae3d7b8e453f084b1949098e25da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8790c861060ce4dfc9868d45a10d73c4"><td class="memTemplParams" colspan="2"><a id="a8790c861060ce4dfc9868d45a10d73c4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8790c861060ce4dfc9868d45a10d73c4"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a8790c861060ce4dfc9868d45a10d73c4">from_euclidean_expr</a> = detail::is_from_euclidean_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a8790c861060ce4dfc9868d45a10d73c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is an expression converting coefficients from Euclidean space (i.e., <a class="el" href="structOpenKalman_1_1FromEuclideanExpr.html" title="An expression that transforms angular or other modular vector space descriptors back from Euclidean s...">FromEuclideanExpr</a>). <br /></td></tr>
<tr class="separator:a8790c861060ce4dfc9868d45a10d73c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb6759ba33779f183b9c45f6382db5e"><td class="memTemplParams" colspan="2"><a id="a4cb6759ba33779f183b9c45f6382db5e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4cb6759ba33779f183b9c45f6382db5e"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4cb6759ba33779f183b9c45f6382db5e">to_euclidean_expr</a> = detail::is_to_euclidean_expr&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a4cb6759ba33779f183b9c45f6382db5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is an expression converting coefficients to Euclidean space (i.e., ToEuclideanExpr). <br /></td></tr>
<tr class="separator:a4cb6759ba33779f183b9c45f6382db5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975fc8245840d81474729158361d84c0"><td class="memTemplParams" colspan="2"><a id="a975fc8245840d81474729158361d84c0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a975fc8245840d81474729158361d84c0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a975fc8245840d81474729158361d84c0">euclidean_expr</a> = <a class="el" href="namespaceOpenKalman.html#a4cb6759ba33779f183b9c45f6382db5e">to_euclidean_expr</a>&lt;T&gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a8790c861060ce4dfc9868d45a10d73c4">from_euclidean_expr</a>&lt;T&gt;</td></tr>
<tr class="memdesc:a975fc8245840d81474729158361d84c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is either <a class="el" href="namespaceOpenKalman.html#a4cb6759ba33779f183b9c45f6382db5e">to_euclidean_expr</a> or <a class="el" href="namespaceOpenKalman.html#a8790c861060ce4dfc9868d45a10d73c4">from_euclidean_expr</a>. <br /></td></tr>
<tr class="separator:a975fc8245840d81474729158361d84c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f663d3bacbc3dc52fb0eb3c0412b514"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">dynamic_size</a> = std::numeric_limits&lt;std::size_t&gt;::max()</td></tr>
<tr class="memdesc:a0f663d3bacbc3dc52fb0eb3c0412b514"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant indicating that a size or index is dynamic.  <a href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">More...</a><br /></td></tr>
<tr class="separator:a0f663d3bacbc3dc52fb0eb3c0412b514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbebc790f8ee12c06f75126504fd1e2"><td class="memItemLeft" align="right" valign="top">constexpr std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a9cbebc790f8ee12c06f75126504fd1e2">dynamic_difference</a> = std::numeric_limits&lt;std::ptrdiff_t&gt;::max()</td></tr>
<tr class="memdesc:a9cbebc790f8ee12c06f75126504fd1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constant indicating that a difference in sizes or indices is dynamic.  <a href="namespaceOpenKalman.html#a9cbebc790f8ee12c06f75126504fd1e2">More...</a><br /></td></tr>
<tr class="separator:a9cbebc790f8ee12c06f75126504fd1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad731e2f7b2bff8ebbfa618a8e515c10e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad731e2f7b2bff8ebbfa618a8e515c10e"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ad731e2f7b2bff8ebbfa618a8e515c10e">all_fixed_indices_are_euclidean</a></td></tr>
<tr class="memdesc:ad731e2f7b2bff8ebbfa618a8e515c10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that every fixed-size index of T is euclidean.  <a href="namespaceOpenKalman.html#ad731e2f7b2bff8ebbfa618a8e515c10e">More...</a><br /></td></tr>
<tr class="separator:ad731e2f7b2bff8ebbfa618a8e515c10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e3e6ab58b992bd11790bba514bd032"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ds&gt; </td></tr>
<tr class="memitem:ab5e3e6ab58b992bd11790bba514bd032"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ab5e3e6ab58b992bd11790bba514bd032">compatible_with_vector_space_descriptors</a></td></tr>
<tr class="memdesc:ab5e3e6ab58b992bd11790bba514bd032"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> T is compatible with <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> set Ds.  <a href="namespaceOpenKalman.html#ab5e3e6ab58b992bd11790bba514bd032">More...</a><br /></td></tr>
<tr class="separator:ab5e3e6ab58b992bd11790bba514bd032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d4806449fe50fb0c787b48fe79a439"><td class="memTemplParams" colspan="2">template&lt;typename T , ConstantType c = ConstantType::any&gt; </td></tr>
<tr class="memitem:ac7d4806449fe50fb0c787b48fe79a439"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ac7d4806449fe50fb0c787b48fe79a439">constant_diagonal_matrix</a></td></tr>
<tr class="memdesc:ac7d4806449fe50fb0c787b48fe79a439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that all diagonal elements of a diagonal object are the same constant value.  <a href="namespaceOpenKalman.html#ac7d4806449fe50fb0c787b48fe79a439">More...</a><br /></td></tr>
<tr class="separator:ac7d4806449fe50fb0c787b48fe79a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdfdebaaf3e96ae0c9fbe36ce3b2721"><td class="memTemplParams" colspan="2"><a id="afbdfdebaaf3e96ae0c9fbe36ce3b2721"></a>
template&lt;typename T , ConstantType c = ConstantType::any&gt; </td></tr>
<tr class="memitem:afbdfdebaaf3e96ae0c9fbe36ce3b2721"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#afbdfdebaaf3e96ae0c9fbe36ce3b2721">constant_matrix</a></td></tr>
<tr class="memdesc:afbdfdebaaf3e96ae0c9fbe36ce3b2721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that all components of an object are the same constant value. <br /></td></tr>
<tr class="separator:afbdfdebaaf3e96ae0c9fbe36ce3b2721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f76b1d29292737f93f8ad1918b52e6e"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N = 0&gt; </td></tr>
<tr class="memitem:a0f76b1d29292737f93f8ad1918b52e6e"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0f76b1d29292737f93f8ad1918b52e6e">diagonal_adapter</a></td></tr>
<tr class="memdesc:a0f76b1d29292737f93f8ad1918b52e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a diagonal matrix adapter.  <a href="namespaceOpenKalman.html#a0f76b1d29292737f93f8ad1918b52e6e">More...</a><br /></td></tr>
<tr class="separator:a0f76b1d29292737f93f8ad1918b52e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd606b45e391ddbb67fa785798b1a89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aabd606b45e391ddbb67fa785798b1a89"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a></td></tr>
<tr class="memdesc:aabd606b45e391ddbb67fa785798b1a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a diagonal matrix or tensor.  <a href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">More...</a><br /></td></tr>
<tr class="separator:aabd606b45e391ddbb67fa785798b1a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4ff0c32c70ea24cfc42faaa4ae58d2"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t index, std::size_t value, Qualification b = Qualification::unqualified&gt; </td></tr>
<tr class="memitem:acb4ff0c32c70ea24cfc42faaa4ae58d2"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#acb4ff0c32c70ea24cfc42faaa4ae58d2">dimension_size_of_index_is</a></td></tr>
<tr class="memdesc:acb4ff0c32c70ea24cfc42faaa4ae58d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a given index of T has a specified size.  <a href="namespaceOpenKalman.html#acb4ff0c32c70ea24cfc42faaa4ae58d2">More...</a><br /></td></tr>
<tr class="separator:acb4ff0c32c70ea24cfc42faaa4ae58d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d830f257cdd77081cdd30cb0cb60a43"><td class="memTemplParams" colspan="2"><a id="a9d830f257cdd77081cdd30cb0cb60a43"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9d830f257cdd77081cdd30cb0cb60a43"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a9d830f257cdd77081cdd30cb0cb60a43">directly_accessible</a></td></tr>
<tr class="memdesc:a9d830f257cdd77081cdd30cb0cb60a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying raw data for T is directly accessible. <br /></td></tr>
<tr class="separator:a9d830f257cdd77081cdd30cb0cb60a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e91b2f6875a87b261fa4929a5ab00c8"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a6e91b2f6875a87b261fa4929a5ab00c8"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a6e91b2f6875a87b261fa4929a5ab00c8">dynamic_dimension</a> = <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a>&lt;T&gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> (index_dimension_of_v&lt;T, N&gt; == <a class="el" href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">dynamic_size</a>)</td></tr>
<tr class="memdesc:a6e91b2f6875a87b261fa4929a5ab00c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T's index N has a dimension defined at run time.  <a href="namespaceOpenKalman.html#a6e91b2f6875a87b261fa4929a5ab00c8">More...</a><br /></td></tr>
<tr class="separator:a6e91b2f6875a87b261fa4929a5ab00c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4a95b16bcf85246cc892ddf51cc9ddfa">element_gettable</a></td></tr>
<tr class="memdesc:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type has components addressable by N indices.  <a href="namespaceOpenKalman.html#a4a95b16bcf85246cc892ddf51cc9ddfa">More...</a><br /></td></tr>
<tr class="separator:a4a95b16bcf85246cc892ddf51cc9ddfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2ce6da5d4f3187281589b759364395"><td class="memTemplParams" colspan="2"><a id="a4d2ce6da5d4f3187281589b759364395"></a>
template&lt;typename T , Qualification b = Qualification::unqualified&gt; </td></tr>
<tr class="memitem:a4d2ce6da5d4f3187281589b759364395"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4d2ce6da5d4f3187281589b759364395">empty_object</a></td></tr>
<tr class="memdesc:a4d2ce6da5d4f3187281589b759364395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that an object is empty (i.e., at least one index is zero-dimensional). <br /></td></tr>
<tr class="separator:a4d2ce6da5d4f3187281589b759364395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df14967a1282177068bd8aaff491e65"><td class="memTemplParams" colspan="2"><a id="a2df14967a1282177068bd8aaff491e65"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2df14967a1282177068bd8aaff491e65"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2df14967a1282177068bd8aaff491e65">has_dynamic_dimensions</a></td></tr>
<tr class="memdesc:a2df14967a1282177068bd8aaff491e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T has at least one index with dynamic dimensions. <br /></td></tr>
<tr class="separator:a2df14967a1282177068bd8aaff491e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6c3ae343e5f64996d8955c6a7a9364"><td class="memTemplParams" colspan="2"><a id="a7c6c3ae343e5f64996d8955c6a7a9364"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c6c3ae343e5f64996d8955c6a7a9364"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a7c6c3ae343e5f64996d8955c6a7a9364">has_nested_object</a></td></tr>
<tr class="memdesc:a7c6c3ae343e5f64996d8955c6a7a9364"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix that has a nested matrix, if it is a wrapper type. <br /></td></tr>
<tr class="separator:a7c6c3ae343e5f64996d8955c6a7a9364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2865e545918d7edd76731d5fe5f1e57f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a2865e545918d7edd76731d5fe5f1e57f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a></td></tr>
<tr class="memdesc:a2865e545918d7edd76731d5fe5f1e57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T has an untyped index N.  <a href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">More...</a><br /></td></tr>
<tr class="separator:a2865e545918d7edd76731d5fe5f1e57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8566a3ec777d7c9fa78b59da320a037"><td class="memTemplParams" colspan="2">template&lt;typename T , HermitianAdapterType t = HermitianAdapterType::any&gt; </td></tr>
<tr class="memitem:af8566a3ec777d7c9fa78b59da320a037"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#af8566a3ec777d7c9fa78b59da320a037">hermitian_adapter</a></td></tr>
<tr class="memdesc:af8566a3ec777d7c9fa78b59da320a037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a hermitian matrix adapter of a particular type.  <a href="namespaceOpenKalman.html#af8566a3ec777d7c9fa78b59da320a037">More...</a><br /></td></tr>
<tr class="separator:af8566a3ec777d7c9fa78b59da320a037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0088e685736596243017da33045f865"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ad0088e685736596243017da33045f865"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ad0088e685736596243017da33045f865">hermitian_adapter_type_of_v</a> = <a class="el" href="structOpenKalman_1_1hermitian__adapter__type__of.html">hermitian_adapter_type_of</a>&lt;T, Ts...&gt;::value</td></tr>
<tr class="memdesc:ad0088e685736596243017da33045f865"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TriangleType associated with the storage triangle of a <a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a>.  <a href="namespaceOpenKalman.html#ad0088e685736596243017da33045f865">More...</a><br /></td></tr>
<tr class="separator:ad0088e685736596243017da33045f865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbcbf9bf2f925d0dc32e7942a08507c"><td class="memTemplParams" colspan="2">template&lt;typename T , Qualification b = Qualification::unqualified&gt; </td></tr>
<tr class="memitem:afbbcbf9bf2f925d0dc32e7942a08507c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a></td></tr>
<tr class="memdesc:afbbcbf9bf2f925d0dc32e7942a08507c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a hermitian matrix (assuming it is <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>).  <a href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">More...</a><br /></td></tr>
<tr class="separator:afbbcbf9bf2f925d0dc32e7942a08507c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a52b813621d6f1567234b83e0cad2bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2a52b813621d6f1567234b83e0cad2bb"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2a52b813621d6f1567234b83e0cad2bb">identity_matrix</a></td></tr>
<tr class="memdesc:a2a52b813621d6f1567234b83e0cad2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is an identity matrix.  <a href="namespaceOpenKalman.html#a2a52b813621d6f1567234b83e0cad2bb">More...</a><br /></td></tr>
<tr class="separator:a2a52b813621d6f1567234b83e0cad2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357b81b7e7664f628fc14bcd5bb3bdc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a357b81b7e7664f628fc14bcd5bb3bdc0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a></td></tr>
<tr class="memdesc:a357b81b7e7664f628fc14bcd5bb3bdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a generalized tensor type.  <a href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">More...</a><br /></td></tr>
<tr class="separator:a357b81b7e7664f628fc14bcd5bb3bdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84253b07de6239d7b8db483f43255ee"><td class="memTemplParams" colspan="2"><a id="af84253b07de6239d7b8db483f43255ee"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af84253b07de6239d7b8db483f43255ee"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#af84253b07de6239d7b8db483f43255ee">mean</a> = internal::is_mean&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:af84253b07de6239d7b8db483f43255ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a mean (i.e., is a specialization of the class Mean). <br /></td></tr>
<tr class="separator:af84253b07de6239d7b8db483f43255ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad479bc10bea5f3ede5038cbf23aeb28"><td class="memTemplParams" colspan="2"><a id="aad479bc10bea5f3ede5038cbf23aeb28"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad479bc10bea5f3ede5038cbf23aeb28"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aad479bc10bea5f3ede5038cbf23aeb28">wrapped_mean</a></td></tr>
<tr class="memdesc:aad479bc10bea5f3ede5038cbf23aeb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a wrapped mean (i.e., its row fixed_vector_space_descriptor have at least one type that requires wrapping). <br /></td></tr>
<tr class="separator:aad479bc10bea5f3ede5038cbf23aeb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7b200aec405011325186b243792ebf"><td class="memTemplParams" colspan="2"><a id="a1d7b200aec405011325186b243792ebf"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d7b200aec405011325186b243792ebf"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a1d7b200aec405011325186b243792ebf">euclidean_mean</a> = internal::is_euclidean_mean&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a1d7b200aec405011325186b243792ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a Euclidean mean (i.e., is a specialization of the class EuclideanMean). <br /></td></tr>
<tr class="separator:a1d7b200aec405011325186b243792ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde753e8fa98ead4323ad7f74c6e314f"><td class="memTemplParams" colspan="2"><a id="afde753e8fa98ead4323ad7f74c6e314f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afde753e8fa98ead4323ad7f74c6e314f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#afde753e8fa98ead4323ad7f74c6e314f">euclidean_transformed</a></td></tr>
<tr class="memdesc:afde753e8fa98ead4323ad7f74c6e314f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a Euclidean mean that actually has coefficients that are transformed to Euclidean space. <br /></td></tr>
<tr class="separator:afde753e8fa98ead4323ad7f74c6e314f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47b21e50b1569c5b7cf3824fdd2be87"><td class="memTemplParams" colspan="2"><a id="aa47b21e50b1569c5b7cf3824fdd2be87"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa47b21e50b1569c5b7cf3824fdd2be87"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a> = <a class="el" href="namespaceOpenKalman.html#af84253b07de6239d7b8db483f43255ee">mean</a>&lt;T&gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a1d7b200aec405011325186b243792ebf">euclidean_mean</a>&lt;T&gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> internal::is_matrix&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:aa47b21e50b1569c5b7cf3824fdd2be87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a typed matrix (i.e., is a specialization of Matrix, Mean, or EuclideanMean). <br /></td></tr>
<tr class="separator:aa47b21e50b1569c5b7cf3824fdd2be87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198d517cf1bb5f7492fc6b5e7c99545a"><td class="memTemplParams" colspan="2"><a id="a198d517cf1bb5f7492fc6b5e7c99545a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a198d517cf1bb5f7492fc6b5e7c99545a"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a198d517cf1bb5f7492fc6b5e7c99545a">self_adjoint_covariance</a> = internal::is_self_adjoint_covariance&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a198d517cf1bb5f7492fc6b5e7c99545a"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a self-adjoint covariance matrix (i.e., a specialization of Covariance). <br /></td></tr>
<tr class="separator:a198d517cf1bb5f7492fc6b5e7c99545a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3391652c86c0ea55fa64d7aa61216a"><td class="memTemplParams" colspan="2"><a id="a8b3391652c86c0ea55fa64d7aa61216a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b3391652c86c0ea55fa64d7aa61216a"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a8b3391652c86c0ea55fa64d7aa61216a">triangular_covariance</a> = internal::is_triangular_covariance&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a8b3391652c86c0ea55fa64d7aa61216a"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a square root (Cholesky) covariance matrix (i.e., a specialization of SquareRootCovariance). <br /></td></tr>
<tr class="separator:a8b3391652c86c0ea55fa64d7aa61216a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f321ae7c589c6f337efe84ccd948586"><td class="memTemplParams" colspan="2"><a id="a7f321ae7c589c6f337efe84ccd948586"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f321ae7c589c6f337efe84ccd948586"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a> = <a class="el" href="namespaceOpenKalman.html#a198d517cf1bb5f7492fc6b5e7c99545a">self_adjoint_covariance</a>&lt;T&gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a8b3391652c86c0ea55fa64d7aa61216a">triangular_covariance</a>&lt;T&gt;</td></tr>
<tr class="memdesc:a7f321ae7c589c6f337efe84ccd948586"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a specialization of either Covariance or SquareRootCovariance. <br /></td></tr>
<tr class="separator:a7f321ae7c589c6f337efe84ccd948586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e676386d6ed5b7749578d8a4e966d96"><td class="memTemplParams" colspan="2"><a id="a2e676386d6ed5b7749578d8a4e966d96"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e676386d6ed5b7749578d8a4e966d96"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2e676386d6ed5b7749578d8a4e966d96">gaussian_distribution</a> = internal::is_gaussian_distribution&lt;std::decay_t&lt;T&gt;&gt;::value</td></tr>
<tr class="memdesc:a2e676386d6ed5b7749578d8a4e966d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a Gaussian distribution. <br /></td></tr>
<tr class="separator:a2e676386d6ed5b7749578d8a4e966d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fd1f9ea5bea9c8f9454beeb3898dc0"><td class="memTemplParams" colspan="2"><a id="ae1fd1f9ea5bea9c8f9454beeb3898dc0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1fd1f9ea5bea9c8f9454beeb3898dc0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ae1fd1f9ea5bea9c8f9454beeb3898dc0">distribution</a> = <a class="el" href="namespaceOpenKalman.html#a2e676386d6ed5b7749578d8a4e966d96">gaussian_distribution</a>&lt;T&gt;</td></tr>
<tr class="memdesc:ae1fd1f9ea5bea9c8f9454beeb3898dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a statistical distribution of any kind that is defined in <a class="el" href="namespaceOpenKalman.html" title="The root namespace for OpenKalman.">OpenKalman</a>. <br /></td></tr>
<tr class="separator:ae1fd1f9ea5bea9c8f9454beeb3898dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db5d6f9c808b45eb7f9e8bb78ab5d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14db5d6f9c808b45eb7f9e8bb78ab5d6"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a14db5d6f9c808b45eb7f9e8bb78ab5d6">cholesky_form</a> = (not <a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a>&lt;T&gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not <a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a>&lt;<a class="el" href="namespaceOpenKalman.html#a03b16f3264522ab5b6be8215b82b7e9d">nested_object_of_t</a>&lt;T&gt;&gt;)</td></tr>
<tr class="memdesc:a14db5d6f9c808b45eb7f9e8bb78ab5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type has a nested native matrix that is a Cholesky square root.  <a href="namespaceOpenKalman.html#a14db5d6f9c808b45eb7f9e8bb78ab5d6">More...</a><br /></td></tr>
<tr class="separator:a14db5d6f9c808b45eb7f9e8bb78ab5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb015187a4dc31623f1917928e0ce69"><td class="memTemplParams" colspan="2"><a id="addb015187a4dc31623f1917928e0ce69"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:addb015187a4dc31623f1917928e0ce69"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a></td></tr>
<tr class="memdesc:addb015187a4dc31623f1917928e0ce69"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is an acceptable nested matrix for a covariance (including triangular_covariance). <br /></td></tr>
<tr class="separator:addb015187a4dc31623f1917928e0ce69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5132d834a8b3d816e1ab09a2912737"><td class="memTemplParams" colspan="2"><a id="a3d5132d834a8b3d816e1ab09a2912737"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d5132d834a8b3d816e1ab09a2912737"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a></td></tr>
<tr class="memdesc:a3d5132d834a8b3d816e1ab09a2912737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies a type that is nestable in a general typed matrix (e.g., matrix, mean, or euclidean_mean) <br /></td></tr>
<tr class="separator:a3d5132d834a8b3d816e1ab09a2912737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd99301266e3bb4f1d2d92b69b324ab"><td class="memTemplParams" colspan="2">template&lt;typename T , Qualification b = Qualification::unqualified&gt; </td></tr>
<tr class="memitem:a2dd99301266e3bb4f1d2d92b69b324ab"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2dd99301266e3bb4f1d2d92b69b324ab">one_dimensional</a></td></tr>
<tr class="memdesc:a2dd99301266e3bb4f1d2d92b69b324ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is one-dimensional in every index.  <a href="namespaceOpenKalman.html#a2dd99301266e3bb4f1d2d92b69b324ab">More...</a><br /></td></tr>
<tr class="separator:a2dd99301266e3bb4f1d2d92b69b324ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcd379baf13eb66452873164e6354f8"><td class="memTemplParams" colspan="2">template&lt;typename T , Qualification b = Qualification::unqualified&gt; </td></tr>
<tr class="memitem:a9bcd379baf13eb66452873164e6354f8"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a></td></tr>
<tr class="memdesc:a9bcd379baf13eb66452873164e6354f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that an object is square (i.e., has equivalent <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> along each dimension).  <a href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">More...</a><br /></td></tr>
<tr class="separator:a9bcd379baf13eb66452873164e6354f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8913d4eca256134749dc085bf617466"><td class="memTemplParams" colspan="2"><a id="ac8913d4eca256134749dc085bf617466"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ac8913d4eca256134749dc085bf617466"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ac8913d4eca256134749dc085bf617466">triangle_type_of_v</a> = <a class="el" href="structOpenKalman_1_1triangle__type__of.html">triangle_type_of</a>&lt;T, Ts...&gt;::value</td></tr>
<tr class="memdesc:ac8913d4eca256134749dc085bf617466"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TriangleType associated with a <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>. <br /></td></tr>
<tr class="separator:ac8913d4eca256134749dc085bf617466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3191dafc41675832797c59b2a719eba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3191dafc41675832797c59b2a719eba"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ae3191dafc41675832797c59b2a719eba">triangular_adapter</a></td></tr>
<tr class="memdesc:ae3191dafc41675832797c59b2a719eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a triangular adapter of triangle type triangle_type.  <a href="namespaceOpenKalman.html#ae3191dafc41675832797c59b2a719eba">More...</a><br /></td></tr>
<tr class="separator:ae3191dafc41675832797c59b2a719eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1fd82767ce2a6be113c3ed4d96350c"><td class="memTemplParams" colspan="2">template&lt;typename T , TriangleType t = TriangleType::any&gt; </td></tr>
<tr class="memitem:adf1fd82767ce2a6be113c3ed4d96350c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a></td></tr>
<tr class="memdesc:adf1fd82767ce2a6be113c3ed4d96350c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is a triangular matrix (upper, lower, or diagonal).  <a href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">More...</a><br /></td></tr>
<tr class="separator:adf1fd82767ce2a6be113c3ed4d96350c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aec890e453b7ffbd9ddec82cd150772"><td class="memTemplParams" colspan="2"><a id="a1aec890e453b7ffbd9ddec82cd150772"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1aec890e453b7ffbd9ddec82cd150772"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a1aec890e453b7ffbd9ddec82cd150772">typed_adapter</a></td></tr>
<tr class="memdesc:a1aec890e453b7ffbd9ddec82cd150772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a typed adapter expression. <br /></td></tr>
<tr class="separator:a1aec890e453b7ffbd9ddec82cd150772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aecb900a734f8906da8e96db6e702a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4aecb900a734f8906da8e96db6e702a6"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4aecb900a734f8906da8e96db6e702a6">untyped_adapter</a></td></tr>
<tr class="memdesc:a4aecb900a734f8906da8e96db6e702a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is an untyped adapter expression.  <a href="namespaceOpenKalman.html#a4aecb900a734f8906da8e96db6e702a6">More...</a><br /></td></tr>
<tr class="separator:a4aecb900a734f8906da8e96db6e702a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab737b3bbdad3ee74c92a344a6a18c447"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N = 0, Qualification b = Qualification::unqualified&gt; </td></tr>
<tr class="memitem:ab737b3bbdad3ee74c92a344a6a18c447"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a></td></tr>
<tr class="memdesc:ab737b3bbdad3ee74c92a344a6a18c447"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a vector (e.g., column or row vector).  <a href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">More...</a><br /></td></tr>
<tr class="separator:ab737b3bbdad3ee74c92a344a6a18c447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06c81bf543e750616dc3cb2115885d8"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:af06c81bf543e750616dc3cb2115885d8"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#af06c81bf543e750616dc3cb2115885d8">vector_space_descriptors_match_with</a></td></tr>
<tr class="memdesc:af06c81bf543e750616dc3cb2115885d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a set of indexible objects have <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent</a> vector space descriptors for each index.  <a href="namespaceOpenKalman.html#af06c81bf543e750616dc3cb2115885d8">More...</a><br /></td></tr>
<tr class="separator:af06c81bf543e750616dc3cb2115885d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71866768ca1d2b98352a34f58eac26a4"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a71866768ca1d2b98352a34f58eac26a4"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a71866768ca1d2b98352a34f58eac26a4">vector_space_descriptors_may_match_with</a></td></tr>
<tr class="memdesc:a71866768ca1d2b98352a34f58eac26a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> objects Ts may have equivalent dimensions and vector-space types.  <a href="namespaceOpenKalman.html#a71866768ca1d2b98352a34f58eac26a4">More...</a><br /></td></tr>
<tr class="separator:a71866768ca1d2b98352a34f58eac26a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0446f0fba3feb5d14a40bf9d375ba31e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0446f0fba3feb5d14a40bf9d375ba31e"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0446f0fba3feb5d14a40bf9d375ba31e">wrappable</a></td></tr>
<tr class="memdesc:a0446f0fba3feb5d14a40bf9d375ba31e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that every fixed-size index of T (other than potentially index 0) is euclidean.  <a href="namespaceOpenKalman.html#a0446f0fba3feb5d14a40bf9d375ba31e">More...</a><br /></td></tr>
<tr class="separator:a0446f0fba3feb5d14a40bf9d375ba31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7388b89ddb8b8aa2c0e1be66900dee"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd7388b89ddb8b8aa2c0e1be66900dee"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#abd7388b89ddb8b8aa2c0e1be66900dee">writable</a></td></tr>
<tr class="memdesc:abd7388b89ddb8b8aa2c0e1be66900dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that T is a dense, writable matrix.  <a href="namespaceOpenKalman.html#abd7388b89ddb8b8aa2c0e1be66900dee">More...</a><br /></td></tr>
<tr class="separator:abd7388b89ddb8b8aa2c0e1be66900dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10408b0379abb2d3405f6401d563e149"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Indices  = std::conditional_t&lt;index_count_v&lt;T&gt; == dynamic_size, std::array&lt;std::size_t, index_count_v&lt;T&gt;&gt;, std::vector&lt;std::size_t&gt;&gt;&gt; </td></tr>
<tr class="memitem:a10408b0379abb2d3405f6401d563e149"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a10408b0379abb2d3405f6401d563e149">writable_by_component</a></td></tr>
<tr class="memdesc:a10408b0379abb2d3405f6401d563e149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type has components that can be set with Indices (an std::ranges::input_range) of type std::size_t.  <a href="namespaceOpenKalman.html#a10408b0379abb2d3405f6401d563e149">More...</a><br /></td></tr>
<tr class="separator:a10408b0379abb2d3405f6401d563e149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0674aa914eb3ec11e5bd68221094ef9"><td class="memTemplParams" colspan="2"><a id="aa0674aa914eb3ec11e5bd68221094ef9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0674aa914eb3ec11e5bd68221094ef9"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a></td></tr>
<tr class="memdesc:aa0674aa914eb3ec11e5bd68221094ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a type is known at compile time to be a constant matrix of value zero. <br /></td></tr>
<tr class="separator:aa0674aa914eb3ec11e5bd68221094ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ca7c438cbddb3fd487e299c4d185ea"><td class="memTemplParams" colspan="2"><a id="a04ca7c438cbddb3fd487e299c4d185ea"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a04ca7c438cbddb3fd487e299c4d185ea"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a04ca7c438cbddb3fd487e299c4d185ea">dynamic_index_value</a></td></tr>
<tr class="memdesc:a04ca7c438cbddb3fd487e299c4d185ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a dynamic index value. <br /></td></tr>
<tr class="separator:a04ca7c438cbddb3fd487e299c4d185ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8a5ca9cb2a660eb584981e1339b87a"><td class="memTemplParams" colspan="2"><a id="a8b8a5ca9cb2a660eb584981e1339b87a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b8a5ca9cb2a660eb584981e1339b87a"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a8b8a5ca9cb2a660eb584981e1339b87a">index_value</a></td></tr>
<tr class="memdesc:a8b8a5ca9cb2a660eb584981e1339b87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is an index value. <br /></td></tr>
<tr class="separator:a8b8a5ca9cb2a660eb584981e1339b87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc94c01586781f39e5e41a7a14378dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Z  = std::size_t&gt; </td></tr>
<tr class="memitem:a1cc94c01586781f39e5e41a7a14378dc"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a1cc94c01586781f39e5e41a7a14378dc">static_index_value</a></td></tr>
<tr class="memdesc:a1cc94c01586781f39e5e41a7a14378dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a static index value.  <a href="namespaceOpenKalman.html#a1cc94c01586781f39e5e41a7a14378dc">More...</a><br /></td></tr>
<tr class="separator:a1cc94c01586781f39e5e41a7a14378dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cdde4b102bbb681e3dc62a9e767cb6"><td class="memTemplParams" colspan="2"><a id="a43cdde4b102bbb681e3dc62a9e767cb6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43cdde4b102bbb681e3dc62a9e767cb6"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a43cdde4b102bbb681e3dc62a9e767cb6">complex_number</a> = <a class="el" href="structOpenKalman_1_1interface_1_1scalar__traits.html">interface::scalar_traits</a>&lt;std::decay_t&lt;T&gt;&gt;::is_complex</td></tr>
<tr class="memdesc:a43cdde4b102bbb681e3dc62a9e767cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is std::complex or a custom complex type. <br /></td></tr>
<tr class="separator:a43cdde4b102bbb681e3dc62a9e767cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75ed2f5c6d5e67c02b095f3f14bf7c7"><td class="memTemplParams" colspan="2"><a id="ae75ed2f5c6d5e67c02b095f3f14bf7c7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae75ed2f5c6d5e67c02b095f3f14bf7c7"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ae75ed2f5c6d5e67c02b095f3f14bf7c7">floating_scalar_type</a></td></tr>
<tr class="memdesc:ae75ed2f5c6d5e67c02b095f3f14bf7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a floating-point scalar type. <br /></td></tr>
<tr class="separator:ae75ed2f5c6d5e67c02b095f3f14bf7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6865fd1e6b35c6be70b2f464dfd6497b"><td class="memTemplParams" colspan="2"><a id="a6865fd1e6b35c6be70b2f464dfd6497b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6865fd1e6b35c6be70b2f464dfd6497b"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a6865fd1e6b35c6be70b2f464dfd6497b">real_axis_number</a></td></tr>
<tr class="memdesc:a6865fd1e6b35c6be70b2f464dfd6497b"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is either not a <a class="el" href="namespaceOpenKalman.html#a43cdde4b102bbb681e3dc62a9e767cb6">complex_number</a> or its imaginary component is 0. <br /></td></tr>
<tr class="separator:a6865fd1e6b35c6be70b2f464dfd6497b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72829d83ccbc836bfb60d395cd4d5331"><td class="memTemplParams" colspan="2">template&lt;typename T , ConstantType c = ConstantType::any&gt; </td></tr>
<tr class="memitem:a72829d83ccbc836bfb60d395cd4d5331"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a72829d83ccbc836bfb60d395cd4d5331">scalar_constant</a></td></tr>
<tr class="memdesc:a72829d83ccbc836bfb60d395cd4d5331"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a scalar constant.  <a href="namespaceOpenKalman.html#a72829d83ccbc836bfb60d395cd4d5331">More...</a><br /></td></tr>
<tr class="separator:a72829d83ccbc836bfb60d395cd4d5331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7f9880c66287c68d382f6a1352d069"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae7f9880c66287c68d382f6a1352d069"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a></td></tr>
<tr class="memdesc:aae7f9880c66287c68d382f6a1352d069"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a scalar type.  <a href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">More...</a><br /></td></tr>
<tr class="separator:aae7f9880c66287c68d382f6a1352d069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa828dc27ee7d74c91968b38a82e5dac6"><td class="memTemplParams" colspan="2"><a id="aa828dc27ee7d74c91968b38a82e5dac6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa828dc27ee7d74c91968b38a82e5dac6"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aa828dc27ee7d74c91968b38a82e5dac6">angle_vector_space_descriptor</a></td></tr>
<tr class="memdesc:aa828dc27ee7d74c91968b38a82e5dac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> object representing an angle. <br /></td></tr>
<tr class="separator:aa828dc27ee7d74c91968b38a82e5dac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff25390bb0b5e5e73139cd09afa1795"><td class="memTemplParams" colspan="2"><a id="a0ff25390bb0b5e5e73139cd09afa1795"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ff25390bb0b5e5e73139cd09afa1795"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0ff25390bb0b5e5e73139cd09afa1795">inclination_vector_space_descriptor</a></td></tr>
<tr class="memdesc:a0ff25390bb0b5e5e73139cd09afa1795"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> object representing an inclination. <br /></td></tr>
<tr class="separator:a0ff25390bb0b5e5e73139cd09afa1795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8118548e58d6571ae37572fc5e04206d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8118548e58d6571ae37572fc5e04206d"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a8118548e58d6571ae37572fc5e04206d">atomic_fixed_vector_space_descriptor</a></td></tr>
<tr class="memdesc:a8118548e58d6571ae37572fc5e04206d"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is an atomic (non-separable or non-composite) group of fixed <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a>.  <a href="namespaceOpenKalman.html#a8118548e58d6571ae37572fc5e04206d">More...</a><br /></td></tr>
<tr class="separator:a8118548e58d6571ae37572fc5e04206d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07fe14df356f0f5e28afcfc7c47ad86"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab07fe14df356f0f5e28afcfc7c47ad86"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ab07fe14df356f0f5e28afcfc7c47ad86">composite_vector_space_descriptor</a></td></tr>
<tr class="memdesc:ab07fe14df356f0f5e28afcfc7c47ad86"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a <a class="el" href="namespaceOpenKalman.html#ab07fe14df356f0f5e28afcfc7c47ad86">composite_vector_space_descriptor</a>.  <a href="namespaceOpenKalman.html#ab07fe14df356f0f5e28afcfc7c47ad86">More...</a><br /></td></tr>
<tr class="separator:ab07fe14df356f0f5e28afcfc7c47ad86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592e04b6d486227e1e469eaceae0e17a"><td class="memTemplParams" colspan="2"><a id="a592e04b6d486227e1e469eaceae0e17a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a592e04b6d486227e1e469eaceae0e17a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a> = <a class="el" href="structOpenKalman_1_1dimension__size__of.html">dimension_size_of</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a592e04b6d486227e1e469eaceae0e17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="structOpenKalman_1_1dimension__size__of.html">dimension_size_of</a>. <br /></td></tr>
<tr class="separator:a592e04b6d486227e1e469eaceae0e17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eae8386d50ed98dc96326732ef9234"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a31eae8386d50ed98dc96326732ef9234"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a31eae8386d50ed98dc96326732ef9234">dynamic_vector_space_descriptor</a></td></tr>
<tr class="memdesc:a31eae8386d50ed98dc96326732ef9234"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> for which the number of dimensions is defined at runtime.  <a href="namespaceOpenKalman.html#a31eae8386d50ed98dc96326732ef9234">More...</a><br /></td></tr>
<tr class="separator:a31eae8386d50ed98dc96326732ef9234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7ac95c22475788a1bc2adf9315ba5d"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a7f7ac95c22475788a1bc2adf9315ba5d"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a></td></tr>
<tr class="memdesc:a7f7ac95c22475788a1bc2adf9315ba5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> objects are known at compile time to be equivalent.  <a href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">More...</a><br /></td></tr>
<tr class="separator:a7f7ac95c22475788a1bc2adf9315ba5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8831f8a8cb3083e1606a0d99679814c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename C &gt; </td></tr>
<tr class="memitem:ad8831f8a8cb3083e1606a0d99679814c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ad8831f8a8cb3083e1606a0d99679814c">equivalent_to_uniform_fixed_vector_space_descriptor_component_of</a> = <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt;T, <a class="el" href="namespaceOpenKalman.html#a5ba3df824cdc8ddd172e52be74196644">uniform_fixed_vector_space_descriptor_component_of_t</a>&lt;C&gt;&gt;</td></tr>
<tr class="memdesc:ad8831f8a8cb3083e1606a0d99679814c"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is equivalent to the uniform dimension type of C.  <a href="namespaceOpenKalman.html#ad8831f8a8cb3083e1606a0d99679814c">More...</a><br /></td></tr>
<tr class="separator:ad8831f8a8cb3083e1606a0d99679814c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399b0547d1b74a66dd68157b927b3e5d"><td class="memTemplParams" colspan="2"><a id="a399b0547d1b74a66dd68157b927b3e5d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a399b0547d1b74a66dd68157b927b3e5d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a399b0547d1b74a66dd68157b927b3e5d">euclidean_dimension_size_of_v</a> = <a class="el" href="structOpenKalman_1_1euclidean__dimension__size__of.html">euclidean_dimension_size_of</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a399b0547d1b74a66dd68157b927b3e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="structOpenKalman_1_1euclidean__dimension__size__of.html">euclidean_dimension_size_of</a>. <br /></td></tr>
<tr class="separator:a399b0547d1b74a66dd68157b927b3e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4a660c145525d68a44fad81f52d1b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4a4a660c145525d68a44fad81f52d1b9"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4a4a660c145525d68a44fad81f52d1b9">euclidean_vector_space_descriptor</a></td></tr>
<tr class="memdesc:a4a4a660c145525d68a44fad81f52d1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> for a normal tensor index, which identifies non-modular coordinates in Euclidean space.  <a href="namespaceOpenKalman.html#a4a4a660c145525d68a44fad81f52d1b9">More...</a><br /></td></tr>
<tr class="separator:a4a4a660c145525d68a44fad81f52d1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055e7b9e1a13db048847821c1d71dd5f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a055e7b9e1a13db048847821c1d71dd5f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a></td></tr>
<tr class="memdesc:a055e7b9e1a13db048847821c1d71dd5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> for which the number of dimensions is fixed at compile time.  <a href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">More...</a><br /></td></tr>
<tr class="separator:a055e7b9e1a13db048847821c1d71dd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d179caf50325236f04ae3778c02519"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a34d179caf50325236f04ae3778c02519"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a34d179caf50325236f04ae3778c02519">maybe_equivalent_to</a></td></tr>
<tr class="memdesc:a34d179caf50325236f04ae3778c02519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that a set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> objects may be equivalent based on what is known at compile time.  <a href="namespaceOpenKalman.html#a34d179caf50325236f04ae3778c02519">More...</a><br /></td></tr>
<tr class="separator:a34d179caf50325236f04ae3778c02519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5e34c97d63bb06f980344d91524410"><td class="memTemplParams" colspan="2"><a id="a0f5e34c97d63bb06f980344d91524410"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0f5e34c97d63bb06f980344d91524410"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0f5e34c97d63bb06f980344d91524410">uniform_fixed_vector_space_descriptor</a></td></tr>
<tr class="memdesc:a0f5e34c97d63bb06f980344d91524410"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is a <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> that can be decomposed into a uniform set of 1D <a class="el" href="namespaceOpenKalman_1_1vector__space__descriptors.html">vector_space_descriptors</a>. <br /></td></tr>
<tr class="separator:a0f5e34c97d63bb06f980344d91524410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2b1b4b09a3b012e95b054965dad682"><td class="memTemplParams" colspan="2"><a id="a4a2b1b4b09a3b012e95b054965dad682"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4a2b1b4b09a3b012e95b054965dad682"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4a2b1b4b09a3b012e95b054965dad682">vector_space_component_count_v</a> = <a class="el" href="structOpenKalman_1_1vector__space__component__count.html">vector_space_component_count</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a4a2b1b4b09a3b012e95b054965dad682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="structOpenKalman_1_1vector__space__component__count.html">vector_space_component_count</a>. <br /></td></tr>
<tr class="separator:a4a2b1b4b09a3b012e95b054965dad682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa798b43668ea60705a78485a84a200"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6aa798b43668ea60705a78485a84a200"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a></td></tr>
<tr class="memdesc:a6aa798b43668ea60705a78485a84a200"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object describing the type of (vector) space associated with a tensor index.  <a href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">More...</a><br /></td></tr>
<tr class="separator:a6aa798b43668ea60705a78485a84a200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530caeba987ecaa553e5b8430818ee20"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t order = 1&gt; </td></tr>
<tr class="memitem:a530caeba987ecaa553e5b8430818ee20"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a530caeba987ecaa553e5b8430818ee20">linearized_function</a></td></tr>
<tr class="memdesc:a530caeba987ecaa553e5b8430818ee20"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linearized function (with defined Jacobian and optionally Hessian functions).  <a href="namespaceOpenKalman.html#a530caeba987ecaa553e5b8430818ee20">More...</a><br /></td></tr>
<tr class="separator:a530caeba987ecaa553e5b8430818ee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188757d14b80eaab112f0aefa1031dbe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Coeffs  = typename oin::PerturbationTraits&lt;T&gt;::RowCoefficients&gt; </td></tr>
<tr class="memitem:a188757d14b80eaab112f0aefa1031dbe"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a188757d14b80eaab112f0aefa1031dbe">transformation_input</a></td></tr>
<tr class="memdesc:a188757d14b80eaab112f0aefa1031dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is an acceptable input to a tests.  <a href="namespaceOpenKalman.html#a188757d14b80eaab112f0aefa1031dbe">More...</a><br /></td></tr>
<tr class="separator:a188757d14b80eaab112f0aefa1031dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bf66c95289a9d90a189c843755687f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Coeffs  = typename oin::PerturbationTraits&lt;T&gt;::RowCoefficients&gt; </td></tr>
<tr class="memitem:a39bf66c95289a9d90a189c843755687f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a39bf66c95289a9d90a189c843755687f">perturbation</a></td></tr>
<tr class="memdesc:a39bf66c95289a9d90a189c843755687f"><td class="mdescLeft">&#160;</td><td class="mdescRight">T is an acceptable noise perturbation input to a tests.  <a href="namespaceOpenKalman.html#a39bf66c95289a9d90a189c843755687f">More...</a><br /></td></tr>
<tr class="separator:a39bf66c95289a9d90a189c843755687f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3899b43bdfa17fa31303340b2dd9121e"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121e">Layout</a> : int { <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea334c4a4c42fdb79d7ebc3e73b517e6f8">none</a>
, <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea7c4f29407893c334a6cb7a87bf045c0d">right</a>
, <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea811882fecd5c7618d7099ebbd39ea254">left</a>
, <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea47101375aa96fa02cfb1d55fd00af989">stride</a>
 }</td></tr>
<tr class="memdesc:a3899b43bdfa17fa31303340b2dd9121e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The layout format of a multidimensional array.  <a href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121e">More...</a><br /></td></tr>
<tr class="separator:a3899b43bdfa17fa31303340b2dd9121e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d7114313206e555dfb932ccc82209b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a> : int { <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209baa0e17e2709a0404ae3d7de03b8ea9093">diagonal</a>
, <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba81e073b428b50247daba38531dcf412a">lower</a>
, <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">upper</a>
, <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba100b8cad7cf2a56f6df78f171f97a1ec">any</a>
 }</td></tr>
<tr class="memdesc:a04d7114313206e555dfb932ccc82209b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a triangular matrix.  <a href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">More...</a><br /></td></tr>
<tr class="separator:a04d7114313206e555dfb932ccc82209b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a9bbfcbe19f7fc489fd1405bfdce76"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aa8a9bbfcbe19f7fc489fd1405bfdce76">HermitianAdapterType</a> : int { <a class="el" href="namespaceOpenKalman.html#aa8a9bbfcbe19f7fc489fd1405bfdce76a100b8cad7cf2a56f6df78f171f97a1ec">any</a> = static_cast&lt;int&gt;(TriangleType::diagonal)
, <a class="el" href="namespaceOpenKalman.html#aa8a9bbfcbe19f7fc489fd1405bfdce76a81e073b428b50247daba38531dcf412a">lower</a> = static_cast&lt;int&gt;(TriangleType::lower)
, <a class="el" href="namespaceOpenKalman.html#aa8a9bbfcbe19f7fc489fd1405bfdce76a0122b4c2c01ee1c698ecc309d2b8eb5a">upper</a> = static_cast&lt;int&gt;(TriangleType::upper)
 }</td></tr>
<tr class="memdesc:aa8a9bbfcbe19f7fc489fd1405bfdce76"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a hermitian adapter, indicating which triangle of the nested matrix is used.  <a href="namespaceOpenKalman.html#aa8a9bbfcbe19f7fc489fd1405bfdce76">More...</a><br /></td></tr>
<tr class="separator:aa8a9bbfcbe19f7fc489fd1405bfdce76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8d9ff3bc2be3b04457b2ae3df89832"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832">Qualification</a> : int { <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832ab19eb7aa5ed583579f9827b838e3d191">unqualified</a>
, <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30">depends_on_dynamic_shape</a>
 }</td></tr>
<tr class="memdesc:a3d8d9ff3bc2be3b04457b2ae3df89832"><td class="mdescLeft">&#160;</td><td class="mdescRight">How a concept or trait is qualified.  <a href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832">More...</a><br /></td></tr>
<tr class="separator:a3d8d9ff3bc2be3b04457b2ae3df89832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa745cbaa0edbfed7d1da05691e07d47b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aa745cbaa0edbfed7d1da05691e07d47b">ConstantType</a> { <a class="el" href="namespaceOpenKalman.html#aa745cbaa0edbfed7d1da05691e07d47ba100b8cad7cf2a56f6df78f171f97a1ec">any</a>
, <a class="el" href="namespaceOpenKalman.html#aa745cbaa0edbfed7d1da05691e07d47ba32c2b7f95065494184e8b5799d3618e7">dynamic_constant</a>
, <a class="el" href="namespaceOpenKalman.html#aa745cbaa0edbfed7d1da05691e07d47baa90e37207f27e1996845a3c7d594fd0a">static_constant</a>
 }</td></tr>
<tr class="memdesc:aa745cbaa0edbfed7d1da05691e07d47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of constant.  <a href="namespaceOpenKalman.html#aa745cbaa0edbfed7d1da05691e07d47b">More...</a><br /></td></tr>
<tr class="separator:aa745cbaa0edbfed7d1da05691e07d47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Aliases</h2></td></tr>
<tr class="memitem:a3ffd6208ec107df3ffefbff512f0ad27"><td class="memTemplParams" colspan="2">template&lt;indexible PatternObject, scalar_type Scalar = scalar_type_of_t&lt;PatternObject&gt;&gt; </td></tr>
<tr class="memitem:a3ffd6208ec107df3ffefbff512f0ad27"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a3ffd6208ec107df3ffefbff512f0ad27">ZeroAdapter</a> = ConstantAdapter&lt; PatternObject, Scalar, 0 &gt;</td></tr>
<tr class="memdesc:a3ffd6208ec107df3ffefbff512f0ad27"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ConstantAdapter in which all elements are 0.  <a href="namespaceOpenKalman.html#a3ffd6208ec107df3ffefbff512f0ad27">More...</a><br /></td></tr>
<tr class="separator:a3ffd6208ec107df3ffefbff512f0ad27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314099a953f3874ecbadc92985ecc504"><td class="memTemplParams" colspan="2"><a id="a314099a953f3874ecbadc92985ecc504"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a314099a953f3874ecbadc92985ecc504"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a314099a953f3874ecbadc92985ecc504">pattern_matrix_of_t</a> = typename <a class="el" href="structOpenKalman_1_1pattern__matrix__of.html">pattern_matrix_of</a>&lt; std::decay_t&lt; T &gt; &gt;::type</td></tr>
<tr class="memdesc:a314099a953f3874ecbadc92985ecc504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="structOpenKalman_1_1pattern__matrix__of.html" title="The native matrix on which an OpenKalman matrix adapter is patterned.">pattern_matrix_of</a>. <br /></td></tr>
<tr class="separator:a314099a953f3874ecbadc92985ecc504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b16f3264522ab5b6be8215b82b7e9d"><td class="memTemplParams" colspan="2">template&lt;has_nested_object T&gt; </td></tr>
<tr class="memitem:a03b16f3264522ab5b6be8215b82b7e9d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a03b16f3264522ab5b6be8215b82b7e9d">nested_object_of_t</a> = typename <a class="el" href="structOpenKalman_1_1nested__object__of.html">nested_object_of</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a03b16f3264522ab5b6be8215b82b7e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper type for <a class="el" href="structOpenKalman_1_1nested__object__of.html">nested_object_of</a>.  <a href="namespaceOpenKalman.html#a03b16f3264522ab5b6be8215b82b7e9d">More...</a><br /></td></tr>
<tr class="separator:a03b16f3264522ab5b6be8215b82b7e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecbd87443fa0938b5d8f10271761dce"><td class="memTemplParams" colspan="2"><a id="abecbd87443fa0938b5d8f10271761dce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abecbd87443fa0938b5d8f10271761dce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a> = typename <a class="el" href="structOpenKalman_1_1scalar__type__of.html">scalar_type_of</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:abecbd87443fa0938b5d8f10271761dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper template for <a class="el" href="structOpenKalman_1_1scalar__type__of.html">scalar_type_of</a>. <br /></td></tr>
<tr class="separator:abecbd87443fa0938b5d8f10271761dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41181972b06178290c0a128453ed5ed"><td class="memTemplParams" colspan="2"><a id="ad41181972b06178290c0a128453ed5ed"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ad41181972b06178290c0a128453ed5ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a> = typename <a class="el" href="structOpenKalman_1_1vector__space__descriptor__of.html">vector_space_descriptor_of</a>&lt; T, N &gt;::type</td></tr>
<tr class="memdesc:ad41181972b06178290c0a128453ed5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper template for <a class="el" href="structOpenKalman_1_1vector__space__descriptor__of.html">vector_space_descriptor_of</a>. <br /></td></tr>
<tr class="separator:ad41181972b06178290c0a128453ed5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551efec16eae409b3b9c6ecaf7c06b34"><td class="memTemplParams" colspan="2"><a id="a551efec16eae409b3b9c6ecaf7c06b34"></a>
template&lt;typename... Cs&gt; </td></tr>
<tr class="memitem:a551efec16eae409b3b9c6ecaf7c06b34"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a551efec16eae409b3b9c6ecaf7c06b34">concatenate_fixed_vector_space_descriptor_t</a> = typename <a class="el" href="structOpenKalman_1_1concatenate__fixed__vector__space__descriptor.html">concatenate_fixed_vector_space_descriptor</a>&lt; Cs... &gt;::type</td></tr>
<tr class="memdesc:a551efec16eae409b3b9c6ecaf7c06b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="structOpenKalman_1_1concatenate__fixed__vector__space__descriptor.html">concatenate_fixed_vector_space_descriptor</a>. <br /></td></tr>
<tr class="separator:a551efec16eae409b3b9c6ecaf7c06b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1daaa208308a73f358b4965b91554b"><td class="memTemplParams" colspan="2"><a id="a5e1daaa208308a73f358b4965b91554b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e1daaa208308a73f358b4965b91554b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a5e1daaa208308a73f358b4965b91554b">canonical_fixed_vector_space_descriptor_t</a> = typename <a class="el" href="structOpenKalman_1_1canonical__fixed__vector__space__descriptor.html">canonical_fixed_vector_space_descriptor</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a5e1daaa208308a73f358b4965b91554b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="structOpenKalman_1_1canonical__fixed__vector__space__descriptor.html">canonical_fixed_vector_space_descriptor</a>. <br /></td></tr>
<tr class="separator:a5e1daaa208308a73f358b4965b91554b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73babbdf8f4d8b6c1d60b4cf8c1d433"><td class="memTemplParams" colspan="2"><a id="ac73babbdf8f4d8b6c1d60b4cf8c1d433"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac73babbdf8f4d8b6c1d60b4cf8c1d433"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ac73babbdf8f4d8b6c1d60b4cf8c1d433">reverse_fixed_vector_space_descriptor_t</a> = typename <a class="el" href="structOpenKalman_1_1reverse__fixed__vector__space__descriptor.html">reverse_fixed_vector_space_descriptor</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ac73babbdf8f4d8b6c1d60b4cf8c1d433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="structOpenKalman_1_1reverse__fixed__vector__space__descriptor.html">reverse_fixed_vector_space_descriptor</a>. <br /></td></tr>
<tr class="separator:ac73babbdf8f4d8b6c1d60b4cf8c1d433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39d77b137916a8a15850d49f4740e7a"><td class="memTemplParams" colspan="2"><a id="ac39d77b137916a8a15850d49f4740e7a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac39d77b137916a8a15850d49f4740e7a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ac39d77b137916a8a15850d49f4740e7a">dimension_difference_of_t</a> = typename <a class="el" href="structOpenKalman_1_1dimension__difference__of.html">dimension_difference_of</a>&lt; std::decay_t&lt; T &gt; &gt;::type</td></tr>
<tr class="memdesc:ac39d77b137916a8a15850d49f4740e7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="structOpenKalman_1_1dimension__difference__of.html">dimension_difference_of</a>. <br /></td></tr>
<tr class="separator:ac39d77b137916a8a15850d49f4740e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c44eb728f801ccd1f88d6a0a55c555"><td class="memTemplParams" colspan="2"><a id="a35c44eb728f801ccd1f88d6a0a55c555"></a>
template&lt;typename C , std::size_t N&gt; </td></tr>
<tr class="memitem:a35c44eb728f801ccd1f88d6a0a55c555"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a35c44eb728f801ccd1f88d6a0a55c555">replicate_fixed_vector_space_descriptor_t</a> = typename replicate_fixed_vector_space_descriptor&lt; C, N &gt;::type</td></tr>
<tr class="memdesc:a35c44eb728f801ccd1f88d6a0a55c555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for replicate_fixed_vector_space_descriptor. <br /></td></tr>
<tr class="separator:a35c44eb728f801ccd1f88d6a0a55c555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba3df824cdc8ddd172e52be74196644"><td class="memTemplParams" colspan="2"><a id="a5ba3df824cdc8ddd172e52be74196644"></a>
template&lt;uniform_fixed_vector_space_descriptor T&gt; </td></tr>
<tr class="memitem:a5ba3df824cdc8ddd172e52be74196644"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a5ba3df824cdc8ddd172e52be74196644">uniform_fixed_vector_space_descriptor_component_of_t</a> = typename <a class="el" href="structOpenKalman_1_1uniform__fixed__vector__space__descriptor__component__of.html">uniform_fixed_vector_space_descriptor_component_of</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a5ba3df824cdc8ddd172e52be74196644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template for <a class="el" href="structOpenKalman_1_1uniform__fixed__vector__space__descriptor__component__of.html">uniform_fixed_vector_space_descriptor_component_of</a>. <br /></td></tr>
<tr class="separator:a5ba3df824cdc8ddd172e52be74196644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0a46bcac951601748c4f4da64d20c6"><td class="memItemLeft" align="right" valign="top"><a id="afb0a46bcac951601748c4f4da64d20c6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#afb0a46bcac951601748c4f4da64d20c6">UnscentedSigmaPoints</a> = <a class="el" href="structOpenKalman_1_1Unscented.html">Unscented</a>&lt; <a class="el" href="structOpenKalman_1_1UnscentedParametersStateEstimation.html">UnscentedParametersStateEstimation</a> &gt;</td></tr>
<tr class="memdesc:afb0a46bcac951601748c4f4da64d20c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as UnscentedSigmaPointsStateEstimation. <br /></td></tr>
<tr class="separator:afb0a46bcac951601748c4f4da64d20c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a36f0f93bfee9b8ff1801c7b75066a841"><td class="memTemplParams" colspan="2">template&lt;indexible PatternMatrix, scalar_constant Scalar, auto... constant&gt; </td></tr>
<tr class="memitem:a36f0f93bfee9b8ff1801c7b75066a841"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a36f0f93bfee9b8ff1801c7b75066a841">requires</a> (sizeof...(constant)==0) <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> requires</td></tr>
<tr class="memdesc:a36f0f93bfee9b8ff1801c7b75066a841"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor or other matrix in which all elements are a constant scalar value.  <a href="namespaceOpenKalman.html#a36f0f93bfee9b8ff1801c7b75066a841">More...</a><br /></td></tr>
<tr class="separator:a36f0f93bfee9b8ff1801c7b75066a841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cfddbbcf6833742c53fec3f3c007ec"><td class="memTemplParams" colspan="2"><a id="a05cfddbbcf6833742c53fec3f3c007ec"></a>
template&lt;covariance_nestable M&gt; </td></tr>
<tr class="memitem:a05cfddbbcf6833742c53fec3f3c007ec"><td class="memTemplItemLeft" align="right" valign="top">requires(<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;==index_dimension_of_v&lt; NestedMatrix, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not std&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a05cfddbbcf6833742c53fec3f3c007ec">Covariance</a> (M &amp;&amp;) -&gt; Covariance&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1Dimensions.html">Dimensions</a>&lt; index_dimension_of_v&lt; M, 0 &gt;&gt;, passable_t&lt; M &gt;&gt;</td></tr>
<tr class="memdesc:a05cfddbbcf6833742c53fec3f3c007ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce Covariance type from a <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>. <br /></td></tr>
<tr class="separator:a05cfddbbcf6833742c53fec3f3c007ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac377108d3e0c6c35f2995db9adf16ec6"><td class="memTemplParams" colspan="2"><a id="ac377108d3e0c6c35f2995db9adf16ec6"></a>
template&lt;typed_matrix M&gt; </td></tr>
<tr class="memitem:ac377108d3e0c6c35f2995db9adf16ec6"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ac377108d3e0c6c35f2995db9adf16ec6">Covariance</a> (M &amp;&amp;) -&gt; Covariance&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; M, 0 &gt;, typename MatrixTraits&lt; std::decay_t&lt; <a class="el" href="namespaceOpenKalman.html#a03b16f3264522ab5b6be8215b82b7e9d">nested_object_of_t</a>&lt; M &gt;&gt;&gt;::template SelfAdjointMatrixFrom&lt;&gt;&gt;</td></tr>
<tr class="memdesc:ac377108d3e0c6c35f2995db9adf16ec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce Covariance type from a square <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>. <br /></td></tr>
<tr class="separator:ac377108d3e0c6c35f2995db9adf16ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2b69064ea0d93b624e21c3ad978c1b"><td class="memTemplParams" colspan="2">template&lt;typed_matrix_nestable M&gt; </td></tr>
<tr class="memitem:a2d2b69064ea0d93b624e21c3ad978c1b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2d2b69064ea0d93b624e21c3ad978c1b">requires</a> (not <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>&lt; M &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; M &gt; explicit <a class="el" href="namespaceOpenKalman.html#a05cfddbbcf6833742c53fec3f3c007ec">Covariance</a>(M &amp;&amp;) -&gt; <a class="el" href="namespaceOpenKalman.html#a05cfddbbcf6833742c53fec3f3c007ec">Covariance</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1Dimensions.html">Dimensions</a>&lt; index_dimension_of_v&lt; M, 0 &gt;&gt;, typename MatrixTraits&lt; std::decay_t&lt; M &gt;&gt;::template SelfAdjointMatrixFrom&lt;&gt;&gt;</td></tr>
<tr class="memdesc:a2d2b69064ea0d93b624e21c3ad978c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce Covariance type from a square <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>.  <a href="namespaceOpenKalman.html#a2d2b69064ea0d93b624e21c3ad978c1b">More...</a><br /></td></tr>
<tr class="separator:a2d2b69064ea0d93b624e21c3ad978c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389f725d61029bd7034f2723b3bf37a2"><td class="memTemplParams" colspan="2">template&lt;fixed_vector_space_descriptor FixedDescriptor, covariance_nestable Arg&gt; </td></tr>
<tr class="memitem:a389f725d61029bd7034f2723b3bf37a2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a389f725d61029bd7034f2723b3bf37a2">requires</a> (<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;==index_dimension_of_v&lt; Arg, 0 &gt;) inline auto <a class="el" href="namespaceOpenKalman.html#a8482a5fd9758debdb1214b304e765525">make_covariance</a>(Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a389f725d61029bd7034f2723b3bf37a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Covariance from a <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>, specifying the fixed_vector_space_descriptor.  <a href="namespaceOpenKalman.html#a389f725d61029bd7034f2723b3bf37a2">More...</a><br /></td></tr>
<tr class="separator:a389f725d61029bd7034f2723b3bf37a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8438538fe4e22ca1adba45e0f2a9e21d"><td class="memTemplParams" colspan="2">template&lt;fixed_vector_space_descriptor FixedDescriptor, TriangleType triangle_type, covariance_nestable Arg&gt; </td></tr>
<tr class="memitem:a8438538fe4e22ca1adba45e0f2a9e21d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a8438538fe4e22ca1adba45e0f2a9e21d">requires</a> (<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;==index_dimension_of_v&lt; Arg, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(triangle_type !</td></tr>
<tr class="memdesc:a8438538fe4e22ca1adba45e0f2a9e21d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Covariance from a <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>, specifying the fixed_vector_space_descriptor.  <a href="namespaceOpenKalman.html#a8438538fe4e22ca1adba45e0f2a9e21d">More...</a><br /></td></tr>
<tr class="separator:a8438538fe4e22ca1adba45e0f2a9e21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ddde5dc21c15f822135690e0ca248b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a86ddde5dc21c15f822135690e0ca248b">requires</a> (not <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>&lt; Arg &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(triangle_type</td></tr>
<tr class="memdesc:a86ddde5dc21c15f822135690e0ca248b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a SquareRootCovariance (with nested triangular matrix) from a self-adjoint <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>.  <a href="namespaceOpenKalman.html#a86ddde5dc21c15f822135690e0ca248b">More...</a><br /></td></tr>
<tr class="separator:a86ddde5dc21c15f822135690e0ca248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7427f719088d74894a03c68f0bfdb778"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg Arg&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a7427f719088d74894a03c68f0bfdb778">requires</a> (<a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>&lt; Arg &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>&lt; Arg &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; Arg &gt; inline auto <a class="el" href="namespaceOpenKalman.html#a8482a5fd9758debdb1214b304e765525">make_covariance</a>()</td></tr>
<tr class="memdesc:a7427f719088d74894a03c68f0bfdb778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized Covariance from a <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> or <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>.  <a href="namespaceOpenKalman.html#a7427f719088d74894a03c68f0bfdb778">More...</a><br /></td></tr>
<tr class="separator:a7427f719088d74894a03c68f0bfdb778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8482a5fd9758debdb1214b304e765525"><td class="memTemplParams" colspan="2">template&lt;fixed_vector_space_descriptor FixedDescriptor, TriangleType triangle_type, typed_matrix_nestable Arg&gt; </td></tr>
<tr class="memitem:a8482a5fd9758debdb1214b304e765525"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; Arg &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a8482a5fd9758debdb1214b304e765525">make_covariance</a> ()</td></tr>
<tr class="memdesc:a8482a5fd9758debdb1214b304e765525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized Covariance with a nested triangular matrix, from a <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>.  <a href="namespaceOpenKalman.html#a8482a5fd9758debdb1214b304e765525">More...</a><br /></td></tr>
<tr class="separator:a8482a5fd9758debdb1214b304e765525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9177239a3492a45c5e2d407663429cdb"><td class="memTemplParams" colspan="2">template&lt;TriangleType triangle_type, typed_matrix_nestable Arg&gt; </td></tr>
<tr class="memitem:a9177239a3492a45c5e2d407663429cdb"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; Arg &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a9177239a3492a45c5e2d407663429cdb">make_covariance</a> ()</td></tr>
<tr class="memdesc:a9177239a3492a45c5e2d407663429cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized Covariance based on a nested triangle, with default Axis coefficients.  <a href="namespaceOpenKalman.html#a9177239a3492a45c5e2d407663429cdb">More...</a><br /></td></tr>
<tr class="separator:a9177239a3492a45c5e2d407663429cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5810b2ed52134bd24e82bf47493b8c2e"><td class="memTemplParams" colspan="2">template&lt;self_adjoint_covariance Arg&gt; </td></tr>
<tr class="memitem:a5810b2ed52134bd24e82bf47493b8c2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a5810b2ed52134bd24e82bf47493b8c2e">make_covariance</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a5810b2ed52134bd24e82bf47493b8c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Covariance based on another non-square-root <a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a>.  <a href="namespaceOpenKalman.html#a5810b2ed52134bd24e82bf47493b8c2e">More...</a><br /></td></tr>
<tr class="separator:a5810b2ed52134bd24e82bf47493b8c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab5575c973a22e0e02cb8c641e1c10c"><td class="memTemplParams" colspan="2">template&lt;self_adjoint_covariance T&gt; </td></tr>
<tr class="memitem:a6ab5575c973a22e0e02cb8c641e1c10c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a6ab5575c973a22e0e02cb8c641e1c10c">make_covariance</a> ()</td></tr>
<tr class="memdesc:a6ab5575c973a22e0e02cb8c641e1c10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized Covariance from a non-square-root <a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a>.  <a href="namespaceOpenKalman.html#a6ab5575c973a22e0e02cb8c641e1c10c">More...</a><br /></td></tr>
<tr class="separator:a6ab5575c973a22e0e02cb8c641e1c10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f78757e507c466b20ccd85294e47aea"><td class="memTemplParams" colspan="2">template&lt;typed_matrix Arg&gt; </td></tr>
<tr class="memitem:a2f78757e507c466b20ccd85294e47aea"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; Arg &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2f78757e507c466b20ccd85294e47aea">make_covariance</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a2f78757e507c466b20ccd85294e47aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Covariance from a <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>.  <a href="namespaceOpenKalman.html#a2f78757e507c466b20ccd85294e47aea">More...</a><br /></td></tr>
<tr class="separator:a2f78757e507c466b20ccd85294e47aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434176cb05fac21968ffd2d6d16813c8"><td class="memTemplParams" colspan="2">template&lt;TriangleType triangle_type, typed_matrix Arg&gt; </td></tr>
<tr class="memitem:a434176cb05fac21968ffd2d6d16813c8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a434176cb05fac21968ffd2d6d16813c8">requires</a> (triangle_type==<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba81e073b428b50247daba38531dcf412a">TriangleType::lower</a> <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> triangle_type==<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">TriangleType::upper</a>) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; Arg &gt; inline auto <a class="el" href="namespaceOpenKalman.html#a8482a5fd9758debdb1214b304e765525">make_covariance</a>(Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a434176cb05fac21968ffd2d6d16813c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Covariance, with a nested triangular matrix, from a <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>.  <a href="namespaceOpenKalman.html#a434176cb05fac21968ffd2d6d16813c8">More...</a><br /></td></tr>
<tr class="separator:a434176cb05fac21968ffd2d6d16813c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d673fd7f55bacbd8c6257a9aa29548"><td class="memTemplParams" colspan="2">template&lt;typed_matrix Arg&gt; </td></tr>
<tr class="memitem:ae9d673fd7f55bacbd8c6257a9aa29548"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; Arg &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ae9d673fd7f55bacbd8c6257a9aa29548">make_covariance</a> ()</td></tr>
<tr class="memdesc:ae9d673fd7f55bacbd8c6257a9aa29548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized Covariance, based on a <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>.  <a href="namespaceOpenKalman.html#ae9d673fd7f55bacbd8c6257a9aa29548">More...</a><br /></td></tr>
<tr class="separator:ae9d673fd7f55bacbd8c6257a9aa29548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d81b2f9af6a61cf3f9727ef17a5650b"><td class="memTemplParams" colspan="2">template&lt;covariance M, std::convertible_to&lt; scalar_type_of_t&lt; M &gt;&gt; S&gt; </td></tr>
<tr class="memitem:a4d81b2f9af6a61cf3f9727ef17a5650b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4d81b2f9af6a61cf3f9727ef17a5650b">scale</a> (M &amp;&amp;m, const S s)</td></tr>
<tr class="separator:a4d81b2f9af6a61cf3f9727ef17a5650b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8da59cacacdde8a92007912d373070"><td class="memTemplParams" colspan="2">template&lt;covariance M, std::convertible_to&lt; scalar_type_of_t&lt; M &gt;&gt; S&gt; </td></tr>
<tr class="memitem:aab8da59cacacdde8a92007912d373070"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aab8da59cacacdde8a92007912d373070">inverse_scale</a> (M &amp;&amp;m, const S s)</td></tr>
<tr class="separator:aab8da59cacacdde8a92007912d373070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097e8249617b8aad6bc0dc736f93bda1"><td class="memTemplParams" colspan="2">template&lt;covariance M, typed_matrix A&gt; </td></tr>
<tr class="memitem:a097e8249617b8aad6bc0dc736f93bda1"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; A, 0 &gt;::<a class="el" href="namespaceOpenKalman.html#a30391ef8ac72c2cbb79acee7ab1fd90f">ColumnCoefficients</a>, typename MatrixTraits&lt; std::decay_t&lt; M &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> (not <a class="el" href="namespaceOpenKalman.html#afde753e8fa98ead4323ad7f74c6e314f">euclidean_transformed</a>&lt; A &gt;) inline auto <a class="el" href="namespaceOpenKalman.html#a4d81b2f9af6a61cf3f9727ef17a5650b">scale</a>(M &amp;&amp;m</td></tr>
<tr class="memdesc:a097e8249617b8aad6bc0dc736f93bda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scale a covariance by a matrix.  <a href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">More...</a><br /></td></tr>
<tr class="separator:a097e8249617b8aad6bc0dc736f93bda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eea165f22b79ddfa5081d4019853b47"><td class="memTemplParams" colspan="2"><a id="a5eea165f22b79ddfa5081d4019853b47"></a>
template&lt;covariance M, covariance ... Ms&gt; </td></tr>
<tr class="memitem:a5eea165f22b79ddfa5081d4019853b47"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a5eea165f22b79ddfa5081d4019853b47">concatenate</a> (M &amp;&amp;m, Ms &amp;&amp;... mN)</td></tr>
<tr class="memdesc:a5eea165f22b79ddfa5081d4019853b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more Covariance or SquareRootCovariance objects diagonally. <br /></td></tr>
<tr class="separator:a5eea165f22b79ddfa5081d4019853b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee017004115da71e1bdffa5ea512b14d"><td class="memTemplParams" colspan="2"><a id="aee017004115da71e1bdffa5ea512b14d"></a>
template&lt;fixed_vector_space_descriptor ... Cs, covariance M&gt; </td></tr>
<tr class="memitem:aee017004115da71e1bdffa5ea512b14d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aee017004115da71e1bdffa5ea512b14d">split_diagonal</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:aee017004115da71e1bdffa5ea512b14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split Covariance or SquareRootCovariance diagonally. <br /></td></tr>
<tr class="separator:aee017004115da71e1bdffa5ea512b14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0cc5efe4e67accfd0e5b7901163436"><td class="memTemplParams" colspan="2"><a id="a5e0cc5efe4e67accfd0e5b7901163436"></a>
template&lt;fixed_vector_space_descriptor ... Cs, covariance M&gt; </td></tr>
<tr class="memitem:a5e0cc5efe4e67accfd0e5b7901163436"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a5e0cc5efe4e67accfd0e5b7901163436">split_vertical</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:a5e0cc5efe4e67accfd0e5b7901163436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split Covariance or SquareRootCovariance vertically. Result is a tuple of typed matrices. <br /></td></tr>
<tr class="separator:a5e0cc5efe4e67accfd0e5b7901163436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1892ba023c8f13c723b9108c15fee09"><td class="memTemplParams" colspan="2"><a id="ac1892ba023c8f13c723b9108c15fee09"></a>
template&lt;fixed_vector_space_descriptor ... Cs, covariance M&gt; </td></tr>
<tr class="memitem:ac1892ba023c8f13c723b9108c15fee09"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ac1892ba023c8f13c723b9108c15fee09">split_horizontal</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:ac1892ba023c8f13c723b9108c15fee09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split Covariance or SquareRootCovariance vertically. Result is a tuple of typed matrices. <br /></td></tr>
<tr class="separator:ac1892ba023c8f13c723b9108c15fee09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aface8ade44fd8d03a26f057539819a90"><td class="memTemplParams" colspan="2"><a id="aface8ade44fd8d03a26f057539819a90"></a>
template&lt;typed_matrix V1, typed_matrix V2&gt; </td></tr>
<tr class="memitem:aface8ade44fd8d03a26f057539819a90"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aface8ade44fd8d03a26f057539819a90">operator+</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:aface8ade44fd8d03a26f057539819a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two typed matrices. If the operands are of different types, the result will be a regular typed matrix. <br /></td></tr>
<tr class="separator:aface8ade44fd8d03a26f057539819a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52fda50e58bb81420d39ae5e54a1da0"><td class="memTemplParams" colspan="2"><a id="ad52fda50e58bb81420d39ae5e54a1da0"></a>
template&lt;typed_matrix V1, typed_matrix V2&gt; </td></tr>
<tr class="memitem:ad52fda50e58bb81420d39ae5e54a1da0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ad52fda50e58bb81420d39ae5e54a1da0">operator-</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:ad52fda50e58bb81420d39ae5e54a1da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract two typed matrices. The result is a regular typed matrix unless both operands are EuclideanMean. <br /></td></tr>
<tr class="separator:ad52fda50e58bb81420d39ae5e54a1da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07621e2c2e2e65a9f1205d45e18075cf"><td class="memTemplParams" colspan="2"><a id="a07621e2c2e2e65a9f1205d45e18075cf"></a>
template&lt;typed_matrix V, std::convertible_to&lt; const scalar_type_of_t&lt; V &gt;&gt; S&gt; </td></tr>
<tr class="memitem:a07621e2c2e2e65a9f1205d45e18075cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a07621e2c2e2e65a9f1205d45e18075cf">operator*</a> (V &amp;&amp;v, S <a class="el" href="namespaceOpenKalman.html#a4d81b2f9af6a61cf3f9727ef17a5650b">scale</a>)</td></tr>
<tr class="memdesc:a07621e2c2e2e65a9f1205d45e18075cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a typed matrix by a scalar. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:a07621e2c2e2e65a9f1205d45e18075cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcd311764513737ba16bb968ff53954"><td class="memTemplParams" colspan="2"><a id="a3fcd311764513737ba16bb968ff53954"></a>
template&lt;typed_matrix V, std::convertible_to&lt; const scalar_type_of_t&lt; V &gt;&gt; S&gt; </td></tr>
<tr class="memitem:a3fcd311764513737ba16bb968ff53954"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a3fcd311764513737ba16bb968ff53954">operator*</a> (S <a class="el" href="namespaceOpenKalman.html#a4d81b2f9af6a61cf3f9727ef17a5650b">scale</a>, V &amp;&amp;v)</td></tr>
<tr class="memdesc:a3fcd311764513737ba16bb968ff53954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a scalar by a typed matrix. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:a3fcd311764513737ba16bb968ff53954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04412e127df48343613a8ed148fab141"><td class="memTemplParams" colspan="2"><a id="a04412e127df48343613a8ed148fab141"></a>
template&lt;typed_matrix V, std::convertible_to&lt; const scalar_type_of_t&lt; V &gt;&gt; S&gt; </td></tr>
<tr class="memitem:a04412e127df48343613a8ed148fab141"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a04412e127df48343613a8ed148fab141">operator/</a> (V &amp;&amp;v, S <a class="el" href="namespaceOpenKalman.html#a4d81b2f9af6a61cf3f9727ef17a5650b">scale</a>)</td></tr>
<tr class="memdesc:a04412e127df48343613a8ed148fab141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a typed matrix by a scalar. The result type is the same as the operand type, so angles in the result may be wrapped. <br /></td></tr>
<tr class="separator:a04412e127df48343613a8ed148fab141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08967fa3558c594e90b28c9a7e09921a"><td class="memTemplParams" colspan="2"><a id="a08967fa3558c594e90b28c9a7e09921a"></a>
template&lt;typed_matrix V1, typed_matrix V2&gt; </td></tr>
<tr class="memitem:a08967fa3558c594e90b28c9a7e09921a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a08967fa3558c594e90b28c9a7e09921a">operator*</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a08967fa3558c594e90b28c9a7e09921a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a typed matrix by another typed matrix. The result is a regular typed matrix unless the first operand is EuclideanMean. <br /></td></tr>
<tr class="separator:a08967fa3558c594e90b28c9a7e09921a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b2dd6c56714fcf74899d9f8b9fd9a5"><td class="memTemplParams" colspan="2"><a id="a66b2dd6c56714fcf74899d9f8b9fd9a5"></a>
template&lt;typed_matrix V&gt; </td></tr>
<tr class="memitem:a66b2dd6c56714fcf74899d9f8b9fd9a5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a66b2dd6c56714fcf74899d9f8b9fd9a5">operator-</a> (V &amp;&amp;v)</td></tr>
<tr class="memdesc:a66b2dd6c56714fcf74899d9f8b9fd9a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negate a vector object. The result is a regular typed matrix unless the operand is EuclideanMean. <br /></td></tr>
<tr class="separator:a66b2dd6c56714fcf74899d9f8b9fd9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c0095b2a2e570fec9bc6948405a954"><td class="memTemplParams" colspan="2"><a id="a59c0095b2a2e570fec9bc6948405a954"></a>
template&lt;typed_matrix V1, typed_matrix V2&gt; </td></tr>
<tr class="memitem:a59c0095b2a2e570fec9bc6948405a954"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a59c0095b2a2e570fec9bc6948405a954">operator==</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a59c0095b2a2e570fec9bc6948405a954"><td class="mdescLeft">&#160;</td><td class="mdescRight">typed_matrix == typed_matrix. <br /></td></tr>
<tr class="separator:a59c0095b2a2e570fec9bc6948405a954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa558386f94e2b8d97a220799ea024f32"><td class="memTemplParams" colspan="2"><a id="aa558386f94e2b8d97a220799ea024f32"></a>
template&lt;typed_matrix V1, typed_matrix V2&gt; </td></tr>
<tr class="memitem:aa558386f94e2b8d97a220799ea024f32"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aa558386f94e2b8d97a220799ea024f32">operator!=</a> (V1 &amp;&amp;v1, V2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:aa558386f94e2b8d97a220799ea024f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">typed_matrix != typed_matrix. <br /></td></tr>
<tr class="separator:aa558386f94e2b8d97a220799ea024f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79f99eb35747cf1389a13ca1626459e"><td class="memTemplParams" colspan="2">template&lt;typed_matrix V, typed_matrix ... Vs&gt; </td></tr>
<tr class="memitem:ae79f99eb35747cf1389a13ca1626459e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ae79f99eb35747cf1389a13ca1626459e">requires</a> (sizeof...(Vs)==0) <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a>(<a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; V</td></tr>
<tr class="memdesc:ae79f99eb35747cf1389a13ca1626459e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more typed matrices objects vertically.  <a href="namespaceOpenKalman.html#ae79f99eb35747cf1389a13ca1626459e">More...</a><br /></td></tr>
<tr class="separator:ae79f99eb35747cf1389a13ca1626459e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b42af84cbf66cf2f695a3e011cceea4"><td class="memTemplParams" colspan="2"><a id="a1b42af84cbf66cf2f695a3e011cceea4"></a>
template&lt;typed_matrix ... Vs&gt; </td></tr>
<tr class="memitem:a1b42af84cbf66cf2f695a3e011cceea4"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a1b42af84cbf66cf2f695a3e011cceea4">concatenate</a> (Vs &amp;&amp;... vs)</td></tr>
<tr class="memdesc:a1b42af84cbf66cf2f695a3e011cceea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more typed matrices vertically. (Synonym for concatenate_vertical.) <br /></td></tr>
<tr class="separator:a1b42af84cbf66cf2f695a3e011cceea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc48f3346d0af309e980a22f7452b0a"><td class="memTemplParams" colspan="2"><a id="a1fc48f3346d0af309e980a22f7452b0a"></a>
template&lt;typed_matrix V, typed_matrix ... Vs&gt; </td></tr>
<tr class="memitem:a1fc48f3346d0af309e980a22f7452b0a"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a1fc48f3346d0af309e980a22f7452b0a">concatenate_diagonal</a> (V &amp;&amp;v, Vs &amp;&amp;... vs)</td></tr>
<tr class="memdesc:a1fc48f3346d0af309e980a22f7452b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate one or more typed matrices diagonally. <br /></td></tr>
<tr class="separator:a1fc48f3346d0af309e980a22f7452b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d74b4c70d45259527e6ab8506740376"><td class="memTemplParams" colspan="2"><a id="a7d74b4c70d45259527e6ab8506740376"></a>
template&lt;fixed_vector_space_descriptor ... Cs, typed_matrix M&gt; </td></tr>
<tr class="memitem:a7d74b4c70d45259527e6ab8506740376"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman_1_1internal.html#a601527fae38b2760d48bb409307dcd88">internal::prefix_of</a>&lt; <a class="el" href="namespaceOpenKalman.html#a551efec16eae409b3b9c6ecaf7c06b34">concatenate_fixed_vector_space_descriptor_t</a>&lt; Cs... &gt;, <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; M, 0 &gt; &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a7d74b4c70d45259527e6ab8506740376">split_vertical</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:a7d74b4c70d45259527e6ab8506740376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split typed matrix into one or more typed matrices vertically. <br /></td></tr>
<tr class="separator:a7d74b4c70d45259527e6ab8506740376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789e9258baaa43a948fbe76d81dece6d"><td class="memTemplParams" colspan="2"><a id="a789e9258baaa43a948fbe76d81dece6d"></a>
template&lt;fixed_vector_space_descriptor ... Cs, typed_matrix M&gt; </td></tr>
<tr class="memitem:a789e9258baaa43a948fbe76d81dece6d"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman_1_1internal.html#a601527fae38b2760d48bb409307dcd88">internal::prefix_of</a>&lt; <a class="el" href="namespaceOpenKalman.html#a551efec16eae409b3b9c6ecaf7c06b34">concatenate_fixed_vector_space_descriptor_t</a>&lt; Cs... &gt;, <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; M, 1 &gt; &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a789e9258baaa43a948fbe76d81dece6d">split_horizontal</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:a789e9258baaa43a948fbe76d81dece6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split typed matrix into one or more typed matrices horizontally. <br /></td></tr>
<tr class="separator:a789e9258baaa43a948fbe76d81dece6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516290263e96f615075c77d680bc02d2"><td class="memTemplParams" colspan="2"><a id="a516290263e96f615075c77d680bc02d2"></a>
template&lt;std::size_t ... cuts, typed_matrix M&gt; </td></tr>
<tr class="memitem:a516290263e96f615075c77d680bc02d2"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt; M, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a516290263e96f615075c77d680bc02d2">and</a> (sizeof...(cuts) &gt; 0) and((...+cuts)&lt;</td></tr>
<tr class="memdesc:a516290263e96f615075c77d680bc02d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split typed matrix into one or more typed matrices horizontally. Column coefficients must all be Axis. <br /></td></tr>
<tr class="separator:a516290263e96f615075c77d680bc02d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351595a30d9cc8f3f9623dcb7c74b26a"><td class="memTemplParams" colspan="2">template&lt;typed_matrix ReturnType, std::uniform_random_bit_generator random_number_engine = std::mt19937, typename... Dists&gt; </td></tr>
<tr class="memitem:a351595a30d9cc8f3f9623dcb7c74b26a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a351595a30d9cc8f3f9623dcb7c74b26a">requires</a> (not <a class="el" href="namespaceOpenKalman.html#a2df14967a1282177068bd8aaff491e65">has_dynamic_dimensions</a>&lt; ReturnType &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(sizeof...(Dists) &gt; 0) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(((requires</td></tr>
<tr class="memdesc:a351595a30d9cc8f3f9623dcb7c74b26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a fixed-shape typed matrix with random values selected from a random distribution.  <a href="namespaceOpenKalman.html#a351595a30d9cc8f3f9623dcb7c74b26a">More...</a><br /></td></tr>
<tr class="separator:a351595a30d9cc8f3f9623dcb7c74b26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b1bd52d0ef0d4b15dcadb66b67297f"><td class="memTemplParams" colspan="2"><a id="a76b1bd52d0ef0d4b15dcadb66b67297f"></a>
template&lt;typed_matrix V&gt; </td></tr>
<tr class="memitem:a76b1bd52d0ef0d4b15dcadb66b67297f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a76b1bd52d0ef0d4b15dcadb66b67297f">operator&lt;&lt;</a> (std::ostream &amp;os, const V &amp;v)</td></tr>
<tr class="memdesc:a76b1bd52d0ef0d4b15dcadb66b67297f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the vector to a stream. <br /></td></tr>
<tr class="separator:a76b1bd52d0ef0d4b15dcadb66b67297f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689b926c307aee8a9b8c177b1c7a389f"><td class="memTemplParams" colspan="2">template&lt;vector&lt; 0, Qualification::depends_on_dynamic_shape &gt; Arg&gt; </td></tr>
<tr class="memitem:a689b926c307aee8a9b8c177b1c7a389f"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a>&lt; Arg &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> (not <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>&lt; Arg &gt;) explicit <a class="el" href="structOpenKalman_1_1DiagonalMatrix.html">DiagonalMatrix</a>(Arg &amp;&amp;) -&gt; <a class="el" href="structOpenKalman_1_1DiagonalMatrix.html">DiagonalMatrix</a>&lt; passable_t&lt; Arg &gt;&gt;</td></tr>
<tr class="memdesc:a689b926c307aee8a9b8c177b1c7a389f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce <a class="el" href="structOpenKalman_1_1DiagonalMatrix.html" title="A diagonal matrix or tensor.">DiagonalMatrix</a> template parameters for a column vector.  <a href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">More...</a><br /></td></tr>
<tr class="separator:a689b926c307aee8a9b8c177b1c7a389f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013d327a3160b745be215edbae838908"><td class="memTemplParams" colspan="2">template&lt;square_shaped&lt; Qualification::depends_on_dynamic_shape &gt; Arg&gt; </td></tr>
<tr class="memitem:a013d327a3160b745be215edbae838908"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a013d327a3160b745be215edbae838908">requires</a> (index_count_v&lt; Arg &gt;==<a class="el" href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">dynamic_size</a> <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> index_count_v&lt; Arg &gt;&lt;=2) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not <a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a>&lt; Arg</td></tr>
<tr class="memdesc:a013d327a3160b745be215edbae838908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce <a class="el" href="structOpenKalman_1_1DiagonalMatrix.html" title="A diagonal matrix or tensor.">DiagonalMatrix</a> template parameters for a square matrix.  <a href="namespaceOpenKalman.html#a013d327a3160b745be215edbae838908">More...</a><br /></td></tr>
<tr class="separator:a013d327a3160b745be215edbae838908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2181d7f80e34010bd192b9b239722b62"><td class="memTemplParams" colspan="2"><a id="a2181d7f80e34010bd192b9b239722b62"></a>
template&lt;typed_matrix V&gt; </td></tr>
<tr class="memitem:a2181d7f80e34010bd192b9b239722b62"><td class="memTemplItemLeft" align="right" valign="top">requires(<a class="el" href="namespaceOpenKalman.html#a399b0547d1b74a66dd68157b927b3e5d">euclidean_dimension_size_of_v</a>&lt; RowCoefficients &gt;==index_dimension_of_v&lt; NestedMatrix, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not std&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2181d7f80e34010bd192b9b239722b62">requires</a> (not <a class="el" href="namespaceOpenKalman.html#afde753e8fa98ead4323ad7f74c6e314f">euclidean_transformed</a>&lt; V &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt; V</td></tr>
<tr class="memdesc:a2181d7f80e34010bd192b9b239722b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a non-Euclidean-transformed typed matrix. <br /></td></tr>
<tr class="separator:a2181d7f80e34010bd192b9b239722b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddc3d4101bf4f5e66a21a3b52cca3cb"><td class="memTemplParams" colspan="2">template&lt;euclidean_transformed V&gt; </td></tr>
<tr class="memitem:a0ddc3d4101bf4f5e66a21a3b52cca3cb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0ddc3d4101bf4f5e66a21a3b52cca3cb">EuclideanMean</a> (V &amp;&amp;) -&gt; EuclideanMean&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; V, 0 &gt;, <a class="el" href="namespaceOpenKalman.html#a03b16f3264522ab5b6be8215b82b7e9d">nested_object_of_t</a>&lt; V &gt;&gt;</td></tr>
<tr class="memdesc:a0ddc3d4101bf4f5e66a21a3b52cca3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a Euclidean-transformed typed matrix.  <a href="namespaceOpenKalman.html#a0ddc3d4101bf4f5e66a21a3b52cca3cb">More...</a><br /></td></tr>
<tr class="separator:a0ddc3d4101bf4f5e66a21a3b52cca3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259728001228946002a0af7de1d0d3ff"><td class="memTemplParams" colspan="2">template&lt;fixed_vector_space_descriptor FixedDescriptor, typed_matrix_nestable M&gt; </td></tr>
<tr class="memitem:a259728001228946002a0af7de1d0d3ff"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a259728001228946002a0af7de1d0d3ff">requires</a> (<a class="el" href="namespaceOpenKalman.html#a399b0547d1b74a66dd68157b927b3e5d">euclidean_dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;==index_dimension_of_v&lt; M, 0 &gt;) auto <a class="el" href="namespaceOpenKalman.html#ae2874fe45e525be71f2256270fedb857">make_euclidean_mean</a>(M &amp;&amp;arg)</td></tr>
<tr class="memdesc:a259728001228946002a0af7de1d0d3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a EuclideanMean from a typed_matrix_nestable, specifying the row coefficients.  <a href="namespaceOpenKalman.html#a259728001228946002a0af7de1d0d3ff">More...</a><br /></td></tr>
<tr class="separator:a259728001228946002a0af7de1d0d3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2874fe45e525be71f2256270fedb857"><td class="memTemplParams" colspan="2">template&lt;typed_matrix_nestable M&gt; </td></tr>
<tr class="memitem:ae2874fe45e525be71f2256270fedb857"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ae2874fe45e525be71f2256270fedb857">make_euclidean_mean</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:ae2874fe45e525be71f2256270fedb857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a EuclideanMean from a typed_matrix_nestable object, with default Axis coefficients.  <a href="namespaceOpenKalman.html#ae2874fe45e525be71f2256270fedb857">More...</a><br /></td></tr>
<tr class="separator:ae2874fe45e525be71f2256270fedb857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d746240ab12ed086adb0da881876812"><td class="memTemplParams" colspan="2">template&lt;typed_matrix Arg&gt; </td></tr>
<tr class="memitem:a4d746240ab12ed086adb0da881876812"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt; Arg, 1 &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4d746240ab12ed086adb0da881876812">make_euclidean_mean</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a4d746240ab12ed086adb0da881876812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a EuclideanMean from another typed_matrix.  <a href="namespaceOpenKalman.html#a4d746240ab12ed086adb0da881876812">More...</a><br /></td></tr>
<tr class="separator:a4d746240ab12ed086adb0da881876812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95e245ac127ab6485c5620d73bdcc45"><td class="memTemplParams" colspan="2">template&lt;fixed_vector_space_descriptor FixedDescriptor, typed_matrix_nestable M&gt; </td></tr>
<tr class="memitem:ac95e245ac127ab6485c5620d73bdcc45"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ac95e245ac127ab6485c5620d73bdcc45">requires</a> (<a class="el" href="namespaceOpenKalman.html#a399b0547d1b74a66dd68157b927b3e5d">euclidean_dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;==index_dimension_of_v&lt; M, 0 &gt;) auto <a class="el" href="namespaceOpenKalman.html#ae2874fe45e525be71f2256270fedb857">make_euclidean_mean</a>()</td></tr>
<tr class="memdesc:ac95e245ac127ab6485c5620d73bdcc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, self-contained EuclideanMean.  <a href="namespaceOpenKalman.html#ac95e245ac127ab6485c5620d73bdcc45">More...</a><br /></td></tr>
<tr class="separator:ac95e245ac127ab6485c5620d73bdcc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756493b5adefecfb121d7dc3b7b4132e"><td class="memTemplParams" colspan="2">template&lt;typed_matrix_nestable M&gt; </td></tr>
<tr class="memitem:a756493b5adefecfb121d7dc3b7b4132e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a756493b5adefecfb121d7dc3b7b4132e">make_euclidean_mean</a> ()</td></tr>
<tr class="memdesc:a756493b5adefecfb121d7dc3b7b4132e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a self-contained EuclideanMean with default Axis coefficients.  <a href="namespaceOpenKalman.html#a756493b5adefecfb121d7dc3b7b4132e">More...</a><br /></td></tr>
<tr class="separator:a756493b5adefecfb121d7dc3b7b4132e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfc60abb9ea187ae2a341af555a26ab"><td class="memTemplParams" colspan="2">template&lt;fixed_vector_space_descriptor RowCoefficients, fixed_vector_space_descriptor ColumnCoefficients, typed_matrix_nestable NestedMatrix&gt; </td></tr>
<tr class="memitem:a1bfc60abb9ea187ae2a341af555a26ab"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a1bfc60abb9ea187ae2a341af555a26ab">requires</a> (<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; RowCoefficients &gt;==index_dimension_of_v&lt; NestedMatrix, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; <a class="el" href="namespaceOpenKalman.html#a30391ef8ac72c2cbb79acee7ab1fd90f">ColumnCoefficients</a> &gt;</td></tr>
<tr class="memdesc:a1bfc60abb9ea187ae2a341af555a26ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix with typed rows and columns.  <a href="namespaceOpenKalman.html#a1bfc60abb9ea187ae2a341af555a26ab">More...</a><br /></td></tr>
<tr class="separator:a1bfc60abb9ea187ae2a341af555a26ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f5fb2d477539a5a7ab9a641c532c24"><td class="memTemplParams" colspan="2"><a id="a11f5fb2d477539a5a7ab9a641c532c24"></a>
template&lt;typed_matrix Arg&gt; </td></tr>
<tr class="memitem:a11f5fb2d477539a5a7ab9a641c532c24"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a11f5fb2d477539a5a7ab9a641c532c24">requires</a> (not std::derived_from&lt; std::decay_t&lt; Arg &gt;, Matrix &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not <a class="el" href="namespaceOpenKalman.html#afde753e8fa98ead4323ad7f74c6e314f">euclidean_transformed</a>&lt; Arg &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg</td></tr>
<tr class="memdesc:a11f5fb2d477539a5a7ab9a641c532c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a compatible <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>. <br /></td></tr>
<tr class="separator:a11f5fb2d477539a5a7ab9a641c532c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adaadbd57890165152606ba6ac415c2"><td class="memTemplParams" colspan="2"><a id="a4adaadbd57890165152606ba6ac415c2"></a>
template&lt;euclidean_transformed Arg&gt; </td></tr>
<tr class="memitem:a4adaadbd57890165152606ba6ac415c2"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 0 &gt;, RowCoefficients &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 1 &gt;, <a class="el" href="namespaceOpenKalman.html#a30391ef8ac72c2cbb79acee7ab1fd90f">ColumnCoefficients</a> &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4adaadbd57890165152606ba6ac415c2">requires</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a4adaadbd57890165152606ba6ac415c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a compatible <a class="el" href="namespaceOpenKalman.html#afde753e8fa98ead4323ad7f74c6e314f">euclidean_transformed</a>. <br /></td></tr>
<tr class="separator:a4adaadbd57890165152606ba6ac415c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae084f6f7ea6e2dc171b54a8885093950"><td class="memTemplParams" colspan="2"><a id="ae084f6f7ea6e2dc171b54a8885093950"></a>
template&lt;typed_matrix_nestable Arg&gt; </td></tr>
<tr class="memitem:ae084f6f7ea6e2dc171b54a8885093950"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ae084f6f7ea6e2dc171b54a8885093950">requires</a> (index_dimension_of_v&lt; Arg, 0 &gt;==index_dimension_of_v&lt; NestedMatrix, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(index_dimension_of_v&lt; Arg</td></tr>
<tr class="memdesc:ae084f6f7ea6e2dc171b54a8885093950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from compatible <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>. <br /></td></tr>
<tr class="separator:ae084f6f7ea6e2dc171b54a8885093950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c9229739c7cd95b330dc13c8e928dc"><td class="memTemplParams" colspan="2"><a id="ab3c9229739c7cd95b330dc13c8e928dc"></a>
template&lt;covariance Arg&gt; </td></tr>
<tr class="memitem:ab3c9229739c7cd95b330dc13c8e928dc"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 0 &gt;, RowCoefficients &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 0 &gt;, <a class="el" href="namespaceOpenKalman.html#a30391ef8ac72c2cbb79acee7ab1fd90f">ColumnCoefficients</a> &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ab3c9229739c7cd95b330dc13c8e928dc">requires</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:ab3c9229739c7cd95b330dc13c8e928dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from compatible <a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a>. <br /></td></tr>
<tr class="separator:ab3c9229739c7cd95b330dc13c8e928dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44f39080f92a156d6946f71270c2a9e"><td class="memTemplParams" colspan="2"><a id="aa44f39080f92a156d6946f71270c2a9e"></a>
template&lt;typed_matrix Arg&gt; </td></tr>
<tr class="memitem:aa44f39080f92a156d6946f71270c2a9e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aa44f39080f92a156d6946f71270c2a9e">requires</a> (not <a class="el" href="namespaceOpenKalman.html#afde753e8fa98ead4323ad7f74c6e314f">euclidean_transformed</a>&lt; Arg &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not std</td></tr>
<tr class="memdesc:aa44f39080f92a156d6946f71270c2a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from a compatible <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>. <br /></td></tr>
<tr class="separator:aa44f39080f92a156d6946f71270c2a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b48e9a9a40a95b86bc572793185b59"><td class="memTemplParams" colspan="2"><a id="ad2b48e9a9a40a95b86bc572793185b59"></a>
template&lt;euclidean_transformed Arg&gt; </td></tr>
<tr class="memitem:ad2b48e9a9a40a95b86bc572793185b59"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 0 &gt;, RowCoefficients &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 1 &gt;, <a class="el" href="namespaceOpenKalman.html#a30391ef8ac72c2cbb79acee7ab1fd90f">ColumnCoefficients</a> &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> std::assignable_from&lt; std::add_lvalue_reference_t&lt; NestedMatrix &gt;, decltype(from_euclidean&lt; RowCoefficients &gt;std::declval&lt; <a class="el" href="namespaceOpenKalman.html#a03b16f3264522ab5b6be8215b82b7e9d">nested_object_of_t</a>&lt; Arg &gt;&gt;()))&gt; auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ad2b48e9a9a40a95b86bc572793185b59">operator=</a> (Arg &amp;&amp;other)</td></tr>
<tr class="memdesc:ad2b48e9a9a40a95b86bc572793185b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from a compatible <a class="el" href="namespaceOpenKalman.html#afde753e8fa98ead4323ad7f74c6e314f">euclidean_transformed</a> matrix. <br /></td></tr>
<tr class="separator:ad2b48e9a9a40a95b86bc572793185b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4633bbb3cb51a534959f2e8afe05c092"><td class="memTemplParams" colspan="2"><a id="a4633bbb3cb51a534959f2e8afe05c092"></a>
template&lt;typed_matrix_nestable Arg&gt; </td></tr>
<tr class="memitem:a4633bbb3cb51a534959f2e8afe05c092"><td class="memTemplItemLeft" align="right" valign="top">requires std::assignable_from&lt; std::add_lvalue_reference_t&lt; NestedMatrix &gt;, Arg &amp;&amp; &gt; auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4633bbb3cb51a534959f2e8afe05c092">operator=</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a4633bbb3cb51a534959f2e8afe05c092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign from a compatible <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>. <br /></td></tr>
<tr class="separator:a4633bbb3cb51a534959f2e8afe05c092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbeb189803410846021face177f60b58"><td class="memItemLeft" align="right" valign="top"><a id="adbeb189803410846021face177f60b58"></a>
auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#adbeb189803410846021face177f60b58">operator+=</a> (const Matrix &amp;other)</td></tr>
<tr class="memdesc:adbeb189803410846021face177f60b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment from another Matrix. <br /></td></tr>
<tr class="separator:adbeb189803410846021face177f60b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6850a50179f98cc3b73b05568a45cbe0"><td class="memTemplParams" colspan="2"><a id="a6850a50179f98cc3b73b05568a45cbe0"></a>
template&lt;typed_matrix Arg&gt; </td></tr>
<tr class="memitem:a6850a50179f98cc3b73b05568a45cbe0"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 0 &gt;, RowCoefficients &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 1 &gt;, <a class="el" href="namespaceOpenKalman.html#a30391ef8ac72c2cbb79acee7ab1fd90f">ColumnCoefficients</a> &gt; auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a6850a50179f98cc3b73b05568a45cbe0">operator+=</a> (Arg &amp;&amp;other)</td></tr>
<tr class="memdesc:a6850a50179f98cc3b73b05568a45cbe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment from another typed matrix. <br /></td></tr>
<tr class="separator:a6850a50179f98cc3b73b05568a45cbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ac94f121a52f7fe8274cbea98a020d"><td class="memTemplParams" colspan="2">template&lt;distribution Arg&gt; </td></tr>
<tr class="memitem:ad7ac94f121a52f7fe8274cbea98a020d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ad7ac94f121a52f7fe8274cbea98a020d">requires</a> (<a class="el" href="namespaceOpenKalman.html#a4a4a660c145525d68a44fad81f52d1b9">euclidean_vector_space_descriptor</a>&lt; <a class="el" href="namespaceOpenKalman.html#a30391ef8ac72c2cbb79acee7ab1fd90f">ColumnCoefficients</a> &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(<a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; typename DistributionTraits&lt; Arg &gt;</td></tr>
<tr class="memdesc:ad7ac94f121a52f7fe8274cbea98a020d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a stochastic value to each column of the matrix, based on a distribution.  <a href="namespaceOpenKalman.html#ad7ac94f121a52f7fe8274cbea98a020d">More...</a><br /></td></tr>
<tr class="separator:ad7ac94f121a52f7fe8274cbea98a020d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54261350372576915cbb4f820685e092"><td class="memItemLeft" align="right" valign="top"><a id="a54261350372576915cbb4f820685e092"></a>
auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a54261350372576915cbb4f820685e092">operator-=</a> (const Matrix &amp;other)</td></tr>
<tr class="memdesc:a54261350372576915cbb4f820685e092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement from another Matrix. <br /></td></tr>
<tr class="separator:a54261350372576915cbb4f820685e092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af817aba27d6444d83f12b26776060f8c"><td class="memTemplParams" colspan="2"><a id="af817aba27d6444d83f12b26776060f8c"></a>
template&lt;typed_matrix Arg&gt; </td></tr>
<tr class="memitem:af817aba27d6444d83f12b26776060f8c"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 0 &gt;, RowCoefficients &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 1 &gt;, <a class="el" href="namespaceOpenKalman.html#a30391ef8ac72c2cbb79acee7ab1fd90f">ColumnCoefficients</a> &gt; auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#af817aba27d6444d83f12b26776060f8c">operator-=</a> (Arg &amp;&amp;other)</td></tr>
<tr class="memdesc:af817aba27d6444d83f12b26776060f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement from another typed matrix. <br /></td></tr>
<tr class="separator:af817aba27d6444d83f12b26776060f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ce51f24958dff5bdd6adcdf5390e1a"><td class="memTemplParams" colspan="2">template&lt;typed_matrix_nestable V&gt; </td></tr>
<tr class="memitem:a13ce51f24958dff5bdd6adcdf5390e1a"><td class="memTemplItemLeft" align="right" valign="top">requires(<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; RowCoefficients &gt;==index_dimension_of_v&lt; NestedMatrix, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not std&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a13ce51f24958dff5bdd6adcdf5390e1a">Mean</a> (V &amp;&amp;) -&gt; Mean&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1Dimensions.html">Dimensions</a>&lt; index_dimension_of_v&lt; V, 0 &gt;&gt;, passable_t&lt; V &gt;&gt;</td></tr>
<tr class="memdesc:a13ce51f24958dff5bdd6adcdf5390e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typed vector.  <a href="namespaceOpenKalman.html#a13ce51f24958dff5bdd6adcdf5390e1a">More...</a><br /></td></tr>
<tr class="separator:a13ce51f24958dff5bdd6adcdf5390e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb4e6f83fc6b853bda02c0f143c68ce"><td class="memTemplParams" colspan="2"><a id="aafb4e6f83fc6b853bda02c0f143c68ce"></a>
template&lt;euclidean_transformed V&gt; </td></tr>
<tr class="memitem:aafb4e6f83fc6b853bda02c0f143c68ce"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aafb4e6f83fc6b853bda02c0f143c68ce">Mean</a> (V &amp;&amp;) -&gt; Mean&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; V, 0 &gt;, std::decay_t&lt; decltype(from_euclidean&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; V, 0 &gt;&gt;(<a class="el" href="namespaceOpenKalman.html#a09023dc82cbe71e465ac32184fd325c3">nested_object</a>(std::forward&lt; V &gt;(std::declval&lt; V &gt;()))))&gt;&gt;</td></tr>
<tr class="memdesc:aafb4e6f83fc6b853bda02c0f143c68ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce template parameters from a Euclidean-transformed typed matrix. <br /></td></tr>
<tr class="separator:aafb4e6f83fc6b853bda02c0f143c68ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07b02c4880d0e72ef0e96b05624fb48"><td class="memTemplParams" colspan="2">template&lt;typed_matrix_nestable M&gt; </td></tr>
<tr class="memitem:aa07b02c4880d0e72ef0e96b05624fb48"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aa07b02c4880d0e72ef0e96b05624fb48">make_mean</a> (M &amp;&amp;m)</td></tr>
<tr class="memdesc:aa07b02c4880d0e72ef0e96b05624fb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Mean from a typed_matrix_nestable object, with default Axis fixed_vector_space_descriptor.  <a href="namespaceOpenKalman.html#aa07b02c4880d0e72ef0e96b05624fb48">More...</a><br /></td></tr>
<tr class="separator:aa07b02c4880d0e72ef0e96b05624fb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ac38809e1f1fcee2f556ffde613c51"><td class="memTemplParams" colspan="2">template&lt;typed_matrix Arg&gt; </td></tr>
<tr class="memitem:ac6ac38809e1f1fcee2f556ffde613c51"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt; Arg, 1 &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ac6ac38809e1f1fcee2f556ffde613c51">make_mean</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:ac6ac38809e1f1fcee2f556ffde613c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Mean from another typed_matrix.  <a href="namespaceOpenKalman.html#ac6ac38809e1f1fcee2f556ffde613c51">More...</a><br /></td></tr>
<tr class="separator:ac6ac38809e1f1fcee2f556ffde613c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0856fb135cd5d4752d11f89768c76e"><td class="memTemplParams" colspan="2">template&lt;fixed_vector_space_descriptor FixedDescriptor, typed_matrix_nestable M&gt; </td></tr>
<tr class="memitem:adb0856fb135cd5d4752d11f89768c76e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#adb0856fb135cd5d4752d11f89768c76e">requires</a> (index_dimension_of_v&lt; M, 0 &gt;==<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;) inline auto <a class="el" href="namespaceOpenKalman.html#aa07b02c4880d0e72ef0e96b05624fb48">make_mean</a>()</td></tr>
<tr class="memdesc:adb0856fb135cd5d4752d11f89768c76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, self-contained Mean.  <a href="namespaceOpenKalman.html#adb0856fb135cd5d4752d11f89768c76e">More...</a><br /></td></tr>
<tr class="separator:adb0856fb135cd5d4752d11f89768c76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b34fbabbe7b5ab3293412cf4bd24d80"><td class="memTemplParams" colspan="2">template&lt;typed_matrix_nestable M&gt; </td></tr>
<tr class="memitem:a5b34fbabbe7b5ab3293412cf4bd24d80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a5b34fbabbe7b5ab3293412cf4bd24d80">make_mean</a> ()</td></tr>
<tr class="memdesc:a5b34fbabbe7b5ab3293412cf4bd24d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a self-contained Mean with default Axis fixed_vector_space_descriptor.  <a href="namespaceOpenKalman.html#a5b34fbabbe7b5ab3293412cf4bd24d80">More...</a><br /></td></tr>
<tr class="separator:a5b34fbabbe7b5ab3293412cf4bd24d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb49017fa9becb89a9c9f1f1eeb6cfe4"><td class="memTemplParams" colspan="2">template&lt;square_shaped&lt; Qualification::depends_on_dynamic_shape &gt; NestedMatrix, HermitianAdapterType storage_triangle&gt; </td></tr>
<tr class="memitem:aeb49017fa9becb89a9c9f1f1eeb6cfe4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aeb49017fa9becb89a9c9f1f1eeb6cfe4">requires</a> (index_count_v&lt; NestedMatrix &gt;&lt;=2) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(storage_triangle</td></tr>
<tr class="memdesc:aeb49017fa9becb89a9c9f1f1eeb6cfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hermitian matrix wrapper.  <a href="namespaceOpenKalman.html#aeb49017fa9becb89a9c9f1f1eeb6cfe4">More...</a><br /></td></tr>
<tr class="separator:aeb49017fa9becb89a9c9f1f1eeb6cfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f4a7708985c78ea8155a7e2dc9905c"><td class="memItemLeft" align="right" valign="top"><a id="af0f4a7708985c78ea8155a7e2dc9905c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#af0f4a7708985c78ea8155a7e2dc9905c">SelfAdjointMatrix</a> () requires std</td></tr>
<tr class="memdesc:af0f4a7708985c78ea8155a7e2dc9905c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:af0f4a7708985c78ea8155a7e2dc9905c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf91ff0c7bf6c4b4465a0522bda93604"><td class="memTemplParams" colspan="2">template&lt;diagonal_matrix Arg&gt; </td></tr>
<tr class="memitem:abf91ff0c7bf6c4b4465a0522bda93604"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#abf91ff0c7bf6c4b4465a0522bda93604">requires</a> (not std::is_base_of_v&lt; <a class="el" href="namespaceOpenKalman.html#af0f4a7708985c78ea8155a7e2dc9905c">SelfAdjointMatrix</a>, std::decay_t&lt; Arg &gt;&gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>&lt; NestedMatrix &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a71866768ca1d2b98352a34f58eac26a4">vector_space_descriptors_may_match_with</a>&lt; Arg</td></tr>
<tr class="memdesc:abf91ff0c7bf6c4b4465a0522bda93604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a diagonal matrix if NestedMatrix is diagonal.  <a href="namespaceOpenKalman.html#abf91ff0c7bf6c4b4465a0522bda93604">More...</a><br /></td></tr>
<tr class="separator:abf91ff0c7bf6c4b4465a0522bda93604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac0e861c6cb4741b625dec725470c80"><td class="memTemplParams" colspan="2"><a id="a0ac0e861c6cb4741b625dec725470c80"></a>
template&lt;diagonal_matrix Arg&gt; </td></tr>
<tr class="memitem:a0ac0e861c6cb4741b625dec725470c80"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0ac0e861c6cb4741b625dec725470c80">requires</a> (not std::is_base_of_v&lt; <a class="el" href="namespaceOpenKalman.html#af0f4a7708985c78ea8155a7e2dc9905c">SelfAdjointMatrix</a>, std::decay_t&lt; Arg &gt;&gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>&lt; NestedMatrix &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not requires(Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a0ac0e861c6cb4741b625dec725470c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a diagonal matrix if NestedMatrix is not diagonal. <br /></td></tr>
<tr class="separator:a0ac0e861c6cb4741b625dec725470c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfe18f8569a2d34da92c5d348c5d6bf"><td class="memTemplParams" colspan="2">template&lt;hermitian_adapter Arg&gt; </td></tr>
<tr class="memitem:a8bfe18f8569a2d34da92c5d348c5d6bf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a8bfe18f8569a2d34da92c5d348c5d6bf">requires</a> (not <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>&lt; Arg &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(<a class="el" href="structOpenKalman_1_1hermitian__adapter__type__of.html">hermitian_adapter_type_of</a>&lt; Arg &gt;</td></tr>
<tr class="memdesc:a8bfe18f8569a2d34da92c5d348c5d6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a hermitian, non-diagonal wrapper of the opposite storage type.  <a href="namespaceOpenKalman.html#a8bfe18f8569a2d34da92c5d348c5d6bf">More...</a><br /></td></tr>
<tr class="separator:a8bfe18f8569a2d34da92c5d348c5d6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7ed7d9e2ba20d5c636be2a4b56c293"><td class="memTemplParams" colspan="2"><a id="aea7ed7d9e2ba20d5c636be2a4b56c293"></a>
template&lt;square_shaped&lt; Qualification::depends_on_dynamic_shape &gt; Arg&gt; </td></tr>
<tr class="memitem:aea7ed7d9e2ba20d5c636be2a4b56c293"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aea7ed7d9e2ba20d5c636be2a4b56c293">requires</a> (not <a class="el" href="namespaceOpenKalman.html#af8566a3ec777d7c9fa78b59da320a037">hermitian_adapter</a>&lt; Arg &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>&lt; NestedMatrix &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> std</td></tr>
<tr class="memdesc:aea7ed7d9e2ba20d5c636be2a4b56c293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a non-hermitian matrix if NestedMatrix is not diagonal. <br /></td></tr>
<tr class="separator:aea7ed7d9e2ba20d5c636be2a4b56c293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11762be9fdd5ad98d2f0dfbaf27f7b94"><td class="memTemplParams" colspan="2"><a id="a11762be9fdd5ad98d2f0dfbaf27f7b94"></a>
template&lt;square_shaped&lt; Qualification::depends_on_dynamic_shape &gt; Arg&gt; </td></tr>
<tr class="memitem:a11762be9fdd5ad98d2f0dfbaf27f7b94"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a11762be9fdd5ad98d2f0dfbaf27f7b94">requires</a> (not <a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a>&lt; Arg &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>&lt; NestedMatrix &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> requires(Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a11762be9fdd5ad98d2f0dfbaf27f7b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a non-hermitian matrix if NestedMatrix is diagonal. <br /></td></tr>
<tr class="separator:a11762be9fdd5ad98d2f0dfbaf27f7b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d5a4bfb7b801f7f11517471a8b97ee"><td class="memTemplParams" colspan="2">template&lt;std::convertible_to&lt; const Scalar &gt; ... Args&gt; </td></tr>
<tr class="memitem:a82d5a4bfb7b801f7f11517471a8b97ee"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a82d5a4bfb7b801f7f11517471a8b97ee">requires</a> (sizeof...(Args) &gt; 0) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> requires(Args ... args)</td></tr>
<tr class="memdesc:a82d5a4bfb7b801f7f11517471a8b97ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a list of scalar coefficients, in row-major order.  <a href="namespaceOpenKalman.html#a82d5a4bfb7b801f7f11517471a8b97ee">More...</a><br /></td></tr>
<tr class="separator:a82d5a4bfb7b801f7f11517471a8b97ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79984a568eff69b0cfc035563f193f"><td class="memTemplParams" colspan="2"><a id="a4e79984a568eff69b0cfc035563f193f"></a>
template&lt;hermitian_matrix&lt; Qualification::depends_on_dynamic_shape &gt; M&gt; </td></tr>
<tr class="memitem:a4e79984a568eff69b0cfc035563f193f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4e79984a568eff69b0cfc035563f193f">SelfAdjointMatrix</a> (M &amp;&amp;) -&gt; SelfAdjointMatrix&lt; <a class="el" href="namespaceOpenKalman.html#a03b16f3264522ab5b6be8215b82b7e9d">nested_object_of_t</a>&lt; M &gt;, <a class="el" href="namespaceOpenKalman.html#ad0088e685736596243017da33045f865">hermitian_adapter_type_of_v</a>&lt; M &gt;&gt;</td></tr>
<tr class="memdesc:a4e79984a568eff69b0cfc035563f193f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduction guide for converting Eigen::SelfAdjointView to SelfAdjointMatrix. <br /></td></tr>
<tr class="separator:a4e79984a568eff69b0cfc035563f193f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95434bfa86443535997d861761f3581c"><td class="memTemplParams" colspan="2"><a id="a95434bfa86443535997d861761f3581c"></a>
template&lt;covariance_nestable M&gt; </td></tr>
<tr class="memitem:a95434bfa86443535997d861761f3581c"><td class="memTemplItemLeft" align="right" valign="top">requires(<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;==index_dimension_of_v&lt; NestedMatrix, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not std&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a95434bfa86443535997d861761f3581c">SquareRootCovariance</a> (M &amp;&amp;) -&gt; SquareRootCovariance&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1Dimensions.html">Dimensions</a>&lt; index_dimension_of_v&lt; M, 0 &gt;&gt;, passable_t&lt; M &gt;&gt;</td></tr>
<tr class="memdesc:a95434bfa86443535997d861761f3581c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce SquareRootCovariance type from a <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>. <br /></td></tr>
<tr class="separator:a95434bfa86443535997d861761f3581c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b2f28097342f903e9e7d7b811b337c"><td class="memTemplParams" colspan="2"><a id="a66b2f28097342f903e9e7d7b811b337c"></a>
template&lt;typed_matrix M&gt; </td></tr>
<tr class="memitem:a66b2f28097342f903e9e7d7b811b337c"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a66b2f28097342f903e9e7d7b811b337c">SquareRootCovariance</a> (M &amp;&amp;) -&gt; SquareRootCovariance&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; M, 0 &gt;, typename MatrixTraits&lt; std::decay_t&lt; <a class="el" href="namespaceOpenKalman.html#a03b16f3264522ab5b6be8215b82b7e9d">nested_object_of_t</a>&lt; M &gt;&gt;&gt;::template TriangularMatrixFrom&lt;&gt;&gt;</td></tr>
<tr class="memdesc:a66b2f28097342f903e9e7d7b811b337c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce SquareRootCovariance type from a square <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>. <br /></td></tr>
<tr class="separator:a66b2f28097342f903e9e7d7b811b337c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd09652a3ae438b68339b039ec3a735"><td class="memTemplParams" colspan="2">template&lt;covariance_nestable Arg&gt; </td></tr>
<tr class="memitem:a0bd09652a3ae438b68339b039ec3a735"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0bd09652a3ae438b68339b039ec3a735">make_square_root_covariance</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a0bd09652a3ae438b68339b039ec3a735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a SquareRootCovariance from a <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>, with default Axis coefficients.  <a href="namespaceOpenKalman.html#a0bd09652a3ae438b68339b039ec3a735">More...</a><br /></td></tr>
<tr class="separator:a0bd09652a3ae438b68339b039ec3a735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606ee0d83d6a4f542a876b81a454cb1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; Arg &gt; auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a606ee0d83d6a4f542a876b81a454cb1d">make_square_root_covariance</a> ()</td></tr>
<tr class="memdesc:a606ee0d83d6a4f542a876b81a454cb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a writable, uninitialized SquareRootCovariance, with default Axis coefficients.  <a href="namespaceOpenKalman.html#a606ee0d83d6a4f542a876b81a454cb1d">More...</a><br /></td></tr>
<tr class="separator:a606ee0d83d6a4f542a876b81a454cb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9ef446cddf13d347c406964c3bd6ab"><td class="memTemplParams" colspan="2">template&lt;indexible Arg, vector_space_descriptor C&gt; </td></tr>
<tr class="memitem:a5c9ef446cddf13d347c406964c3bd6ab"><td class="memTemplItemLeft" align="right" valign="top">requires(not <a class="el" href="namespaceOpenKalman.html#a8790c861060ce4dfc9868d45a10d73c4">from_euclidean_expr</a>&lt; NestedMatrix &gt;) struct ToEuclideanExpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a5c9ef446cddf13d347c406964c3bd6ab">ToEuclideanExpr</a> (Arg &amp;&amp;, const C &amp;) -&gt; ToEuclideanExpr&lt; C, passable_t&lt; Arg &gt;&gt;</td></tr>
<tr class="separator:a5c9ef446cddf13d347c406964c3bd6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89161eb6db1c601c18018dc3f87c3e48"><td class="memTemplParams" colspan="2">template&lt;indexible NestedObject&gt; </td></tr>
<tr class="memitem:a89161eb6db1c601c18018dc3f87c3e48"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a89161eb6db1c601c18018dc3f87c3e48">requires</a> (not <a class="el" href="namespaceOpenKalman.html#a8790c861060ce4dfc9868d45a10d73c4">from_euclidean_expr</a>&lt; NestedObject &gt;) struct <a class="el" href="namespaceOpenKalman.html#a5c9ef446cddf13d347c406964c3bd6ab">ToEuclideanExpr</a></td></tr>
<tr class="memdesc:a89161eb6db1c601c18018dc3f87c3e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression that transforms vector space descriptors into Euclidean space for application of directional statistics.  <a href="namespaceOpenKalman.html#a89161eb6db1c601c18018dc3f87c3e48">More...</a><br /></td></tr>
<tr class="separator:a89161eb6db1c601c18018dc3f87c3e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf85d6d9b731225e0dbfb59857fa967f"><td class="memTemplParams" colspan="2">template&lt;fixed_vector_space_descriptor Descriptor, typed_matrix_nestable MeanNestedMatrix, covariance_nestable CovarianceNestedMatrix, std::uniform_random_bit_generator random_number_engine = std::mt19937&gt; </td></tr>
<tr class="memitem:adf85d6d9b731225e0dbfb59857fa967f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#adf85d6d9b731225e0dbfb59857fa967f">requires</a> (index_dimension_of_v&lt; MeanNestedMatrix, 0 &gt;==index_dimension_of_v&lt; CovarianceNestedMatrix, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(index_dimension_of_v&lt; MeanNestedMatrix</td></tr>
<tr class="memdesc:adf85d6d9b731225e0dbfb59857fa967f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian distribution, defined in terms of a Mean and a Covariance.  <a href="namespaceOpenKalman.html#adf85d6d9b731225e0dbfb59857fa967f">More...</a><br /></td></tr>
<tr class="separator:adf85d6d9b731225e0dbfb59857fa967f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166c8fd0ea3c99895cd0f03e5bd33e21"><td class="memTemplParams" colspan="2">template&lt;indexible Arg&gt; </td></tr>
<tr class="memitem:a166c8fd0ea3c99895cd0f03e5bd33e21"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a166c8fd0ea3c99895cd0f03e5bd33e21">requires</a> (max_tensor_order_v&lt; Arg &gt;&lt;=2) const expr decltype(auto) adjoint(Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a166c8fd0ea3c99895cd0f03e5bd33e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the adjoint of a matrix.  <a href="namespaceOpenKalman.html#a166c8fd0ea3c99895cd0f03e5bd33e21">More...</a><br /></td></tr>
<tr class="separator:a166c8fd0ea3c99895cd0f03e5bd33e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cd7ce40e47ba1c85cad4c4e45a1ec4"><td class="memTemplParams" colspan="2">template&lt;indexible To, vector_space_descriptors_may_match_with&lt; To &gt; From&gt; </td></tr>
<tr class="memitem:ae7cd7ce40e47ba1c85cad4c4e45a1ec4"><td class="memTemplItemLeft" align="right" valign="top">constexpr To &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ae7cd7ce40e47ba1c85cad4c4e45a1ec4">assign</a> (To &amp;&amp;a, From &amp;&amp;b)</td></tr>
<tr class="memdesc:ae7cd7ce40e47ba1c85cad4c4e45a1ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a writable object from an indexible object.  <a href="namespaceOpenKalman.html#ae7cd7ce40e47ba1c85cad4c4e45a1ec4">More...</a><br /></td></tr>
<tr class="separator:ae7cd7ce40e47ba1c85cad4c4e45a1ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438a0a35c1b418a083708dccf3d06255"><td class="memTemplParams" colspan="2">template&lt;std::size_t index, std::size_t... indices, internal::has_uniform_fixed_vector_space_descriptors&lt; index, indices... &gt; Arg&gt; </td></tr>
<tr class="memitem:a438a0a35c1b418a083708dccf3d06255"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a438a0a35c1b418a083708dccf3d06255">requires</a> (not <a class="el" href="namespaceOpenKalman.html#a4d2ce6da5d4f3187281589b759364395">empty_object</a>&lt; Arg &gt;) const expr <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> decltype(auto) <a class="el" href="namespaceOpenKalman.html#a641b62efeed5cc744ce28951d6ca5601">average_reduce</a>(Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a438a0a35c1b418a083708dccf3d06255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a partial reduction by taking the average along one or more indices.  <a href="namespaceOpenKalman.html#a438a0a35c1b418a083708dccf3d06255">More...</a><br /></td></tr>
<tr class="separator:a438a0a35c1b418a083708dccf3d06255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641b62efeed5cc744ce28951d6ca5601"><td class="memTemplParams" colspan="2">template&lt;internal::has_uniform_fixed_vector_space_descriptors Arg&gt; </td></tr>
<tr class="memitem:a641b62efeed5cc744ce28951d6ca5601"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a641b62efeed5cc744ce28951d6ca5601">average_reduce</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a641b62efeed5cc744ce28951d6ca5601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a complete reduction by taking the average along all indices and returning a scalar value.  <a href="namespaceOpenKalman.html#a641b62efeed5cc744ce28951d6ca5601">More...</a><br /></td></tr>
<tr class="separator:a641b62efeed5cc744ce28951d6ca5601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4a36e61209a0b9363824ad1c155fdb"><td class="memTemplParams" colspan="2">template&lt;indexible Arg, index_value... Factors&gt; </td></tr>
<tr class="memitem:a0e4a36e61209a0b9363824ad1c155fdb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0e4a36e61209a0b9363824ad1c155fdb">requires</a> (... <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(<a class="el" href="namespaceOpenKalman.html#a04ca7c438cbddb3fd487e299c4d185ea">dynamic_index_value</a>&lt; Factors &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> requires { requires Factors::value &gt; 0;})) const expr <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> decltype(auto) broadcast(Arg &amp;&amp;arg</td></tr>
<tr class="memdesc:a0e4a36e61209a0b9363824ad1c155fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an object by replicating it by factors specified for each index.  <a href="namespaceOpenKalman.html#a0e4a36e61209a0b9363824ad1c155fdb">More...</a><br /></td></tr>
<tr class="separator:a0e4a36e61209a0b9363824ad1c155fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa5429eae98e1949363eb143a48ba8b"><td class="memTemplParams" colspan="2">template&lt;std::size_t... indices, typename Operation , indexible... Args&gt; </td></tr>
<tr class="memitem:a8aa5429eae98e1949363eb143a48ba8b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a8aa5429eae98e1949363eb143a48ba8b">requires</a> (sizeof...(Args) &gt; 0) const expr auto chipwise_operation(const Operation &amp;operation</td></tr>
<tr class="memdesc:a8aa5429eae98e1949363eb143a48ba8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a chipwise n-ary operation (n&gt;0) on one or more indexible objects.  <a href="namespaceOpenKalman.html#a8aa5429eae98e1949363eb143a48ba8b">More...</a><br /></td></tr>
<tr class="separator:a8aa5429eae98e1949363eb143a48ba8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417b4ea4656920e8251eb4783cd5977a"><td class="memTemplParams" colspan="2">template&lt;TriangleType triangle_type, hermitian_matrix&lt; Qualification::depends_on_dynamic_shape &gt; A&gt; </td></tr>
<tr class="memitem:a417b4ea4656920e8251eb4783cd5977a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a417b4ea4656920e8251eb4783cd5977a">requires</a> (triangle_type !=<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209baa0e17e2709a0404ae3d7de03b8ea9093">TriangleType::diagonal</a> <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>&lt; A &gt;) const expr <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>&lt; triangle_type &gt; decltype(auto) <a class="el" href="namespaceOpenKalman.html#a01c83504077bd3ab7538f265c37fbafd">cholesky_factor</a>(A &amp;&amp;a)</td></tr>
<tr class="memdesc:a417b4ea4656920e8251eb4783cd5977a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the Cholesky factor of a matrix.  <a href="namespaceOpenKalman.html#a417b4ea4656920e8251eb4783cd5977a">More...</a><br /></td></tr>
<tr class="separator:a417b4ea4656920e8251eb4783cd5977a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c83504077bd3ab7538f265c37fbafd"><td class="memTemplParams" colspan="2">template&lt;hermitian_matrix&lt; Qualification::depends_on_dynamic_shape &gt; A&gt; </td></tr>
<tr class="memitem:a01c83504077bd3ab7538f265c37fbafd"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto) <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a01c83504077bd3ab7538f265c37fbafd">cholesky_factor</a> (A &amp;&amp;a)</td></tr>
<tr class="separator:a01c83504077bd3ab7538f265c37fbafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3eb9668bebd5c4243ff8a05def4dd05"><td class="memTemplParams" colspan="2">template&lt;triangular_matrix A&gt; </td></tr>
<tr class="memitem:ae3eb9668bebd5c4243ff8a05def4dd05"><td class="memTemplItemLeft" align="right" valign="top">requires constexpr <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; A, <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30">Qualification::depends_on_dynamic_shape</a> &gt;decltype(auto) <a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ae3eb9668bebd5c4243ff8a05def4dd05">cholesky_square</a> (A &amp;&amp;a)</td></tr>
<tr class="memdesc:ae3eb9668bebd5c4243ff8a05def4dd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the Cholesky square of a <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>.  <a href="namespaceOpenKalman.html#ae3eb9668bebd5c4243ff8a05def4dd05">More...</a><br /></td></tr>
<tr class="separator:ae3eb9668bebd5c4243ff8a05def4dd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b403d6ff4f5ead605b12940841659f6"><td class="memTemplParams" colspan="2">template&lt;std::size_t... indices, indexible Arg, detail::concatenate_dimensions_match&lt; Arg &gt;... Args&gt; </td></tr>
<tr class="memitem:a8b403d6ff4f5ead605b12940841659f6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a8b403d6ff4f5ead605b12940841659f6">requires</a> (sizeof...(indices) &gt; 0) const expr decltype(auto) <a class="el" href="namespaceOpenKalman.html#a5eea165f22b79ddfa5081d4019853b47">concatenate</a>(Arg &amp;&amp;arg</td></tr>
<tr class="memdesc:a8b403d6ff4f5ead605b12940841659f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate some number of objects along one or more indices.  <a href="namespaceOpenKalman.html#a8b403d6ff4f5ead605b12940841659f6">More...</a><br /></td></tr>
<tr class="separator:a8b403d6ff4f5ead605b12940841659f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad3b0d5e413cdc9e6cf637e2ec3cbd9"><td class="memTemplParams" colspan="2">template&lt;indexible Arg&gt; </td></tr>
<tr class="memitem:abad3b0d5e413cdc9e6cf637e2ec3cbd9"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#abad3b0d5e413cdc9e6cf637e2ec3cbd9">conjugate</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:abad3b0d5e413cdc9e6cf637e2ec3cbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the conjugate of a matrix.  <a href="namespaceOpenKalman.html#abad3b0d5e413cdc9e6cf637e2ec3cbd9">More...</a><br /></td></tr>
<tr class="separator:abad3b0d5e413cdc9e6cf637e2ec3cbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817c87490aba57d1def8ff710575e905"><td class="memTemplParams" colspan="2">template&lt;square_shaped&lt; Qualification::depends_on_dynamic_shape &gt; Arg&gt; </td></tr>
<tr class="memitem:a817c87490aba57d1def8ff710575e905"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a817c87490aba57d1def8ff710575e905">requires</a> (max_tensor_order_v&lt; Arg &gt;&lt;=2) const expr std</td></tr>
<tr class="memdesc:a817c87490aba57d1def8ff710575e905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the determinant of a matrix.  <a href="namespaceOpenKalman.html#a817c87490aba57d1def8ff710575e905">More...</a><br /></td></tr>
<tr class="separator:a817c87490aba57d1def8ff710575e905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadc3b8d1b3899d9d9554ab5ab9bc8fd"><td class="memTemplParams" colspan="2">template&lt;Layout layout = Layout::right, indexible Arg, scalar_type ... S&gt; </td></tr>
<tr class="memitem:aeadc3b8d1b3899d9d9554ab5ab9bc8fd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aeadc3b8d1b3899d9d9554ab5ab9bc8fd">requires</a> (layout==<a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea7c4f29407893c334a6cb7a87bf045c0d">Layout::right</a> <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> layout==<a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea811882fecd5c7618d7099ebbd39ea254">Layout::left</a>) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> internal</td></tr>
<tr class="memdesc:aeadc3b8d1b3899d9d9554ab5ab9bc8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the components of an object from a list of scalar values.  <a href="namespaceOpenKalman.html#aeadc3b8d1b3899d9d9554ab5ab9bc8fd">More...</a><br /></td></tr>
<tr class="separator:aeadc3b8d1b3899d9d9554ab5ab9bc8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e049482086d430a8cfd7d538de5a02a"><td class="memTemplParams" colspan="2">template&lt;wrappable Arg, vector_space_descriptor V&gt; </td></tr>
<tr class="memitem:a0e049482086d430a8cfd7d538de5a02a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0e049482086d430a8cfd7d538de5a02a">requires</a> (<a class="el" href="namespaceOpenKalman.html#a31eae8386d50ed98dc96326732ef9234">dynamic_vector_space_descriptor</a>&lt; V &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a6e91b2f6875a87b261fa4929a5ab00c8">dynamic_dimension</a>&lt; Arg, 0 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt; Arg, 0 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; V, <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 0 &gt;&gt;) const expr decltype(auto) from_euclidean(Arg &amp;&amp;arg</td></tr>
<tr class="memdesc:a0e049482086d430a8cfd7d538de5a02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a Euclidean space associated with index 0 to a (potentially wrapped) vector space after applying directional statistics.  <a href="namespaceOpenKalman.html#a0e049482086d430a8cfd7d538de5a02a">More...</a><br /></td></tr>
<tr class="separator:a0e049482086d430a8cfd7d538de5a02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78802460b0a8da10df93ac7617b10e5d"><td class="memTemplParams" colspan="2">template&lt;std::size_t... indices, indexible Arg, index_value... Ixs&gt; </td></tr>
<tr class="memitem:a78802460b0a8da10df93ac7617b10e5d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a78802460b0a8da10df93ac7617b10e5d">requires</a> (sizeof...(indices)==sizeof...(Ixs)) const expr decltype(auto) get_chip(Arg &amp;&amp;arg</td></tr>
<tr class="memdesc:a78802460b0a8da10df93ac7617b10e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a sub-array having rank less than the rank of the input object.  <a href="namespaceOpenKalman.html#a78802460b0a8da10df93ac7617b10e5d">More...</a><br /></td></tr>
<tr class="separator:a78802460b0a8da10df93ac7617b10e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468e4521e756fcbe5b3a2306513e54cc"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Indices , std::enable_if_t&lt; indexible&lt; Arg &gt; and index_value&lt;  decltype, int &gt; </td></tr>
<tr class="memitem:a468e4521e756fcbe5b3a2306513e54cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a468e4521e756fcbe5b3a2306513e54cc">get_component</a> (Arg &amp;&amp;arg, const Indices &amp;indices)</td></tr>
<tr class="memdesc:a468e4521e756fcbe5b3a2306513e54cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a component of an object at a particular set of indices.  <a href="namespaceOpenKalman.html#a468e4521e756fcbe5b3a2306513e54cc">More...</a><br /></td></tr>
<tr class="separator:a468e4521e756fcbe5b3a2306513e54cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e23c6db3dac174912de398cce549901"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Indices , std::enable_if_t&lt; indexible&lt; Arg &gt; and index_value&lt; Indices &gt; and(not empty_object&lt; Arg &gt;), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a2e23c6db3dac174912de398cce549901"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2e23c6db3dac174912de398cce549901">get_component</a> (Arg &amp;&amp;arg, const std::initializer_list&lt; Indices &gt; &amp;indices)</td></tr>
<tr class="memdesc:a2e23c6db3dac174912de398cce549901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a component of an object using an initializer list.  <a href="namespaceOpenKalman.html#a2e23c6db3dac174912de398cce549901">More...</a><br /></td></tr>
<tr class="separator:a2e23c6db3dac174912de398cce549901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7c14154c4c8afd53aafaf206202e0e"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename... I, std::enable_if_t&lt; indexible&lt; Arg &gt; and(... and index_value&lt; I &gt;) and(index_count&lt; Arg &gt;::value==dynamic_size or sizeof...(I) &gt;=index_count&lt; Arg &gt;::value) and(not empty_object&lt; Arg &gt;) and internal::static_indices_within_bounds&lt; Arg, I... &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a0c7c14154c4c8afd53aafaf206202e0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0c7c14154c4c8afd53aafaf206202e0e">get_component</a> (Arg &amp;&amp;arg, I &amp;&amp;...i)</td></tr>
<tr class="memdesc:a0c7c14154c4c8afd53aafaf206202e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a component of an object using a fixed number of indices.  <a href="namespaceOpenKalman.html#a0c7c14154c4c8afd53aafaf206202e0e">More...</a><br /></td></tr>
<tr class="separator:a0c7c14154c4c8afd53aafaf206202e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5df307d607f8e4623e586dda547901"><td class="memTemplParams" colspan="2">template&lt;std::size_t... indices, indexible Arg, index_value... Begin, index_value... Size&gt; </td></tr>
<tr class="memitem:a3c5df307d607f8e4623e586dda547901"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a3c5df307d607f8e4623e586dda547901">requires</a> (sizeof...(Begin)==sizeof...(Size)) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> internal</td></tr>
<tr class="memdesc:a3c5df307d607f8e4623e586dda547901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a slice from a matrix or tensor.  <a href="namespaceOpenKalman.html#a3c5df307d607f8e4623e586dda547901">More...</a><br /></td></tr>
<tr class="separator:a3c5df307d607f8e4623e586dda547901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53037a5c9000410a8fa8e43e05dd5cd0"><td class="memTemplParams" colspan="2">template&lt;indexible A&gt; </td></tr>
<tr class="memitem:a53037a5c9000410a8fa8e43e05dd5cd0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a53037a5c9000410a8fa8e43e05dd5cd0">requires</a> (not <a class="el" href="namespaceOpenKalman.html#afde753e8fa98ead4323ad7f74c6e314f">euclidean_transformed</a>&lt; A &gt;) const expr <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>&lt; <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a></td></tr>
<tr class="memdesc:a53037a5c9000410a8fa8e43e05dd5cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an LQ decomposition of matrix A=[L,0]Q, L is a lower-triangular matrix, and Q is orthogonal.  <a href="namespaceOpenKalman.html#a53037a5c9000410a8fa8e43e05dd5cd0">More...</a><br /></td></tr>
<tr class="separator:a53037a5c9000410a8fa8e43e05dd5cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30135b36d5d792be0f05ccc85ff286c"><td class="memTemplParams" colspan="2">template&lt;indexible T, scalar_constant C, vector_space_descriptor... Ds&gt; </td></tr>
<tr class="memitem:aa30135b36d5d792be0f05ccc85ff286c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aa30135b36d5d792be0f05ccc85ff286c">requires</a> (sizeof...(Ds) !=0) <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a>(not <a class="el" href="namespaceOpenKalman.html#a2df14967a1282177068bd8aaff491e65">has_dynamic_dimensions</a>&lt; T &gt;) const expr const ant_matrix auto make_constant(C &amp;&amp;c</td></tr>
<tr class="memdesc:aa30135b36d5d792be0f05ccc85ff286c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a constant object based on a particular library object.  <a href="namespaceOpenKalman.html#aa30135b36d5d792be0f05ccc85ff286c">More...</a><br /></td></tr>
<tr class="separator:aa30135b36d5d792be0f05ccc85ff286c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1057a6c9a969b189dd249d34fa84a5ad"><td class="memTemplParams" colspan="2">template&lt;indexible T, Layout layout = Layout::none, scalar_type Scalar = scalar_type_of_t&lt;T&gt;, vector_space_descriptor... D&gt; </td></tr>
<tr class="memitem:a1057a6c9a969b189dd249d34fa84a5ad"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a1057a6c9a969b189dd249d34fa84a5ad">requires</a> (layout !=<a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea47101375aa96fa02cfb1d55fd00af989">Layout::stride</a>) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> interface = typename detail::dense_writable_matrix_impl&lt;T, layout, std::decay_t&lt;S&gt;, D...&gt;::type</td></tr>
<tr class="memdesc:a1057a6c9a969b189dd249d34fa84a5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default, dense, writable matrix based on a list of Dimensions describing the sizes of each index.  <a href="namespaceOpenKalman.html#a1057a6c9a969b189dd249d34fa84a5ad">More...</a><br /></td></tr>
<tr class="separator:a1057a6c9a969b189dd249d34fa84a5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5219de18d1ade23e3ac70972d585cb3a"><td class="memTemplParams" colspan="2">template&lt;indexible Arg, vector_space_descriptor D0, vector_space_descriptor D1&gt; </td></tr>
<tr class="memitem:a5219de18d1ade23e3ac70972d585cb3a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a5219de18d1ade23e3ac70972d585cb3a">requires</a> (not <a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; D0 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not <a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; D1 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman_1_1internal.html#a601527fae38b2760d48bb409307dcd88">internal::prefix_of</a>&lt; D0, D1 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman_1_1internal.html#a601527fae38b2760d48bb409307dcd88">internal::prefix_of</a>&lt; D1, D0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(<a class="el" href="namespaceOpenKalman.html#a6e91b2f6875a87b261fa4929a5ab00c8">dynamic_dimension</a>&lt; Arg</td></tr>
<tr class="memdesc:a5219de18d1ade23e3ac70972d585cb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>, specifying the first two dimensions, which may not necessarily be the same.  <a href="namespaceOpenKalman.html#a5219de18d1ade23e3ac70972d585cb3a">More...</a><br /></td></tr>
<tr class="separator:a5219de18d1ade23e3ac70972d585cb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a81f86cc97db31634eae30b9887c5fb"><td class="memTemplParams" colspan="2">template&lt;indexible Arg&gt; </td></tr>
<tr class="memitem:a3a81f86cc97db31634eae30b9887c5fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a3a81f86cc97db31634eae30b9887c5fb">make_diagonal_matrix</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a3a81f86cc97db31634eae30b9887c5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an square <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a> that is square with respect to dimensions 0 and 1.  <a href="namespaceOpenKalman.html#a3a81f86cc97db31634eae30b9887c5fb">More...</a><br /></td></tr>
<tr class="separator:a3a81f86cc97db31634eae30b9887c5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe0a0d1c311f0eb1361c678e6591dc9"><td class="memTemplParams" colspan="2">template&lt;indexible T, scalar_type Scalar = scalar_type_of_t&lt;T&gt;, vector_space_descriptor D0, vector_space_descriptor D1, vector_space_descriptor... Ds&gt; </td></tr>
<tr class="memitem:adbe0a0d1c311f0eb1361c678e6591dc9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#adbe0a0d1c311f0eb1361c678e6591dc9">requires</a> (not <a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; D0 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not <a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; D1 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman_1_1internal.html#a601527fae38b2760d48bb409307dcd88">internal::prefix_of</a>&lt; D0, D1 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman_1_1internal.html#a601527fae38b2760d48bb409307dcd88">internal::prefix_of</a>&lt; D1, D0 &gt;) const expr <a class="el" href="namespaceOpenKalman.html#a2a52b813621d6f1567234b83e0cad2bb">identity_matrix</a> auto <a class="el" href="namespaceOpenKalman.html#a4aaf087f2ae09405e334c02bd396e8fa">make_identity_matrix_like</a>(D0 &amp;&amp;d0</td></tr>
<tr class="memdesc:adbe0a0d1c311f0eb1361c678e6591dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an identity matrix with a particular set of dimensions.  <a href="namespaceOpenKalman.html#adbe0a0d1c311f0eb1361c678e6591dc9">More...</a><br /></td></tr>
<tr class="separator:adbe0a0d1c311f0eb1361c678e6591dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaf087f2ae09405e334c02bd396e8fa"><td class="memTemplParams" colspan="2">template&lt;scalar_type Scalar, indexible Arg&gt; </td></tr>
<tr class="memitem:a4aaf087f2ae09405e334c02bd396e8fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceOpenKalman.html#a2a52b813621d6f1567234b83e0cad2bb">identity_matrix</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4aaf087f2ae09405e334c02bd396e8fa">make_identity_matrix_like</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a4aaf087f2ae09405e334c02bd396e8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an identity matrix with the same size and shape as an argument, specifying a new scalar type.  <a href="namespaceOpenKalman.html#a4aaf087f2ae09405e334c02bd396e8fa">More...</a><br /></td></tr>
<tr class="separator:a4aaf087f2ae09405e334c02bd396e8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810cb1bd7aec431e68f50c081cc9f295"><td class="memTemplParams" colspan="2">template&lt;indexible Arg&gt; </td></tr>
<tr class="memitem:a810cb1bd7aec431e68f50c081cc9f295"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceOpenKalman.html#a2a52b813621d6f1567234b83e0cad2bb">identity_matrix</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a810cb1bd7aec431e68f50c081cc9f295">make_identity_matrix_like</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a810cb1bd7aec431e68f50c081cc9f295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an identity matrix with the same size and shape as an argument.  <a href="namespaceOpenKalman.html#a810cb1bd7aec431e68f50c081cc9f295">More...</a><br /></td></tr>
<tr class="separator:a810cb1bd7aec431e68f50c081cc9f295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fef8225fd0142e06907ef6cbb96290"><td class="memTemplParams" colspan="2">template&lt;TriangleType t = TriangleType::lower, indexible Arg&gt; </td></tr>
<tr class="memitem:ac3fef8225fd0142e06907ef6cbb96290"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ac3fef8225fd0142e06907ef6cbb96290">requires</a> (t==<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba81e073b428b50247daba38531dcf412a">TriangleType::lower</a> <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> t==<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">TriangleType::upper</a> <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> t==<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209baa0e17e2709a0404ae3d7de03b8ea9093">TriangleType::diagonal</a>) const expr <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>&lt; t &gt; decltype(auto) make_triangular_matrix(Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:ac3fef8225fd0142e06907ef6cbb96290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a> from a general matrix.  <a href="namespaceOpenKalman.html#ac3fef8225fd0142e06907ef6cbb96290">More...</a><br /></td></tr>
<tr class="separator:ac3fef8225fd0142e06907ef6cbb96290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ec07cc06e19af84f87471e4f387720"><td class="memTemplParams" colspan="2">template&lt;indexible Arg, vector_space_descriptor... Ds&gt; </td></tr>
<tr class="memitem:a16ec07cc06e19af84f87471e4f387720"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman_1_1internal.html#abc8a076739643eb44a47a90d10f7974c">internal::not_more_fixed_than</a>&lt; Arg, Ds... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a16ec07cc06e19af84f87471e4f387720">and</a> (not <a class="el" href="namespaceOpenKalman_1_1internal.html#a22f7a8daa8f3c006b00dd41ca4329a4c">internal::less_fixed_than</a>&lt; Arg, Ds... &gt;) and internal</td></tr>
<tr class="memdesc:a16ec07cc06e19af84f87471e4f387720"><td class="mdescLeft">&#160;</td><td class="mdescRight">If necessary, wrap an object in a wrapper that adds vector space descriptors for each index.  <a href="namespaceOpenKalman.html#a16ec07cc06e19af84f87471e4f387720">More...</a><br /></td></tr>
<tr class="separator:a16ec07cc06e19af84f87471e4f387720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cecabf2d6451987477317b5c7805a4"><td class="memTemplParams" colspan="2">template&lt;fixed_vector_space_descriptor... Ds, indexible Arg&gt; </td></tr>
<tr class="memitem:ab0cecabf2d6451987477317b5c7805a4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ab0cecabf2d6451987477317b5c7805a4">requires</a> (not <a class="el" href="namespaceOpenKalman.html#a2df14967a1282177068bd8aaff491e65">has_dynamic_dimensions</a>&lt; Arg &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(sizeof...(Ds) &gt; 0) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> internal</td></tr>
<tr class="memdesc:ab0cecabf2d6451987477317b5c7805a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an adapter in which all vector space descriptors are fixed.  <a href="namespaceOpenKalman.html#ab0cecabf2d6451987477317b5c7805a4">More...</a><br /></td></tr>
<tr class="separator:ab0cecabf2d6451987477317b5c7805a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f739bf230b05b500ec8971ec94a4d61"><td class="memTemplParams" colspan="2">template&lt;indexible T, scalar_type Scalar = scalar_type_of_t&lt;T&gt;, vector_space_descriptor... Ds&gt; </td></tr>
<tr class="memitem:a3f739bf230b05b500ec8971ec94a4d61"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a3f739bf230b05b500ec8971ec94a4d61">requires</a> (sizeof...(Ds)==index_count_v&lt; T &gt;) <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a>(sizeof...(Ds)</td></tr>
<tr class="memdesc:a3f739bf230b05b500ec8971ec94a4d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a> associated with a particular library.  <a href="namespaceOpenKalman.html#a3f739bf230b05b500ec8971ec94a4d61">More...</a><br /></td></tr>
<tr class="separator:a3f739bf230b05b500ec8971ec94a4d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef005135c9c2fe905e52a3f722efdac6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> constexpr T <a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aef005135c9c2fe905e52a3f722efdac6">make_zero</a> (const T &amp;t)</td></tr>
<tr class="memdesc:aef005135c9c2fe905e52a3f722efdac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a zero matrix based on T.  <a href="namespaceOpenKalman.html#aef005135c9c2fe905e52a3f722efdac6">More...</a><br /></td></tr>
<tr class="separator:aef005135c9c2fe905e52a3f722efdac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c50f80dd02e0cdef3b395406dc34c50"><td class="memTemplParams" colspan="2">template&lt;vector_space_descriptor... Ds, typename Operation , indexible... Args&gt; </td></tr>
<tr class="memitem:a3c50f80dd02e0cdef3b395406dc34c50"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a3c50f80dd02e0cdef3b395406dc34c50">requires</a> (sizeof...(Args) &gt; 0) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> detail</td></tr>
<tr class="memdesc:a3c50f80dd02e0cdef3b395406dc34c50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a component-wise n-ary operation, using broadcasting to match the size of a pattern matrix.  <a href="namespaceOpenKalman.html#a3c50f80dd02e0cdef3b395406dc34c50">More...</a><br /></td></tr>
<tr class="separator:a3c50f80dd02e0cdef3b395406dc34c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069d6e208bb47413b71e0a4e11192b68"><td class="memTemplParams" colspan="2">template&lt;typename Operation , indexible... Args&gt; </td></tr>
<tr class="memitem:a069d6e208bb47413b71e0a4e11192b68"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a069d6e208bb47413b71e0a4e11192b68">requires</a> (sizeof...(Args) &gt; 0) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> detail</td></tr>
<tr class="memdesc:a069d6e208bb47413b71e0a4e11192b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a component-wise n-ary operation, using broadcasting if necessary to make the arguments the same size.  <a href="namespaceOpenKalman.html#a069d6e208bb47413b71e0a4e11192b68">More...</a><br /></td></tr>
<tr class="separator:a069d6e208bb47413b71e0a4e11192b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644162964434183513f9d121ec4ec21e"><td class="memTemplParams" colspan="2">template&lt;indexible PatternMatrix, std::size_t... indices, vector_space_descriptor... Ds, typename... Operations&gt; </td></tr>
<tr class="memitem:a644162964434183513f9d121ec4ec21e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a644162964434183513f9d121ec4ec21e">requires</a> ((<a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; std::tuple_element_t&lt; indices, std::tuple&lt; Ds... &gt;&gt;&gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> ...) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(sizeof...(Operations)</td></tr>
<tr class="memdesc:a644162964434183513f9d121ec4ec21e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a component-wise nullary operation with potentially multiple operations for different blocks.  <a href="namespaceOpenKalman.html#a644162964434183513f9d121ec4ec21e">More...</a><br /></td></tr>
<tr class="separator:a644162964434183513f9d121ec4ec21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09023dc82cbe71e465ac32184fd325c3"><td class="memTemplParams" colspan="2">template&lt;has_nested_object Arg&gt; </td></tr>
<tr class="memitem:a09023dc82cbe71e465ac32184fd325c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a09023dc82cbe71e465ac32184fd325c3">nested_object</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a09023dc82cbe71e465ac32184fd325c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a nested object of Arg, if it exists.  <a href="namespaceOpenKalman.html#a09023dc82cbe71e465ac32184fd325c3">More...</a><br /></td></tr>
<tr class="separator:a09023dc82cbe71e465ac32184fd325c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657983b53745e10f84cc229af98a0978"><td class="memTemplParams" colspan="2">template&lt;indexible A&gt; </td></tr>
<tr class="memitem:a657983b53745e10f84cc229af98a0978"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto) <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>&lt; <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">TriangleType::upper</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a657983b53745e10f84cc229af98a0978">QR_decomposition</a> (A &amp;&amp;a)</td></tr>
<tr class="memdesc:a657983b53745e10f84cc229af98a0978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a QR decomposition of matrix A=Q[U,0], U is a upper-triangular matrix, and Q is orthogonal.  <a href="namespaceOpenKalman.html#a657983b53745e10f84cc229af98a0978">More...</a><br /></td></tr>
<tr class="separator:a657983b53745e10f84cc229af98a0978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a641e63358c6f36058cdd8380538b4"><td class="memTemplParams" colspan="2">template&lt;indexible PatternMatrix, std::size_t... indices, std::uniform_random_bit_generator random_number_generator, vector_space_descriptor... Ds, typename... Dists&gt; </td></tr>
<tr class="memitem:a33a641e63358c6f36058cdd8380538b4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a33a641e63358c6f36058cdd8380538b4">requires</a> ((<a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; std::tuple_element_t&lt; indices, std::tuple&lt; Ds... &gt;&gt;&gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> ...) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(sizeof...(Dists)</td></tr>
<tr class="memdesc:a33a641e63358c6f36058cdd8380538b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an indexible object with random values selected from one or more random distributions.  <a href="namespaceOpenKalman.html#a33a641e63358c6f36058cdd8380538b4">More...</a><br /></td></tr>
<tr class="separator:a33a641e63358c6f36058cdd8380538b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b41f709d7fda5e8641b771bcc99c9d0"><td class="memTemplParams" colspan="2">template&lt;hermitian_matrix&lt; Qualification::depends_on_dynamic_shape &gt; A, indexible U&gt; </td></tr>
<tr class="memitem:a7b41f709d7fda5e8641b771bcc99c9d0"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#acb4ff0c32c70ea24cfc42faaa4ae58d2">dimension_size_of_index_is</a>&lt; U, 0, index_dimension_of_v&lt; A, 0 &gt;, <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30">Qualification::depends_on_dynamic_shape</a> &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#acb4ff0c32c70ea24cfc42faaa4ae58d2">dimension_size_of_index_is</a>&lt; U, 0, index_dimension_of_v&lt; A, 1 &gt;, <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30">Qualification::depends_on_dynamic_shape</a> &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> std::convertible_to&lt; <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; U &gt;, const <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; A &gt; &gt;decltype(auto) <a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a7b41f709d7fda5e8641b771bcc99c9d0">rank_update_hermitian</a> (A &amp;&amp;a, U &amp;&amp;u, <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; A &gt; alpha=1)</td></tr>
<tr class="memdesc:a7b41f709d7fda5e8641b771bcc99c9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a rank update on a hermitian matrix.  <a href="namespaceOpenKalman.html#a7b41f709d7fda5e8641b771bcc99c9d0">More...</a><br /></td></tr>
<tr class="separator:a7b41f709d7fda5e8641b771bcc99c9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ce1958c2e246aca54146613ee31339"><td class="memTemplParams" colspan="2">template&lt;triangular_matrix&lt; TriangleType::any &gt; A, indexible U&gt; </td></tr>
<tr class="memitem:a68ce1958c2e246aca54146613ee31339"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#acb4ff0c32c70ea24cfc42faaa4ae58d2">dimension_size_of_index_is</a>&lt; U, 0, index_dimension_of_v&lt; A, 0 &gt;, <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30">Qualification::depends_on_dynamic_shape</a> &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#acb4ff0c32c70ea24cfc42faaa4ae58d2">dimension_size_of_index_is</a>&lt; U, 0, index_dimension_of_v&lt; A, 1 &gt;, <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30">Qualification::depends_on_dynamic_shape</a> &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> std::convertible_to&lt; <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; U &gt;, const <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; A &gt; &gt;decltype(auto) <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>&lt; <a class="el" href="namespaceOpenKalman.html#ac8913d4eca256134749dc085bf617466">triangle_type_of_v</a>&lt; A &gt;==<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">TriangleType::upper</a> ? <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">TriangleType::upper</a> :<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba81e073b428b50247daba38531dcf412a">TriangleType::lower</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a68ce1958c2e246aca54146613ee31339">rank_update_triangular</a> (A &amp;&amp;a, U &amp;&amp;u, <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; A &gt; alpha=1)</td></tr>
<tr class="memdesc:a68ce1958c2e246aca54146613ee31339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a rank update on triangular matrix.  <a href="namespaceOpenKalman.html#a68ce1958c2e246aca54146613ee31339">More...</a><br /></td></tr>
<tr class="separator:a68ce1958c2e246aca54146613ee31339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9995d627138ebb17ba9e7363a319e1"><td class="memTemplParams" colspan="2">template&lt;std::size_t index, std::size_t... indices, typename BinaryFunction , internal::has_uniform_fixed_vector_space_descriptors&lt; index, indices... &gt; Arg&gt; </td></tr>
<tr class="memitem:a2a9995d627138ebb17ba9e7363a319e1"><td class="memTemplItemLeft" align="right" valign="top">requires constexpr std::is_invocable_r_v&lt; <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt;, BinaryFunction &amp;&amp;, <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt;, <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt; &gt;decltype(auto) <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2a9995d627138ebb17ba9e7363a319e1">reduce</a> (BinaryFunction &amp;&amp;b, Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a2a9995d627138ebb17ba9e7363a319e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a partial reduction based on an associative binary function, across one or more indices.  <a href="namespaceOpenKalman.html#a2a9995d627138ebb17ba9e7363a319e1">More...</a><br /></td></tr>
<tr class="separator:a2a9995d627138ebb17ba9e7363a319e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bf477a67e664cf9838c07e15a327f5"><td class="memTemplParams" colspan="2">template&lt;typename BinaryFunction , internal::has_uniform_fixed_vector_space_descriptors Arg&gt; </td></tr>
<tr class="memitem:a07bf477a67e664cf9838c07e15a327f5"><td class="memTemplItemLeft" align="right" valign="top">requires constexpr std::is_invocable_r_v&lt; <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt;, BinaryFunction &amp;&amp;, <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt;, <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt; &gt; <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a07bf477a67e664cf9838c07e15a327f5">reduce</a> (const BinaryFunction &amp;b, const Arg &amp;arg)</td></tr>
<tr class="memdesc:a07bf477a67e664cf9838c07e15a327f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a complete reduction based on an associative binary function, and return a scalar.  <a href="namespaceOpenKalman.html#a07bf477a67e664cf9838c07e15a327f5">More...</a><br /></td></tr>
<tr class="separator:a07bf477a67e664cf9838c07e15a327f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed14ff54203adfde6276b06d6eceeb85"><td class="memTemplParams" colspan="2">template&lt;indexible Arg, scalar_constant S&gt; </td></tr>
<tr class="memitem:aed14ff54203adfde6276b06d6eceeb85"><td class="memTemplItemLeft" align="right" valign="top">requires&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aed14ff54203adfde6276b06d6eceeb85">requires</a> (S s)</td></tr>
<tr class="memdesc:aed14ff54203adfde6276b06d6eceeb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply an object by a scalar value.  <a href="namespaceOpenKalman.html#aed14ff54203adfde6276b06d6eceeb85">More...</a><br /></td></tr>
<tr class="separator:aed14ff54203adfde6276b06d6eceeb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f654f5665cd41eb79ed2e08e8c1f6d2"><td class="memTemplParams" colspan="2">template&lt;std::size_t... indices, writable Arg, indexible Chip, index_value... Ixs&gt; </td></tr>
<tr class="memitem:a7f654f5665cd41eb79ed2e08e8c1f6d2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a7f654f5665cd41eb79ed2e08e8c1f6d2">requires</a> (sizeof...(indices)==sizeof...(Ixs)) const expr Arg &amp;&amp;set_chip(Arg &amp;&amp;arg</td></tr>
<tr class="memdesc:a7f654f5665cd41eb79ed2e08e8c1f6d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a sub-array having rank less than the rank of the input object.  <a href="namespaceOpenKalman.html#a7f654f5665cd41eb79ed2e08e8c1f6d2">More...</a><br /></td></tr>
<tr class="separator:a7f654f5665cd41eb79ed2e08e8c1f6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af856ae93af81c5aa773607a257889e02"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Indices , std::enable_if_t&lt; writable_by_component&lt; Arg, Indices &gt; and index_value&lt;  decltype, int &gt; </td></tr>
<tr class="memitem:af856ae93af81c5aa773607a257889e02"><td class="memTemplItemLeft" align="right" valign="top">Arg &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#af856ae93af81c5aa773607a257889e02">set_component</a> (Arg &amp;&amp;arg, const <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt; &amp;s, const Indices &amp;indices)</td></tr>
<tr class="memdesc:af856ae93af81c5aa773607a257889e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a component of an object at a particular set of indices.  <a href="namespaceOpenKalman.html#af856ae93af81c5aa773607a257889e02">More...</a><br /></td></tr>
<tr class="separator:af856ae93af81c5aa773607a257889e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a0ba0d290788c643191cc5abca9f87"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename Indices , std::enable_if_t&lt; index_value&lt; Indices &gt; and writable_by_component&lt; Arg, std::initializer_list&lt; Indices &gt;&gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab1a0ba0d290788c643191cc5abca9f87"><td class="memTemplItemLeft" align="right" valign="top">Arg &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ab1a0ba0d290788c643191cc5abca9f87">set_component</a> (Arg &amp;&amp;arg, const <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt; &amp;s, const std::initializer_list&lt; Indices &gt; &amp;indices)</td></tr>
<tr class="memdesc:ab1a0ba0d290788c643191cc5abca9f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a component of an object using an initializer list.  <a href="namespaceOpenKalman.html#ab1a0ba0d290788c643191cc5abca9f87">More...</a><br /></td></tr>
<tr class="separator:ab1a0ba0d290788c643191cc5abca9f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab182263021d646820f1a316607fdd6c3"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename... I, std::enable_if_t&lt;(index_value&lt; I &gt; and ...) and writable_by_component&lt; Arg, std::array&lt; std::size_t, sizeof...(I)&gt;&gt; and(index_count&lt; Arg &gt;::value==dynamic_size or sizeof...(I) &gt;=index_count&lt; Arg &gt;::value) and internal::static_indices_within_bounds&lt; Arg, I... &gt;::value, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab182263021d646820f1a316607fdd6c3"><td class="memTemplItemLeft" align="right" valign="top">Arg &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ab182263021d646820f1a316607fdd6c3">set_component</a> (Arg &amp;&amp;arg, const <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt; &amp;s, I &amp;&amp;...i)</td></tr>
<tr class="memdesc:ab182263021d646820f1a316607fdd6c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a component of an object using a fixed number of indices.  <a href="namespaceOpenKalman.html#ab182263021d646820f1a316607fdd6c3">More...</a><br /></td></tr>
<tr class="separator:ab182263021d646820f1a316607fdd6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1475f0750497f10e6dfd9af0084ce5de"><td class="memTemplParams" colspan="2">template&lt;writable Arg, indexible Block, index_value... Begin&gt; </td></tr>
<tr class="memitem:a1475f0750497f10e6dfd9af0084ce5de"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a1475f0750497f10e6dfd9af0084ce5de">requires</a> (sizeof...(Begin) &gt;=index_count_v&lt; Arg &gt;) const expr Arg &amp;&amp;set_slice(Arg &amp;&amp;arg</td></tr>
<tr class="memdesc:a1475f0750497f10e6dfd9af0084ce5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an object to a particular slice of a matrix or tensor.  <a href="namespaceOpenKalman.html#a1475f0750497f10e6dfd9af0084ce5de">More...</a><br /></td></tr>
<tr class="separator:a1475f0750497f10e6dfd9af0084ce5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10efc09aa0d06509a1b86a8f0616886"><td class="memTemplParams" colspan="2">template&lt;bool must_be_unique = false, bool must_be_exact = false, typename A , typename B &gt; </td></tr>
<tr class="memitem:ab10efc09aa0d06509a1b86a8f0616886"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ab10efc09aa0d06509a1b86a8f0616886">requires</a> (not <a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a>&lt; A &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not <a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a>&lt; B &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not must_be_unique) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not <a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a>&lt; A &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not(<a class="el" href="namespaceOpenKalman.html#afbdfdebaaf3e96ae0c9fbe36ce3b2721">constant_matrix</a>&lt; B &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> const ant_diagonal_matrix&lt; B &gt;) <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a>&lt; B &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not must_be_exact) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not const ant_matrix&lt; A &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not const ant_diagonal_matrix&lt; B &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a2df14967a1282177068bd8aaff491e65">has_dynamic_dimensions</a>&lt; A &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a>(index_dimension_of_v&lt; A</td></tr>
<tr class="memdesc:ab10efc09aa0d06509a1b86a8f0616886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the equation AX = B for X, which may or may not be a unique solution.  <a href="namespaceOpenKalman.html#ab10efc09aa0d06509a1b86a8f0616886">More...</a><br /></td></tr>
<tr class="separator:ab10efc09aa0d06509a1b86a8f0616886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9e9bf0da26f8de73d2857881c418d1"><td class="memTemplParams" colspan="2"><a id="a0e9e9bf0da26f8de73d2857881c418d1"></a>
template&lt;indexible... Ts&gt; </td></tr>
<tr class="memitem:a0e9e9bf0da26f8de73d2857881c418d1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0e9e9bf0da26f8de73d2857881c418d1">requires</a> (sizeof...(Ts) &gt; 0) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a71866768ca1d2b98352a34f58eac26a4">vector_space_descriptors_may_match_with</a>&lt; Ts... &gt; const expr decltype(auto) sum(Ts &amp;&amp;...ts)</td></tr>
<tr class="memdesc:a0e9e9bf0da26f8de73d2857881c418d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element-by-element sum of one or more objects. <br /></td></tr>
<tr class="separator:a0e9e9bf0da26f8de73d2857881c418d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0ea18e74abb7e98eca12b32cfcdcd5"><td class="memTemplParams" colspan="2">template&lt;vector_space_descriptor... Ds, indexible Block, indexible... Blocks&gt; </td></tr>
<tr class="memitem:aff0ea18e74abb7e98eca12b32cfcdcd5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aff0ea18e74abb7e98eca12b32cfcdcd5">requires</a> (sizeof...(Ds) &gt;=std::max({index_count_v&lt; Block &gt;, index_count_v&lt; Blocks &gt;...})) const expr decltype(auto) tile(const std</td></tr>
<tr class="memdesc:aff0ea18e74abb7e98eca12b32cfcdcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix or tensor by tiling individual blocks.  <a href="namespaceOpenKalman.html#aff0ea18e74abb7e98eca12b32cfcdcd5">More...</a><br /></td></tr>
<tr class="separator:aff0ea18e74abb7e98eca12b32cfcdcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d1a2a695e2247ebce3e5ed48c4703b"><td class="memTemplParams" colspan="2">template&lt;indexible T, Layout layout = Layout::none, scalar_type Scalar = scalar_type_of_t&lt;T&gt;, indexible Arg&gt; </td></tr>
<tr class="memitem:a76d1a2a695e2247ebce3e5ed48c4703b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a76d1a2a695e2247ebce3e5ed48c4703b">requires</a> (layout !=<a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea47101375aa96fa02cfb1d55fd00af989">Layout::stride</a>) const expr <a class="el" href="namespaceOpenKalman.html#abd7388b89ddb8b8aa2c0e1be66900dee">writable</a> decltype(auto) to_dense_object(Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a76d1a2a695e2247ebce3e5ed48c4703b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the argument to a dense, writable matrix of a particular scalar type.  <a href="namespaceOpenKalman.html#a76d1a2a695e2247ebce3e5ed48c4703b">More...</a><br /></td></tr>
<tr class="separator:a76d1a2a695e2247ebce3e5ed48c4703b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c85109f94ecc1cdfee3cfa7fd7c271"><td class="memTemplParams" colspan="2">template&lt;Layout layout, scalar_type Scalar, indexible Arg&gt; </td></tr>
<tr class="memitem:ae6c85109f94ecc1cdfee3cfa7fd7c271"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ae6c85109f94ecc1cdfee3cfa7fd7c271">requires</a> (layout !=<a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea47101375aa96fa02cfb1d55fd00af989">Layout::stride</a>) const expr <a class="el" href="namespaceOpenKalman.html#abd7388b89ddb8b8aa2c0e1be66900dee">writable</a> decltype(auto) to_dense_object(Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:ae6c85109f94ecc1cdfee3cfa7fd7c271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the argument to a dense, writable matrix of a particular scalar type.  <a href="namespaceOpenKalman.html#ae6c85109f94ecc1cdfee3cfa7fd7c271">More...</a><br /></td></tr>
<tr class="separator:ae6c85109f94ecc1cdfee3cfa7fd7c271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3cd9b9bd51d5576d1546a97e7279c6"><td class="memTemplParams" colspan="2">template&lt;Layout layout = Layout::none, indexible Arg&gt; </td></tr>
<tr class="memitem:aca3cd9b9bd51d5576d1546a97e7279c6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aca3cd9b9bd51d5576d1546a97e7279c6">requires</a> (layout !=<a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea47101375aa96fa02cfb1d55fd00af989">Layout::stride</a>) const expr <a class="el" href="namespaceOpenKalman.html#abd7388b89ddb8b8aa2c0e1be66900dee">writable</a> decltype(auto) to_dense_object(Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:aca3cd9b9bd51d5576d1546a97e7279c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the argument to a dense, writable matrix with the same scalar type as the argument.  <a href="namespaceOpenKalman.html#aca3cd9b9bd51d5576d1546a97e7279c6">More...</a><br /></td></tr>
<tr class="separator:aca3cd9b9bd51d5576d1546a97e7279c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeedf8c4ba9661b52baf52ea75a7037"><td class="memTemplParams" colspan="2">template&lt;vector&lt; 0, Qualification::depends_on_dynamic_shape &gt; Arg&gt; </td></tr>
<tr class="memitem:acfeedf8c4ba9661b52baf52ea75a7037"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto) <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#acfeedf8c4ba9661b52baf52ea75a7037">to_diagonal</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:acfeedf8c4ba9661b52baf52ea75a7037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a column vector into a diagonal matrix.  <a href="namespaceOpenKalman.html#acfeedf8c4ba9661b52baf52ea75a7037">More...</a><br /></td></tr>
<tr class="separator:acfeedf8c4ba9661b52baf52ea75a7037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab091294cccdb99cde1e29c4192441baa"><td class="memTemplParams" colspan="2">template&lt;wrappable Arg&gt; </td></tr>
<tr class="memitem:ab091294cccdb99cde1e29c4192441baa"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ab091294cccdb99cde1e29c4192441baa">to_euclidean</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:ab091294cccdb99cde1e29c4192441baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the (potentially wrapped)vector space associated with index 0 to a Euclidean space for applying directional statistics.  <a href="namespaceOpenKalman.html#ab091294cccdb99cde1e29c4192441baa">More...</a><br /></td></tr>
<tr class="separator:ab091294cccdb99cde1e29c4192441baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccae583b05933bcbc9afff632b7be5f"><td class="memTemplParams" colspan="2">template&lt;indexible LibraryObject, indexible Arg&gt; </td></tr>
<tr class="memitem:a1ccae583b05933bcbc9afff632b7be5f"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a1ccae583b05933bcbc9afff632b7be5f">to_native_matrix</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a1ccae583b05933bcbc9afff632b7be5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If it isn't already, convert Arg to a native object in the library associated with LibraryObject.  <a href="namespaceOpenKalman.html#a1ccae583b05933bcbc9afff632b7be5f">More...</a><br /></td></tr>
<tr class="separator:a1ccae583b05933bcbc9afff632b7be5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853f3380f60f775ca40e8c0849f5678c"><td class="memTemplParams" colspan="2">template&lt;interface::count_indices_defined_for T&gt; </td></tr>
<tr class="memitem:a853f3380f60f775ca40e8c0849f5678c"><td class="memTemplItemLeft" align="right" valign="top">requires interface::get_vector_space_descriptor_defined_for&lt; T &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a853f3380f60f775ca40e8c0849f5678c">requires</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a853f3380f60f775ca40e8c0849f5678c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a tuple of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> items defining the dimensions of T.  <a href="namespaceOpenKalman.html#a853f3380f60f775ca40e8c0849f5678c">More...</a><br /></td></tr>
<tr class="separator:a853f3380f60f775ca40e8c0849f5678c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6968381bd677626dc7b09cf077e5cbcc"><td class="memTemplParams" colspan="2">template&lt;interface::count_indices_defined_for T&gt; </td></tr>
<tr class="memitem:a6968381bd677626dc7b09cf077e5cbcc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceOpenKalman.html#a8b8a5ca9cb2a660eb584981e1339b87a">index_value</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a6968381bd677626dc7b09cf077e5cbcc">count_indices</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a6968381bd677626dc7b09cf077e5cbcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of indices available to address the components of an <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> object.  <a href="namespaceOpenKalman.html#a6968381bd677626dc7b09cf077e5cbcc">More...</a><br /></td></tr>
<tr class="separator:a6968381bd677626dc7b09cf077e5cbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa438a707543cf69a916cca2a6762ee8c"><td class="memTemplParams" colspan="2"><a id="aa438a707543cf69a916cca2a6762ee8c"></a>
template&lt;typename T , index_value N = std::integral_constant&lt;std::size_t, 0&gt;&gt; </td></tr>
<tr class="memitem:aa438a707543cf69a916cca2a6762ee8c"><td class="memTemplItemLeft" align="right" valign="top">requires&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#aa438a707543cf69a916cca2a6762ee8c">requires</a> (T t, N n)</td></tr>
<tr class="memdesc:aa438a707543cf69a916cca2a6762ee8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the runtime dimensions of index N of <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> T. <br /></td></tr>
<tr class="separator:aa438a707543cf69a916cca2a6762ee8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1c07f9e38b6f117bc553d02fa52f85"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:a2d1c07f9e38b6f117bc553d02fa52f85"><td class="memTemplItemLeft" align="right" valign="top">requires&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2d1c07f9e38b6f117bc553d02fa52f85">requires</a> (T t)</td></tr>
<tr class="separator:a2d1c07f9e38b6f117bc553d02fa52f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132486ff23e0a9eb21cc145b382a3f06"><td class="memTemplParams" colspan="2"><a id="a132486ff23e0a9eb21cc145b382a3f06"></a>
template&lt;typename T , index_value N&gt; </td></tr>
<tr class="memitem:a132486ff23e0a9eb21cc145b382a3f06"><td class="memTemplItemLeft" align="right" valign="top">requires interface::get_vector_space_descriptor_defined_for&lt; T &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> constexpr detail::count_is_zero&lt; T &gt;::value <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a132486ff23e0a9eb21cc145b382a3f06">get_vector_space_descriptor</a> (const T &amp;t, const N &amp;n)</td></tr>
<tr class="memdesc:a132486ff23e0a9eb21cc145b382a3f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> object for index N of <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> object T. <br /></td></tr>
<tr class="separator:a132486ff23e0a9eb21cc145b382a3f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d3edfd0e8553eafbb1983c29491114"><td class="memTemplParams" colspan="2">template&lt;std::size_t N = 0, typename T &gt; </td></tr>
<tr class="memitem:a12d3edfd0e8553eafbb1983c29491114"><td class="memTemplItemLeft" align="right" valign="top">requires interface::get_vector_space_descriptor_defined_for&lt; T &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> constexpr detail::count_is_zero&lt; T &gt;::value <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a12d3edfd0e8553eafbb1983c29491114">get_vector_space_descriptor</a> (const T &amp;t)</td></tr>
<tr class="separator:a12d3edfd0e8553eafbb1983c29491114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4aa86d3ef5ab79a607ecb7ce06d466f"><td class="memTemplParams" colspan="2">template&lt;interface::count_indices_defined_for T&gt; </td></tr>
<tr class="memitem:af4aa86d3ef5ab79a607ecb7ce06d466f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#af4aa86d3ef5ab79a607ecb7ce06d466f">get_wrappable</a> (const T &amp;t)</td></tr>
<tr class="memdesc:af4aa86d3ef5ab79a607ecb7ce06d466f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether T is wrappable (i.e., all its dimensions other than potentially 0 are euclidean).  <a href="namespaceOpenKalman.html#af4aa86d3ef5ab79a607ecb7ce06d466f">More...</a><br /></td></tr>
<tr class="separator:af4aa86d3ef5ab79a607ecb7ce06d466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0a0786d9c0a6ca9f3a2edc2fc89bed"><td class="memTemplParams" colspan="2">template&lt;interface::count_indices_defined_for T&gt; </td></tr>
<tr class="memitem:a1e0a0786d9c0a6ca9f3a2edc2fc89bed"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a1e0a0786d9c0a6ca9f3a2edc2fc89bed">is_one_dimensional</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a1e0a0786d9c0a6ca9f3a2edc2fc89bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if T is a <a class="el" href="namespaceOpenKalman.html#a2dd99301266e3bb4f1d2d92b69b324ab">one_dimensional</a> at runtime.  <a href="namespaceOpenKalman.html#a1e0a0786d9c0a6ca9f3a2edc2fc89bed">More...</a><br /></td></tr>
<tr class="separator:a1e0a0786d9c0a6ca9f3a2edc2fc89bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae863fa1c417402776c130e558369c6d4"><td class="memTemplParams" colspan="2">template&lt;interface::count_indices_defined_for T&gt; </td></tr>
<tr class="memitem:ae863fa1c417402776c130e558369c6d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ae863fa1c417402776c130e558369c6d4">is_square_shaped</a> (const T &amp;t)</td></tr>
<tr class="memdesc:ae863fa1c417402776c130e558369c6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether an object is <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a> at runtime.  <a href="namespaceOpenKalman.html#ae863fa1c417402776c130e558369c6d4">More...</a><br /></td></tr>
<tr class="separator:ae863fa1c417402776c130e558369c6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f295961ec96698496f7ebbfd4de505e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N = 0, interface::count_indices_defined_for T&gt; </td></tr>
<tr class="memitem:a2f295961ec96698496f7ebbfd4de505e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a2f295961ec96698496f7ebbfd4de505e">is_vector</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a2f295961ec96698496f7ebbfd4de505e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if T is a <a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a> at runtime.  <a href="namespaceOpenKalman.html#a2f295961ec96698496f7ebbfd4de505e">More...</a><br /></td></tr>
<tr class="separator:a2f295961ec96698496f7ebbfd4de505e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5996abd144318dab61496c54bd6ecd"><td class="memTemplParams" colspan="2">template&lt;interface::count_indices_defined_for T&gt; </td></tr>
<tr class="memitem:a6f5996abd144318dab61496c54bd6ecd"><td class="memTemplItemLeft" align="right" valign="top">requires constexpr interface::get_vector_space_descriptor_defined_for&lt; T &gt; <a class="el" href="namespaceOpenKalman.html#a8b8a5ca9cb2a660eb584981e1339b87a">index_value</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a6f5996abd144318dab61496c54bd6ecd">tensor_order</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a6f5996abd144318dab61496c54bd6ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tensor order of T (i.e., the number of indices of dimension greater than 1).  <a href="namespaceOpenKalman.html#a6f5996abd144318dab61496c54bd6ecd">More...</a><br /></td></tr>
<tr class="separator:a6f5996abd144318dab61496c54bd6ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1397f4d7afcc945903cb94f2058064"><td class="memTemplParams" colspan="2">template&lt;interface::count_indices_defined_for... Ts&gt; </td></tr>
<tr class="memitem:a4a1397f4d7afcc945903cb94f2058064"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4a1397f4d7afcc945903cb94f2058064">vector_space_descriptors_match</a> (const Ts &amp;...ts)</td></tr>
<tr class="memdesc:a4a1397f4d7afcc945903cb94f2058064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if every set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> of a set of objects match.  <a href="namespaceOpenKalman.html#a4a1397f4d7afcc945903cb94f2058064">More...</a><br /></td></tr>
<tr class="separator:a4a1397f4d7afcc945903cb94f2058064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34b2cc15f9dbea2b3972dfeed9d0e91"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab34b2cc15f9dbea2b3972dfeed9d0e91"><td class="memTemplItemLeft" align="right" valign="top">requires&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ab34b2cc15f9dbea2b3972dfeed9d0e91">requires</a> (T t)</td></tr>
<tr class="separator:ab34b2cc15f9dbea2b3972dfeed9d0e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22044e4971a0bb5c7d30297c5c0c1a90"><td class="memTemplParams" colspan="2">template&lt;indexible T, Layout layout = Layout::none, scalar_type S = scalar_type_of_t&lt;T&gt;, std::integral auto... D&gt; </td></tr>
<tr class="memitem:a22044e4971a0bb5c7d30297c5c0c1a90"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a22044e4971a0bb5c7d30297c5c0c1a90">requires</a> ((std::is_integral_v&lt; decltype(D)&gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> D &gt;=0) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> ...) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(layout !</td></tr>
<tr class="memdesc:a22044e4971a0bb5c7d30297c5c0c1a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a dense, writable matrix, patterned on parameter T.  <a href="namespaceOpenKalman.html#a22044e4971a0bb5c7d30297c5c0c1a90">More...</a><br /></td></tr>
<tr class="separator:a22044e4971a0bb5c7d30297c5c0c1a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143fe997551f6511524861fa7a14e9ad"><td class="memTemplParams" colspan="2"><a id="a143fe997551f6511524861fa7a14e9ad"></a>
template&lt;scalar_constant Arg&gt; </td></tr>
<tr class="memitem:a143fe997551f6511524861fa7a14e9ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto) <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a143fe997551f6511524861fa7a14e9ad">get_scalar_constant_value</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:a143fe997551f6511524861fa7a14e9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the scalar value of a <a class="el" href="namespaceOpenKalman.html#a72829d83ccbc836bfb60d395cd4d5331">scalar_constant</a>. <br /></td></tr>
<tr class="separator:a143fe997551f6511524861fa7a14e9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14345f292887e27517c4ae21dfc23604"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a14345f292887e27517c4ae21dfc23604">from_euclidean_element</a> (const <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> auto &amp;t, const auto &amp;g, std::size_t local_index, std::size_t euclidean_start) requires requires(std</td></tr>
<tr class="memdesc:a14345f292887e27517c4ae21dfc23604"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of <code>to_euclidean_element</code>. Maps coordinates in Euclidean space back into modular space.  <a href="namespaceOpenKalman.html#a14345f292887e27517c4ae21dfc23604">More...</a><br /></td></tr>
<tr class="separator:a14345f292887e27517c4ae21dfc23604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24dfdc177b13cc45f0191a23c3f4830b"><td class="memTemplParams" colspan="2"><a id="a24dfdc177b13cc45f0191a23c3f4830b"></a>
template&lt;vector_space_descriptor T&gt; </td></tr>
<tr class="memitem:a24dfdc177b13cc45f0191a23c3f4830b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceOpenKalman.html#a8b8a5ca9cb2a660eb584981e1339b87a">index_value</a> auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a24dfdc177b13cc45f0191a23c3f4830b">get_dimension_size_of</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a24dfdc177b13cc45f0191a23c3f4830b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dimension of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> T. <br /></td></tr>
<tr class="separator:a24dfdc177b13cc45f0191a23c3f4830b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570fd6d4fef957a9b29c64dc11ba5c63"><td class="memTemplParams" colspan="2"><a id="a570fd6d4fef957a9b29c64dc11ba5c63"></a>
template&lt;vector_space_descriptor T&gt; </td></tr>
<tr class="memitem:a570fd6d4fef957a9b29c64dc11ba5c63"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a570fd6d4fef957a9b29c64dc11ba5c63">get_euclidean_dimension_size_of</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a570fd6d4fef957a9b29c64dc11ba5c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Euclidean dimension of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> T. <br /></td></tr>
<tr class="separator:a570fd6d4fef957a9b29c64dc11ba5c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242ab0b95d95d1cef60c73bcd669b99b"><td class="memTemplParams" colspan="2"><a id="a242ab0b95d95d1cef60c73bcd669b99b"></a>
template&lt;vector_space_descriptor T&gt; </td></tr>
<tr class="memitem:a242ab0b95d95d1cef60c73bcd669b99b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a242ab0b95d95d1cef60c73bcd669b99b">get_vector_space_descriptor_component_count_of</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a242ab0b95d95d1cef60c73bcd669b99b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of components of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> T. <br /></td></tr>
<tr class="separator:a242ab0b95d95d1cef60c73bcd669b99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285ca11466d477c078b9df28b4f0fb92"><td class="memTemplParams" colspan="2"><a id="a285ca11466d477c078b9df28b4f0fb92"></a>
template&lt;vector_space_descriptor T&gt; </td></tr>
<tr class="memitem:a285ca11466d477c078b9df28b4f0fb92"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a285ca11466d477c078b9df28b4f0fb92">get_vector_space_descriptor_is_euclidean</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a285ca11466d477c078b9df28b4f0fb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine, at runtime, whether <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> T is untyped. <br /></td></tr>
<tr class="separator:a285ca11466d477c078b9df28b4f0fb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41b180a0cc4fc25400b148416966af0"><td class="memTemplParams" colspan="2">template&lt;vector_space_descriptor T, index_value Offset, index_value Extent&gt; </td></tr>
<tr class="memitem:ac41b180a0cc4fc25400b148416966af0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ac41b180a0cc4fc25400b148416966af0">requires</a> (<a class="el" href="namespaceOpenKalman.html#a04ca7c438cbddb3fd487e299c4d185ea">dynamic_index_value</a>&lt; Offset &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> Offset::value &gt;=0) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(<a class="el" href="namespaceOpenKalman.html#a04ca7c438cbddb3fd487e299c4d185ea">dynamic_index_value</a>&lt; Extent &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> Extent</td></tr>
<tr class="memdesc:ac41b180a0cc4fc25400b148416966af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a slice of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> T.  <a href="namespaceOpenKalman.html#ac41b180a0cc4fc25400b148416966af0">More...</a><br /></td></tr>
<tr class="separator:ac41b180a0cc4fc25400b148416966af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ae054a928c412ebde383d1274645e8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a56ae054a928c412ebde383d1274645e8">get_wrapped_component</a> (const <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> auto &amp;t, const auto &amp;g, std::size_t local_index, std::size_t start) requires requires(std</td></tr>
<tr class="memdesc:a56ae054a928c412ebde383d1274645e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an element from a matrix or tensor object and wraps the result.  <a href="namespaceOpenKalman.html#a56ae054a928c412ebde383d1274645e8">More...</a><br /></td></tr>
<tr class="separator:a56ae054a928c412ebde383d1274645e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8e4069b6e4e19b55f854c27c67cd5b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a0b8e4069b6e4e19b55f854c27c67cd5b">set_wrapped_component</a> (const <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> auto &amp;t, const auto &amp;s, const auto &amp;g, const std::decay_t&lt; std::invoke_result_t&lt; decltype(g), std::size_t &gt;&gt; &amp;x, std::size_t local_index, std::size_t start) requires requires(std</td></tr>
<tr class="memdesc:a0b8e4069b6e4e19b55f854c27c67cd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a component and then perform any required wrapping.  <a href="namespaceOpenKalman.html#a0b8e4069b6e4e19b55f854c27c67cd5b">More...</a><br /></td></tr>
<tr class="separator:a0b8e4069b6e4e19b55f854c27c67cd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b649f52fb62a29f355e2d70dd85fbab"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a6b649f52fb62a29f355e2d70dd85fbab">to_euclidean_element</a> (const <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> auto &amp;t, const auto &amp;g, std::size_t euclidean_local_index, std::size_t start) requires requires(std</td></tr>
<tr class="memdesc:a6b649f52fb62a29f355e2d70dd85fbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps an element from coordinates in modular space to coordinates in Euclidean space.  <a href="namespaceOpenKalman.html#a6b649f52fb62a29f355e2d70dd85fbab">More...</a><br /></td></tr>
<tr class="separator:a6b649f52fb62a29f355e2d70dd85fbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad3939ca2912e042aac6a4fc704e2f1"><td class="memTemplParams" colspan="2">template&lt;fixed_vector_space_descriptor C, std::size_t N&gt; </td></tr>
<tr class="memitem:a7ad3939ca2912e042aac6a4fc704e2f1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a7ad3939ca2912e042aac6a4fc704e2f1">requires</a> (N !=<a class="el" href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">dynamic_size</a>) struct replicate_fixed_vector_space_descriptor</td></tr>
<tr class="memdesc:a7ad3939ca2912e042aac6a4fc704e2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replicate a set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> a given number of times.  <a href="namespaceOpenKalman.html#a7ad3939ca2912e042aac6a4fc704e2f1">More...</a><br /></td></tr>
<tr class="separator:a7ad3939ca2912e042aac6a4fc704e2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5c83f78a68c000f6365c4f1601eb22"><td class="memTemplParams" colspan="2">template&lt;gaussian_distribution D&gt; </td></tr>
<tr class="memitem:ada5c83f78a68c000f6365c4f1601eb22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ada5c83f78a68c000f6365c4f1601eb22">make_GaussianDistribution</a> (D &amp;&amp;dist)</td></tr>
<tr class="memdesc:ada5c83f78a68c000f6365c4f1601eb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution.  <a href="namespaceOpenKalman.html#ada5c83f78a68c000f6365c4f1601eb22">More...</a><br /></td></tr>
<tr class="separator:ada5c83f78a68c000f6365c4f1601eb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2f2b564ae42b7d10f3391acdc97546"><td class="memTemplParams" colspan="2">template&lt;std::uniform_random_bit_generator re = std::mt19937, typed_matrix M, typename Cov &gt; </td></tr>
<tr class="memitem:acd2f2b564ae42b7d10f3391acdc97546"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a>&lt; M &gt; and <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt; M, 1 &gt; and <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; Cov &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#acd2f2b564ae42b7d10f3391acdc97546">and</a> (<a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a>&lt; Cov &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>&lt; Cov &gt;) and(<a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; M</td></tr>
<tr class="memdesc:acd2f2b564ae42b7d10f3391acdc97546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution.  <a href="namespaceOpenKalman.html#acd2f2b564ae42b7d10f3391acdc97546">More...</a><br /></td></tr>
<tr class="separator:acd2f2b564ae42b7d10f3391acdc97546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad077f442dad48355cf9818572813a758"><td class="memTemplParams" colspan="2">template&lt;std::uniform_random_bit_generator re = std::mt19937, typed_matrix M, typename Cov &gt; </td></tr>
<tr class="memitem:ad077f442dad48355cf9818572813a758"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a>&lt; M &gt; and <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt; M, 1 &gt; and <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; Cov &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ad077f442dad48355cf9818572813a758">and</a> (<a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>&lt; Cov &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>&lt; Cov &gt;) and(index_dimension_of_v&lt; M</td></tr>
<tr class="memdesc:ad077f442dad48355cf9818572813a758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Gaussian distribution.  <a href="namespaceOpenKalman.html#ad077f442dad48355cf9818572813a758">More...</a><br /></td></tr>
<tr class="separator:ad077f442dad48355cf9818572813a758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1ed2a363bd8790676ea87e9ccb5029"><td class="memTemplParams" colspan="2">template&lt;typed_matrix M, covariance Cov, std::uniform_random_bit_generator re = std::mt19937&gt; </td></tr>
<tr class="memitem:a4d1ed2a363bd8790676ea87e9ccb5029"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a>&lt; M &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt; M, 1 &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; M, 0 &gt;, <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Cov, 0 &gt; &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a4d1ed2a363bd8790676ea87e9ccb5029">make_GaussianDistribution</a> ()</td></tr>
<tr class="memdesc:a4d1ed2a363bd8790676ea87e9ccb5029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default Gaussian distribution.  <a href="namespaceOpenKalman.html#a4d1ed2a363bd8790676ea87e9ccb5029">More...</a><br /></td></tr>
<tr class="separator:a4d1ed2a363bd8790676ea87e9ccb5029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecad8b8032d1d3565c353c5f839a9de"><td class="memTemplParams" colspan="2">template&lt;vector M, typename Cov , std::uniform_random_bit_generator re = std::mt19937&gt; </td></tr>
<tr class="memitem:abecad8b8032d1d3565c353c5f839a9de"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#abecad8b8032d1d3565c353c5f839a9de">requires</a> (<a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>&lt; M &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>&lt; M &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt; M</td></tr>
<tr class="memdesc:abecad8b8032d1d3565c353c5f839a9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a default Gaussian distribution.  <a href="namespaceOpenKalman.html#abecad8b8032d1d3565c353c5f839a9de">More...</a><br /></td></tr>
<tr class="separator:abecad8b8032d1d3565c353c5f839a9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cf2ac3a32ed621da82ac2973bcae51"><td class="memTemplParams" colspan="2"><a id="a52cf2ac3a32ed621da82ac2973bcae51"></a>
template&lt;fixed_vector_space_descriptor ... Cs, gaussian_distribution D&gt; </td></tr>
<tr class="memitem:a52cf2ac3a32ed621da82ac2973bcae51"><td class="memTemplItemLeft" align="right" valign="top">requires <a class="el" href="namespaceOpenKalman_1_1internal.html#a601527fae38b2760d48bb409307dcd88">internal::prefix_of</a>&lt; <a class="el" href="namespaceOpenKalman.html#a551efec16eae409b3b9c6ecaf7c06b34">concatenate_fixed_vector_space_descriptor_t</a>&lt; Cs... &gt;, typename DistributionTraits&lt; D &gt;::<a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt; auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a52cf2ac3a32ed621da82ac2973bcae51">split</a> (D &amp;&amp;d)</td></tr>
<tr class="memdesc:a52cf2ac3a32ed621da82ac2973bcae51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split distribution. <br /></td></tr>
<tr class="separator:a52cf2ac3a32ed621da82ac2973bcae51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90fee0db730e87c4bf758991e2e3d0c"><td class="memTemplParams" colspan="2"><a id="ad90fee0db730e87c4bf758991e2e3d0c"></a>
template&lt;scalar_type ... Args&gt; </td></tr>
<tr class="memitem:ad90fee0db730e87c4bf758991e2e3d0c"><td class="memTemplItemLeft" align="right" valign="top">requires(<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; RowCoefficients &gt;==index_dimension_of_v&lt; NestedMatrix, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not std&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ad90fee0db730e87c4bf758991e2e3d0c">requires</a> (sizeof...(Args) &gt; 0) <a class="el" href="namespaceOpenKalman.html#a13ce51f24958dff5bdd6adcdf5390e1a">Mean</a>(const Args ...) -&gt; <a class="el" href="namespaceOpenKalman.html#a13ce51f24958dff5bdd6adcdf5390e1a">Mean</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1Dimensions.html">Dimensions</a>&lt; sizeof...(Args)&gt;, <a class="el" href="namespaceOpenKalman_1_1Eigen3.html#a9e6da054dc2b4902ca471e0957c0a5ac">Eigen3::eigen_matrix_t</a>&lt; std::common_type_t&lt; Args... &gt;, sizeof...(Args), 1 &gt;&gt;</td></tr>
<tr class="memdesc:ad90fee0db730e87c4bf758991e2e3d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, deduce a single-column mean with all Axis coefficients. <br /></td></tr>
<tr class="separator:ad90fee0db730e87c4bf758991e2e3d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aa3bd3fe43f3b700829a0e9d6a71a5"><td class="memTemplParams" colspan="2"><a id="a08aa3bd3fe43f3b700829a0e9d6a71a5"></a>
template&lt;scalar_type ... Args&gt; </td></tr>
<tr class="memitem:a08aa3bd3fe43f3b700829a0e9d6a71a5"><td class="memTemplItemLeft" align="right" valign="top">requires(<a class="el" href="namespaceOpenKalman.html#a399b0547d1b74a66dd68157b927b3e5d">euclidean_dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;==index_dimension_of_v&lt; NestedMatrix, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not std&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a08aa3bd3fe43f3b700829a0e9d6a71a5">requires</a> (sizeof...(Args) &gt; 0) <a class="el" href="namespaceOpenKalman.html#a0ddc3d4101bf4f5e66a21a3b52cca3cb">EuclideanMean</a>(const Args ...) -&gt; <a class="el" href="namespaceOpenKalman.html#a0ddc3d4101bf4f5e66a21a3b52cca3cb">EuclideanMean</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1Dimensions.html">OpenKalman::Dimensions</a>&lt; sizeof...(Args)&gt;, <a class="el" href="namespaceOpenKalman_1_1Eigen3.html#a9e6da054dc2b4902ca471e0957c0a5ac">Eigen3::eigen_matrix_t</a>&lt; std::common_type_t&lt; Args... &gt;, sizeof...(Args), 1 &gt;&gt;</td></tr>
<tr class="memdesc:a08aa3bd3fe43f3b700829a0e9d6a71a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, construct a single-column Euclidean mean. <br /></td></tr>
<tr class="separator:a08aa3bd3fe43f3b700829a0e9d6a71a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c36ecda17bc479af8b7495a592d077f"><td class="memTemplParams" colspan="2"><a id="a5c36ecda17bc479af8b7495a592d077f"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(scalar_type&lt; Args &gt; and ...) and(sizeof...(Args) &gt; 0) and(sizeof...(Args)==static_cast&lt; std::size_t &gt;(internal::constexpr_sqrt(sizeof...(Args))) *static_cast&lt; std::size_t &gt;(internal::constexpr_sqrt(sizeof...(Args)))), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a5c36ecda17bc479af8b7495a592d077f"><td class="memTemplItemLeft" align="right" valign="top">requires(<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;==index_dimension_of_v&lt; NestedMatrix, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not std&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a5c36ecda17bc479af8b7495a592d077f">Covariance</a> (const Args &amp;...) -&gt; Covariance&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1Dimensions.html">Dimensions</a>&lt; static_cast&lt; std::size_t &gt;(<a class="el" href="namespaceOpenKalman_1_1internal.html#a1c87f70694336b3c7026c56b8c51f93e">internal::constexpr_sqrt</a>(sizeof...(Args)))&gt;, <a class="el" href="namespaceOpenKalman.html#af0f4a7708985c78ea8155a7e2dc9905c">SelfAdjointMatrix</a>&lt; <a class="el" href="namespaceOpenKalman_1_1Eigen3.html#a9e6da054dc2b4902ca471e0957c0a5ac">Eigen3::eigen_matrix_t</a>&lt; std::common_type_t&lt; Args... &gt;, static_cast&lt; std::size_t &gt;(<a class="el" href="namespaceOpenKalman_1_1internal.html#a1c87f70694336b3c7026c56b8c51f93e">internal::constexpr_sqrt</a>(sizeof...(Args))), static_cast&lt; std::size_t &gt;(<a class="el" href="namespaceOpenKalman_1_1internal.html#a1c87f70694336b3c7026c56b8c51f93e">internal::constexpr_sqrt</a>(sizeof...(Args)))&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a5c36ecda17bc479af8b7495a592d077f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, derive a square, self-adjoint matrix. <br /></td></tr>
<tr class="separator:a5c36ecda17bc479af8b7495a592d077f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77b7a37e1c74ba1cb6734e033bae609"><td class="memTemplParams" colspan="2"><a id="af77b7a37e1c74ba1cb6734e033bae609"></a>
template&lt;typename ... Args, std::enable_if_t&lt;(scalar_type&lt; Args &gt; and ...) and(sizeof...(Args) &gt; 0) and(sizeof...(Args)==static_cast&lt; std::size_t &gt;(internal::constexpr_sqrt(sizeof...(Args))) *static_cast&lt; std::size_t &gt;(internal::constexpr_sqrt(sizeof...(Args)))), int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af77b7a37e1c74ba1cb6734e033bae609"><td class="memTemplItemLeft" align="right" valign="top">requires(<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;==index_dimension_of_v&lt; NestedMatrix, 0 &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(not std&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#af77b7a37e1c74ba1cb6734e033bae609">SquareRootCovariance</a> (const Args &amp;...) -&gt; SquareRootCovariance&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1Dimensions.html">Dimensions</a>&lt; static_cast&lt; std::size_t &gt;(<a class="el" href="namespaceOpenKalman_1_1internal.html#a1c87f70694336b3c7026c56b8c51f93e">internal::constexpr_sqrt</a>(sizeof...(Args)))&gt;, TriangularMatrix&lt; <a class="el" href="namespaceOpenKalman_1_1Eigen3.html#a9e6da054dc2b4902ca471e0957c0a5ac">Eigen3::eigen_matrix_t</a>&lt; std::common_type_t&lt; Args... &gt;, static_cast&lt; std::size_t &gt;(<a class="el" href="namespaceOpenKalman_1_1internal.html#a1c87f70694336b3c7026c56b8c51f93e">internal::constexpr_sqrt</a>(sizeof...(Args))), static_cast&lt; std::size_t &gt;(<a class="el" href="namespaceOpenKalman_1_1internal.html#a1c87f70694336b3c7026c56b8c51f93e">internal::constexpr_sqrt</a>(sizeof...(Args)))&gt;&gt;&gt;</td></tr>
<tr class="memdesc:af77b7a37e1c74ba1cb6734e033bae609"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the arguments are a sequence of scalars, derive a square, lower triangular matrix. <br /></td></tr>
<tr class="separator:af77b7a37e1c74ba1cb6734e033bae609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memTemplParams" colspan="2"><a id="a82c83df8efb22e49dd3e6f5ea119caef"></a>
template&lt;typename OutputCoefficients , typename In , typename ... Perturbations&gt; </td></tr>
<tr class="memitem:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a82c83df8efb22e49dd3e6f5ea119caef">zero_hessian</a> ()</td></tr>
<tr class="memdesc:a82c83df8efb22e49dd3e6f5ea119caef"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple of zero-filled arrays of Hessian matrices, based on the input and each perturbation term. <br /></td></tr>
<tr class="separator:a82c83df8efb22e49dd3e6f5ea119caef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memTemplParams" colspan="2"><a id="ac32f98e2f9ea9d21f58ac57b49ee011e"></a>
template&lt;typename OutputCoefficients , typename In , typename ... Perturbations&gt; </td></tr>
<tr class="memitem:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#ac32f98e2f9ea9d21f58ac57b49ee011e">zero_hessian</a> (In &amp;&amp;, Perturbations &amp;&amp;...)</td></tr>
<tr class="memdesc:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tuple of zero-filled arrays of Hessian matrices, based on the input and each perturbation term. <br /></td></tr>
<tr class="separator:ac32f98e2f9ea9d21f58ac57b49ee011e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d55b0a864c70e600ef1985f436eaf2"><td class="memTemplParams" colspan="2">template&lt;fixed_vector_space_descriptor InputCoefficients, fixed_vector_space_descriptor OutputCoefficients, typed_matrix_nestable TransformationMatrix, typed_matrix_nestable ... PerturbationTransformationMatrices&gt; </td></tr>
<tr class="memitem:a49d55b0a864c70e600ef1985f436eaf2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenKalman.html#a49d55b0a864c70e600ef1985f436eaf2">requires</a> (index_dimension_of_v&lt; TransformationMatrix, 0 &gt;==<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; OutputCoefficients &gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a>(index_dimension_of_v&lt; TransformationMatrix</td></tr>
<tr class="memdesc:a49d55b0a864c70e600ef1985f436eaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear tests from one single-column vector to another.  <a href="namespaceOpenKalman.html#a49d55b0a864c70e600ef1985f436eaf2">More...</a><br /></td></tr>
<tr class="separator:a49d55b0a864c70e600ef1985f436eaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1DiagonalMatrix.html">DiagonalMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A diagonal matrix or tensor.  <a href="structOpenKalman_1_1DiagonalMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1FromEuclideanExpr.html">FromEuclideanExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression that transforms angular or other modular vector space descriptors back from Euclidean space.  <a href="structOpenKalman_1_1FromEuclideanExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1pattern__matrix__of.html">pattern_matrix_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native matrix on which an <a class="el" href="namespaceOpenKalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> matrix adapter is patterned.  <a href="structOpenKalman_1_1pattern__matrix__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1dynamic__index__count.html">dynamic_index_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of indices of T in which the dimensions are dynamic.  <a href="structOpenKalman_1_1dynamic__index__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1hermitian__adapter__type__of.html">hermitian_adapter_type_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The TriangleType associated with the storage triangle of one or more matrices.  <a href="structOpenKalman_1_1hermitian__adapter__type__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1index__count.html">index_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum number of indices need to access all the components of an object.  <a href="structOpenKalman_1_1index__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1index__dimension__of.html">index_dimension_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension of an index for a matrix, expression, or array.  <a href="structOpenKalman_1_1index__dimension__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1layout__of.html">layout_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The row dimension of a matrix, expression, or array.  <a href="structOpenKalman_1_1layout__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1max__tensor__order.html">max_tensor_order</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of indices of structure T of size other than 1 (including any dynamic indices).  <a href="structOpenKalman_1_1max__tensor__order.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1nested__object__of.html">nested_object_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper type's nested object type, if it exists.  <a href="structOpenKalman_1_1nested__object__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1scalar__type__of.html">scalar_type_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type scalar type (e.g., std::float, std::double, std::complex&lt;double&gt;) of a tensor.  <a href="structOpenKalman_1_1scalar__type__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1scalar__type__of_3_01T_01_4.html">scalar_type_of&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1triangle__type__of.html">triangle_type_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The common <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a> associated with a set of <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular matrices</a>.  <a href="structOpenKalman_1_1triangle__type__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1vector__space__descriptor__of.html">vector_space_descriptor_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> for index N of object T.  <a href="structOpenKalman_1_1vector__space__descriptor__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1static__range__size.html">static_range_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The static size of a range (e.g., an index range). If this value is not static, the result is <a class="el" href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514" title="A constant indicating that a size or index is dynamic.">OpenKalman::dynamic_size</a>.  <a href="structOpenKalman_1_1static__range__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1static__range__size_3_01T_00_01std_1_1enable__if__t_3_01detail_1_1is__sized_4c6f3b6b73cebe4c0fbfeb80307a91be.html">static_range_size&lt; T, std::enable_if_t&lt; detail::is_sized_range&lt; std::decay_t&lt; T &gt; &gt;::value and detail::static_range_size_impl&lt; std::decay_t&lt; T &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1static__range__size_3_01T_00_01std_1_1enable__if__t_3_01detail_1_1is__sized_e333a5a410f48f18498d2f3c4b5505d9.html">static_range_size&lt; T, std::enable_if_t&lt; detail::is_sized_range&lt; std::decay_t&lt; T &gt; &gt;::value and(not detail::static_range_size_impl&lt; std::decay_t&lt; T &gt;&gt;::value)&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1concatenate__fixed__vector__space__descriptor.html">concatenate_fixed_vector_space_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate any number of FixedDescriptor&lt;...&gt; types.  <a href="structOpenKalman_1_1concatenate__fixed__vector__space__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1canonical__fixed__vector__space__descriptor.html">canonical_fixed_vector_space_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce a <a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a> into its expanded canonical form.  <a href="structOpenKalman_1_1canonical__fixed__vector__space__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1reverse__fixed__vector__space__descriptor.html">reverse_fixed_vector_space_descriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the order of a <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a>.  <a href="structOpenKalman_1_1reverse__fixed__vector__space__descriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1dimension__difference__of.html">dimension_difference_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> object when tensors having respective vector_space_descriptor T are subtracted.  <a href="structOpenKalman_1_1dimension__difference__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1dimension__size__of.html">dimension_size_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension size of a set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a>.  <a href="structOpenKalman_1_1dimension__size__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1euclidean__dimension__size__of.html">euclidean_dimension_size_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dimension size of a set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> if it is transformed into Euclidean space.  <a href="structOpenKalman_1_1euclidean__dimension__size__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1uniform__fixed__vector__space__descriptor__component__of.html">uniform_fixed_vector_space_descriptor_component_of</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a <a class="el" href="namespaceOpenKalman.html#a0f5e34c97d63bb06f980344d91524410">uniform_fixed_vector_space_descriptor</a>, <code>type</code> is an alias for the uniform component.  <a href="structOpenKalman_1_1uniform__fixed__vector__space__descriptor__component__of.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1vector__space__component__count.html">vector_space_component_count</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of atomic component parts of a set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a>.  <a href="structOpenKalman_1_1vector__space__component__count.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1MixtureOfContinuousDistributions.html">MixtureOfContinuousDistributions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1ParticleDistribution.html">ParticleDistribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribution of particles.  <a href="structOpenKalman_1_1ParticleDistribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1KalmanFilter.html">KalmanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using one or more statistical transforms.  <a href="structOpenKalman_1_1KalmanFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1KalmanFilter_3_01Transform_01_4.html">KalmanFilter&lt; Transform &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using the same transform for the process and the measurement.  <a href="structOpenKalman_1_1KalmanFilter_3_01Transform_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1KalmanFilter_3_01ProcessTransform_00_01MeasurementTransform_01_4.html">KalmanFilter&lt; ProcessTransform, MeasurementTransform &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Kalman filter, using a different statistical transform for the process and the measurement.  <a href="structOpenKalman_1_1KalmanFilter_3_01ProcessTransform_00_01MeasurementTransform_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1Transformation.html">Transformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tests from one single-column vector to another.  <a href="structOpenKalman_1_1Transformation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1IdentityTransform.html">IdentityTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An identity transform from one statistical distribution to another.  <a href="structOpenKalman_1_1IdentityTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenKalman_1_1LinearizedTransform.html">LinearizedTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linearized transform, using a 1st or 2nd order Taylor approximation of a linear tests.  <a href="classOpenKalman_1_1LinearizedTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenKalman_1_1LinearTransform.html">LinearTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A linear tests from one statistical distribution to another.  <a href="classOpenKalman_1_1LinearTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1MonteCarloTransform.html">MonteCarloTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Monte Carlo transform from one Gaussian distribution to another.  <a href="structOpenKalman_1_1MonteCarloTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1RecursiveLeastSquaresTransform.html">RecursiveLeastSquaresTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates a recursive least squares error distribution of parameters, with a forgetting factor . Useful for parameter estimation, where the parameter is expected to possibly drift over time.  <a href="structOpenKalman_1_1RecursiveLeastSquaresTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1CubaturePoints.html">CubaturePoints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a cubature points transform.  <a href="structOpenKalman_1_1CubaturePoints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1SphericalSimplex.html">SphericalSimplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical simplex sigma points, as implemented in, e.g., Simon J. Julier. The spherical simplex unscented tests. In Proceedings of American Control Conference, Denver, Colorado, pages 24302434, 2003.  <a href="structOpenKalman_1_1SphericalSimplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1Unscented.html">Unscented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled symmetric sigma points.  <a href="structOpenKalman_1_1Unscented.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1UnscentedParametersStateEstimation.html">UnscentedParametersStateEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structOpenKalman_1_1Unscented.html" title="Scaled symmetric sigma points.">Unscented</a> parameters for use in state estimation (the default).  <a href="structOpenKalman_1_1UnscentedParametersStateEstimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1UnscentedParametersParameterEstimation.html">UnscentedParametersParameterEstimation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structOpenKalman_1_1Unscented.html" title="Scaled symmetric sigma points.">Unscented</a> parameters for use in parameter estimation.  <a href="structOpenKalman_1_1UnscentedParametersParameterEstimation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOpenKalman_1_1SamplePointsTransform.html">SamplePointsTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaled points transform. Compatible with unscented transform and cubature transform.  <a href="structOpenKalman_1_1SamplePointsTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The namespace for all OpenKalman-specific classes and methods. </p>
</div><h2 class="groupheader">Variable Documentation</h2>
<a id="ad731e2f7b2bff8ebbfa618a8e515c10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad731e2f7b2bff8ebbfa618a8e515c10e">&#9670;&nbsp;</a></span>all_fixed_indices_are_euclidean</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::all_fixed_indices_are_euclidean</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    indexible&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> (detail::all_fixed_indices_are_euclidean_impl&lt;T&gt;(std::make_index_sequence&lt;index_count_v&lt;T&gt;&gt; {}))</div>
<div class="ttc" id="anamespaceOpenKalman_1_1internal_html_a53169174d184acbdedc1cc4ea339a542"><div class="ttname"><a href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">OpenKalman::internal::and</a></div><div class="ttdeci">requires case1or2&lt; Derived, NestedMatrix &gt; and(not self_contained&lt; NestedMatrix &gt;) struct CovarianceBase&lt; Derived</div><div class="ttdoc">Base of Covariance and SquareRootCovariance classes (Case 2).</div></div>
</div><!-- fragment --><p>No fixed_size index of T is modular (e.g., Angle, Polar, Spherical, etc.). </p>

<p class="definition">Definition at line <a class="el" href="all__fixed__indices__are__euclidean_8hpp_source.html#l00036">36</a> of file <a class="el" href="all__fixed__indices__are__euclidean_8hpp_source.html">all_fixed_indices_are_euclidean.hpp</a>.</p>

</div>
</div>
<a id="a8118548e58d6571ae37572fc5e04206d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8118548e58d6571ae37572fc5e04206d">&#9670;&nbsp;</a></span>atomic_fixed_vector_space_descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::atomic_fixed_vector_space_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    fixed_vector_space_descriptor&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> (not composite_vector_space_descriptor&lt;T&gt;)</div>
</div><!-- fragment --><p>These <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> objects are suitable for incorporation in <a class="el" href="namespaceOpenKalman.html#ab07fe14df356f0f5e28afcfc7c47ad86">composite_vector_space_descriptor</a>. </p>

<p class="definition">Definition at line <a class="el" href="atomic__fixed__vector__space__descriptor_8hpp_source.html#l00028">28</a> of file <a class="el" href="atomic__fixed__vector__space__descriptor_8hpp_source.html">atomic_fixed_vector_space_descriptor.hpp</a>.</p>

</div>
</div>
<a id="a14db5d6f9c808b45eb7f9e8bb78ab5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14db5d6f9c808b45eb7f9e8bb78ab5d6">&#9670;&nbsp;</a></span>cholesky_form</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::cholesky_form = (not <a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a>&lt;T&gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not <a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a>&lt;<a class="el" href="namespaceOpenKalman.html#a03b16f3264522ab5b6be8215b82b7e9d">nested_object_of_t</a>&lt;T&gt;&gt;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If this is true, then nested_object_of_t&lt;T&gt; is true. </p>

<p class="definition">Definition at line <a class="el" href="object-types_8hpp_source.html#l00220">220</a> of file <a class="el" href="object-types_8hpp_source.html">object-types.hpp</a>.</p>

</div>
</div>
<a id="ab5e3e6ab58b992bd11790bba514bd032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e3e6ab58b992bd11790bba514bd032">&#9670;&nbsp;</a></span>compatible_with_vector_space_descriptors</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::compatible_with_vector_space_descriptors</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    indexible&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> (vector_space_descriptor&lt;Ds&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> ...) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">      detail::compatible_impl&lt;T, Ds...&gt;(std::index_sequence_for&lt;Ds...&gt;{})</div>
</div><!-- fragment --><p>If T has a fixed number of indices, then any trailing indices beyond the set of Ds must be compatible with Dimensions&lt;1&gt;. </p>

<p class="definition">Definition at line <a class="el" href="compatible__with__vector__space__descriptors_8hpp_source.html#l00051">51</a> of file <a class="el" href="compatible__with__vector__space__descriptors_8hpp_source.html">compatible_with_vector_space_descriptors.hpp</a>.</p>

</div>
</div>
<a id="ab07fe14df356f0f5e28afcfc7c47ad86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07fe14df356f0f5e28afcfc7c47ad86">&#9670;&nbsp;</a></span>composite_vector_space_descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::composite_vector_space_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    vector_space_descriptor&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> detail::is_composite_vector_space_descriptor&lt;std::decay_t&lt;T&gt;&gt;::value</div>
</div><!-- fragment --><p>A composite <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> object is a container for other <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a>, and can either be FixedDescriptor or DynamicDescriptor. </p><dl class="section see"><dt>See also</dt><dd>FixedDescriptor, DynamicDescriptor. </dd></dl>

<p class="definition">Definition at line <a class="el" href="composite__vector__space__descriptor_8hpp_source.html#l00045">45</a> of file <a class="el" href="composite__vector__space__descriptor_8hpp_source.html">composite_vector_space_descriptor.hpp</a>.</p>

</div>
</div>
<a id="ac7d4806449fe50fb0c787b48fe79a439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d4806449fe50fb0c787b48fe79a439">&#9670;&nbsp;</a></span>constant_diagonal_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , ConstantType c = ConstantType::any&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::constant_diagonal_matrix</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    indexible&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> scalar_constant&lt;constant_diagonal_coefficient&lt;T&gt;, c&gt;</div>
</div><!-- fragment --><p>A constant diagonal matrix is also a <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>. It is not necessarily square. If T is a rank &gt;2 tensor, every rank-2 slice comprising dimensions 0 and 1 must be constant diagonal matrix. </p>

<p class="definition">Definition at line <a class="el" href="constant__diagonal__matrix_8hpp_source.html#l00029">29</a> of file <a class="el" href="constant__diagonal__matrix_8hpp_source.html">constant_diagonal_matrix.hpp</a>.</p>

</div>
</div>
<a id="a0f76b1d29292737f93f8ad1918b52e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f76b1d29292737f93f8ad1918b52e6e">&#9670;&nbsp;</a></span>diagonal_adapter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::diagonal_adapter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= interface::indexible_object_traits&lt;std::decay_t&lt;T&gt;&gt;::template is_triangular&lt;TriangleType::diagonal&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    vector&lt;nested_object_of_t&lt;T&gt;, N&gt;</div>
</div><!-- fragment --><p>This is an adapter that takes a <a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a> and produces a <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>. Components outside the diagonal are zero. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or tensor. </td></tr>
    <tr><td class="paramname">N</td><td>An index designating the "large" index of the vector (0 for a column vector, 1 for a row vector) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="diagonal__adapter_8hpp_source.html#l00044">44</a> of file <a class="el" href="diagonal__adapter_8hpp_source.html">diagonal_adapter.hpp</a>.</p>

</div>
</div>
<a id="aabd606b45e391ddbb67fa785798b1a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd606b45e391ddbb67fa785798b1a89">&#9670;&nbsp;</a></span>diagonal_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::diagonal_matrix</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    triangular_matrix&lt;T, TriangleType::diagonal&gt;</div>
</div><!-- fragment --><p>A diagonal matrix has zero components everywhere except the main diagonal. It is not necessarily square. For rank &gt;2 tensors, every rank-2 slice comprising dimensions 0 and 1 must be diagonal. </p><dl class="section note"><dt>Note</dt><dd>A <a class="el" href="namespaceOpenKalman.html#a0f76b1d29292737f93f8ad1918b52e6e">diagonal_adapter</a> is an diagonal matrix, but not all diagonal matrices are diagonal adapters. </dd></dl>

<p class="definition">Definition at line <a class="el" href="diagonal__matrix_8hpp_source.html#l00030">30</a> of file <a class="el" href="diagonal__matrix_8hpp_source.html">diagonal_matrix.hpp</a>.</p>

</div>
</div>
<a id="acb4ff0c32c70ea24cfc42faaa4ae58d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4ff0c32c70ea24cfc42faaa4ae58d2">&#9670;&nbsp;</a></span>dimension_size_of_index_is</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t index, std::size_t value, Qualification b = Qualification::unqualified&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::dimension_size_of_index_is</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (index_dimension_of_v&lt;T, index&gt; == value) <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    (b == Qualification::depends_on_dynamic_shape <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> (value == <a class="code" href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">dynamic_size</a> <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> dynamic_dimension&lt;T, index&gt;))</div>
<div class="ttc" id="anamespaceOpenKalman_html_a0f663d3bacbc3dc52fb0eb3c0412b514"><div class="ttname"><a href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">OpenKalman::dynamic_size</a></div><div class="ttdeci">constexpr std::size_t dynamic_size</div><div class="ttdoc">A constant indicating that a size or index is dynamic.</div><div class="ttdef"><b>Definition:</b> <a href="global-definitions_8hpp_source.html#l00033">global-definitions.hpp:33</a></div></div>
<div class="ttc" id="anamespaceOpenKalman_html_a689b926c307aee8a9b8c177b1c7a389f"><div class="ttname"><a href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">OpenKalman::or</a></div><div class="ttdeci">requires vector&lt; Arg &gt; or(not diagonal_matrix&lt; Arg &gt;) explicit DiagonalMatrix(Arg &amp;&amp;) -&gt; DiagonalMatrix&lt; passable_t&lt; Arg &gt;&gt;</div><div class="ttdoc">Deduce DiagonalMatrix template parameters for a column vector.</div></div>
</div><!-- fragment --><p>If <code>b == <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30" title="The property is not ruled out and depends on the dynamic shape.">Qualification::depends_on_dynamic_shape</a></code>, then the concept will apply if there is a possibility that the specified index of <code>T</code> is <code>value</code>. </p>

<p class="definition">Definition at line <a class="el" href="dimension__size__of__index__is_8hpp_source.html#l00042">42</a> of file <a class="el" href="dimension__size__of__index__is_8hpp_source.html">dimension_size_of_index_is.hpp</a>.</p>

</div>
</div>
<a id="a9cbebc790f8ee12c06f75126504fd1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbebc790f8ee12c06f75126504fd1e2">&#9670;&nbsp;</a></span>dynamic_difference</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::ptrdiff_t OpenKalman::dynamic_difference = std::numeric_limits&lt;std::ptrdiff_t&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A dynamic difference can be set, or change, during runtime and is not known at compile time. </p>

<p class="definition">Definition at line <a class="el" href="global-definitions_8hpp_source.html#l00041">41</a> of file <a class="el" href="global-definitions_8hpp_source.html">global-definitions.hpp</a>.</p>

</div>
</div>
<a id="a6e91b2f6875a87b261fa4929a5ab00c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e91b2f6875a87b261fa4929a5ab00c8">&#9670;&nbsp;</a></span>dynamic_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::dynamic_dimension = <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a>&lt;T&gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> (index_dimension_of_v&lt;T, N&gt; == <a class="el" href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">dynamic_size</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The matrix library interface will specify this for native matrices and expressions. </p>

<p class="definition">Definition at line <a class="el" href="dynamic__dimension_8hpp_source.html#l00041">41</a> of file <a class="el" href="dynamic__dimension_8hpp_source.html">dynamic_dimension.hpp</a>.</p>

</div>
</div>
<a id="a0f663d3bacbc3dc52fb0eb3c0412b514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f663d3bacbc3dc52fb0eb3c0412b514">&#9670;&nbsp;</a></span>dynamic_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t OpenKalman::dynamic_size = std::numeric_limits&lt;std::size_t&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A dynamic size or index can be set, or change, during runtime and is not known at compile time. </p>

<p class="definition">Definition at line <a class="el" href="global-definitions_8hpp_source.html#l00033">33</a> of file <a class="el" href="global-definitions_8hpp_source.html">global-definitions.hpp</a>.</p>

</div>
</div>
<a id="a31eae8386d50ed98dc96326732ef9234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eae8386d50ed98dc96326732ef9234">&#9670;&nbsp;</a></span>dynamic_vector_space_descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::dynamic_vector_space_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (not fixed_vector_space_descriptor&lt;T&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    requires(<span class="keyword">const</span> dynamic_vector_space_descriptor_traits&lt;std::decay_t&lt;T&gt;&gt;&amp; t) {</div>
<div class="line">      {t.get_size()} -&gt; std::convertible_to&lt;std::size_t&gt;;</div>
<div class="line">      {t.get_euclidean_size()} -&gt; std::convertible_to&lt;std::size_t&gt;;</div>
<div class="line">      {t.get_component_count()} -&gt; std::convertible_to&lt;std::size_t&gt;;</div>
<div class="line">      {t.is_euclidean()} -&gt; std::convertible_to&lt;bool&gt;;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>This includes any object for which dynamic_vector_space_descriptor_traits is defined. </p>

<p class="definition">Definition at line <a class="el" href="dynamic__vector__space__descriptor_8hpp_source.html#l00046">46</a> of file <a class="el" href="dynamic__vector__space__descriptor_8hpp_source.html">dynamic_vector_space_descriptor.hpp</a>.</p>

</div>
</div>
<a id="a4a95b16bcf85246cc892ddf51cc9ddfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a95b16bcf85246cc892ddf51cc9ddfa">&#9670;&nbsp;</a></span>element_gettable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::element_gettable</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (N == <a class="code" href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">dynamic_size</a> <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> N &gt;= index_count_v&lt;T&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    interface::get_component_defined_for&lt;T, T, std::array&lt;std::size_t, index_count&lt;T&gt;::value&gt;&gt;</div>
</div><!-- fragment --><p>This concept should include anything for which get_component(...) is properly defined with N std::size_t arguments. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceOpenKalman.html#a468e4521e756fcbe5b3a2306513e54cc" title="Get a component of an object at a particular set of indices.">get_component</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="element__gettable_8hpp_source.html#l00033">33</a> of file <a class="el" href="element__gettable_8hpp_source.html">element_gettable.hpp</a>.</p>

</div>
</div>
<a id="a7f7ac95c22475788a1bc2adf9315ba5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7ac95c22475788a1bc2adf9315ba5d">&#9670;&nbsp;</a></span>equivalent_to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::equivalent_to</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    (fixed_vector_space_descriptor&lt;Ts&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> ...) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> <a class="code" href="namespaceOpenKalman.html#a34d179caf50325236f04ae3778c02519">maybe_equivalent_to</a>&lt;Ts...&gt;</div>
<div class="ttc" id="anamespaceOpenKalman_html_a34d179caf50325236f04ae3778c02519"><div class="ttname"><a href="namespaceOpenKalman.html#a34d179caf50325236f04ae3778c02519">OpenKalman::maybe_equivalent_to</a></div><div class="ttdeci">concept maybe_equivalent_to</div><div class="ttdoc">Specifies that a set of vector_space_descriptor objects may be equivalent based on what is known at c...</div><div class="ttdef"><b>Definition:</b> <a href="maybe__equivalent__to_8hpp_source.html#l00079">maybe_equivalent_to.hpp:79</a></div></div>
</div><!-- fragment --><p>Every descriptor in the set must be equivalent to every other descriptor in the set. Sets of coefficients are equivalent if they are treated functionally the same.</p><ul>
<li>Any coefficient or group of coefficients is equivalent to itself.</li>
<li>FixedDescriptor&lt;As...&gt; is equivalent to FixedDescriptor&lt;Bs...&gt;, if each As is equivalent to its respective Bs.</li>
<li>FixedDescriptor is equivalent to A, and vice versa. <dl class="section user"><dt>Example:</dt><dd><code>equivalent_to&lt;Axis, FixedDescriptor&lt;Axis&gt;&gt;</code> </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="equivalent__to_8hpp_source.html#l00034">34</a> of file <a class="el" href="equivalent__to_8hpp_source.html">equivalent_to.hpp</a>.</p>

</div>
</div>
<a id="ad8831f8a8cb3083e1606a0d99679814c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8831f8a8cb3083e1606a0d99679814c">&#9670;&nbsp;</a></span>equivalent_to_uniform_fixed_vector_space_descriptor_component_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::equivalent_to_uniform_fixed_vector_space_descriptor_component_of = <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt;T, <a class="el" href="namespaceOpenKalman.html#a5ba3df824cdc8ddd172e52be74196644">uniform_fixed_vector_space_descriptor_component_of_t</a>&lt;C&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A 1D <a class="el" href="namespaceOpenKalman.html#a8118548e58d6571ae37572fc5e04206d">atomic_fixed_vector_space_descriptor</a> </td></tr>
    <tr><td class="paramname">C</td><td>a <a class="el" href="namespaceOpenKalman.html#a0f5e34c97d63bb06f980344d91524410">uniform_fixed_vector_space_descriptor</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="equivalent__to__uniform__fixed__vector__space__descriptor__component__of_8hpp_source.html#l00045">45</a> of file <a class="el" href="equivalent__to__uniform__fixed__vector__space__descriptor__component__of_8hpp_source.html">equivalent_to_uniform_fixed_vector_space_descriptor_component_of.hpp</a>.</p>

</div>
</div>
<a id="a4a4a660c145525d68a44fad81f52d1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4a660c145525d68a44fad81f52d1b9">&#9670;&nbsp;</a></span>euclidean_vector_space_descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::euclidean_vector_space_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= vector_space_descriptor&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (fixed_vector_space_descriptor_traits&lt;std::decay_t&lt;T&gt;&gt;::always_euclidean <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a></div>
<div class="line">      dynamic_vector_space_descriptor_traits&lt;std::decay_t&lt;T&gt;&gt;::always_euclidean)</div>
</div><!-- fragment --><p>A set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> is Euclidean if each element of the tensor is an unconstrained std::arithmetic type. This would occur, for example, if the underlying scalar value is an unconstrained floating or integral value. In most applications, the <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> will be Euclidean. </p>

<p class="definition">Definition at line <a class="el" href="euclidean__vector__space__descriptor_8hpp_source.html#l00036">36</a> of file <a class="el" href="euclidean__vector__space__descriptor_8hpp_source.html">euclidean_vector_space_descriptor.hpp</a>.</p>

</div>
</div>
<a id="a055e7b9e1a13db048847821c1d71dd5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055e7b9e1a13db048847821c1d71dd5f">&#9670;&nbsp;</a></span>fixed_vector_space_descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::fixed_vector_space_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= std::default_initializable&lt;std::decay_t&lt;T&gt;&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    requires {</div>
<div class="line">      {fixed_vector_space_descriptor_traits&lt;std::decay_t&lt;T&gt;&gt;::size} -&gt; std::convertible_to&lt;std::size_t&gt;;</div>
<div class="line">      {fixed_vector_space_descriptor_traits&lt;std::decay_t&lt;T&gt;&gt;::euclidean_size} -&gt; std::convertible_to&lt;std::size_t&gt;;</div>
<div class="line">      {fixed_vector_space_descriptor_traits&lt;std::decay_t&lt;T&gt;&gt;::component_count} -&gt; std::convertible_to&lt;std::size_t&gt;;</div>
<div class="line">      {fixed_vector_space_descriptor_traits&lt;std::decay_t&lt;T&gt;&gt;::always_euclidean} -&gt; std::convertible_to&lt;bool&gt;;</div>
<div class="line">      <span class="keyword">typename</span> fixed_vector_space_descriptor_traits&lt;std::decay_t&lt;T&gt;&gt;::difference_type;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>This includes any object for which interface::fixed_vector_space_descriptor_traits is defined. </p>

<p class="definition">Definition at line <a class="el" href="fixed__vector__space__descriptor_8hpp_source.html#l00048">48</a> of file <a class="el" href="fixed__vector__space__descriptor_8hpp_source.html">fixed_vector_space_descriptor.hpp</a>.</p>

</div>
</div>
<a id="a2865e545918d7edd76731d5fe5f1e57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2865e545918d7edd76731d5fe5f1e57f">&#9670;&nbsp;</a></span>has_untyped_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::has_untyped_index</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    euclidean_vector_space_descriptor&lt;vector_space_descriptor_of_t&lt;T, N&gt;&gt;</div>
</div><!-- fragment --><p>Index N of T is Euclidean and non-modular (e.g., Axis, FixedDescriptor&lt;Axis, Axis&gt;, etc.). </p>

<p class="definition">Definition at line <a class="el" href="has__untyped__index_8hpp_source.html#l00028">28</a> of file <a class="el" href="has__untyped__index_8hpp_source.html">has_untyped_index.hpp</a>.</p>

</div>
</div>
<a id="af8566a3ec777d7c9fa78b59da320a037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8566a3ec777d7c9fa78b59da320a037">&#9670;&nbsp;</a></span>hermitian_adapter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , HermitianAdapterType t = HermitianAdapterType::any&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::hermitian_adapter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= hermitian_matrix&lt;T, Qualification::depends_on_dynamic_shape&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> has_nested_object&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (t == HermitianAdapterType::any ?</div>
<div class="line">     interface::indexible_object_traits&lt;std::decay_t&lt;T&gt;&gt;::hermitian_adapter_type == HermitianAdapterType::lower <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a></div>
<div class="line">       interface::indexible_object_traits&lt;std::decay_t&lt;T&gt;&gt;::hermitian_adapter_type == HermitianAdapterType::upper :</div>
<div class="line">     interface::indexible_object_traits&lt;std::decay_t&lt;T&gt;&gt;::hermitian_adapter_type == t)</div>
</div><!-- fragment --><p>A hermitian adapter may or may not actually be a <a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a>, depending on whether it is a <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>. If it is not a square matrix, it can still be a hermitian adapter, but only the truncated square portion of the matrix would be hermitian. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or tensor. </td></tr>
    <tr><td class="paramname">t</td><td>The HermitianAdapterType of T. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hermitian__adapter_8hpp_source.html#l00048">48</a> of file <a class="el" href="hermitian__adapter_8hpp_source.html">hermitian_adapter.hpp</a>.</p>

</div>
</div>
<a id="ad0088e685736596243017da33045f865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0088e685736596243017da33045f865">&#9670;&nbsp;</a></span>hermitian_adapter_type_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto OpenKalman::hermitian_adapter_type_of_v = <a class="el" href="structOpenKalman_1_1hermitian__adapter__type__of.html">hermitian_adapter_type_of</a>&lt;T, Ts...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Possible values are <a class="el" href="namespaceOpenKalman.html#aa8a9bbfcbe19f7fc489fd1405bfdce76a81e073b428b50247daba38531dcf412a">lower</a>, <a class="el" href="namespaceOpenKalman.html#aa8a9bbfcbe19f7fc489fd1405bfdce76a0122b4c2c01ee1c698ecc309d2b8eb5a">upper</a>, or <a class="el" href="namespaceOpenKalman.html#aa8a9bbfcbe19f7fc489fd1405bfdce76a100b8cad7cf2a56f6df78f171f97a1ec">any</a>. </p>

<p class="definition">Definition at line <a class="el" href="hermitian__adapter__type__of_8hpp_source.html#l00040">40</a> of file <a class="el" href="hermitian__adapter__type__of_8hpp_source.html">hermitian_adapter_type_of.hpp</a>.</p>

</div>
</div>
<a id="afbbcbf9bf2f925d0dc32e7942a08507c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbcbf9bf2f925d0dc32e7942a08507c">&#9670;&nbsp;</a></span>hermitian_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Qualification b = Qualification::unqualified&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::hermitian_matrix</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= indexible&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> square_shaped&lt;T, b&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (interface::indexible_object_traits&lt;std::decay_t&lt;T&gt;&gt;::is_hermitian <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a></div>
<div class="line">      ((constant_matrix&lt;T, ConstantType::any&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> diagonal_matrix&lt;T&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">      (not <a class="code" href="namespaceOpenKalman.html#a43cdde4b102bbb681e3dc62a9e767cb6">complex_number</a>&lt;scalar_type_of_t&lt;T&gt;&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a></div>
<div class="line">        <a class="code" href="namespaceOpenKalman.html#a6865fd1e6b35c6be70b2f464dfd6497b">real_axis_number</a>&lt;constant_coefficient&lt;T&gt;&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="code" href="namespaceOpenKalman.html#a6865fd1e6b35c6be70b2f464dfd6497b">real_axis_number</a>&lt;constant_diagonal_coefficient&lt;T&gt;&gt;)))</div>
<div class="ttc" id="anamespaceOpenKalman_html_a43cdde4b102bbb681e3dc62a9e767cb6"><div class="ttname"><a href="namespaceOpenKalman.html#a43cdde4b102bbb681e3dc62a9e767cb6">OpenKalman::complex_number</a></div><div class="ttdeci">concept complex_number</div><div class="ttdoc">T is std::complex or a custom complex type.</div><div class="ttdef"><b>Definition:</b> <a href="complex__number_8hpp_source.html#l00040">complex_number.hpp:40</a></div></div>
<div class="ttc" id="anamespaceOpenKalman_html_a6865fd1e6b35c6be70b2f464dfd6497b"><div class="ttname"><a href="namespaceOpenKalman.html#a6865fd1e6b35c6be70b2f464dfd6497b">OpenKalman::real_axis_number</a></div><div class="ttdeci">concept real_axis_number</div><div class="ttdoc">T is either not a complex_number or its imaginary component is 0.</div><div class="ttdef"><b>Definition:</b> <a href="real__axis__number_8hpp_source.html#l00048">real_axis_number.hpp:48</a></div></div>
</div><!-- fragment --><p>For rank &gt;2 tensors, this must be applicable on every rank-2 slice comprising dimensions 0 and 1. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or tensor. </td></tr>
    <tr><td class="paramname">b</td><td>Whether T must be known to be a square matrix at compile time. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="hermitian__matrix_8hpp_source.html#l00044">44</a> of file <a class="el" href="hermitian__matrix_8hpp_source.html">hermitian_matrix.hpp</a>.</p>

</div>
</div>
<a id="a2a52b813621d6f1567234b83e0cad2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a52b813621d6f1567234b83e0cad2bb">&#9670;&nbsp;</a></span>identity_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::identity_matrix</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    (constant_diagonal_matrix&lt;T, ConstantType::static_constant&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> <a class="code" href="namespaceOpenKalman_1_1internal.html#a58d39fdab87fc43374d964cd410ce63c">internal::are_within_tolerance</a>(constant_diagonal_coefficient_v&lt;T&gt;, 1)) <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    empty_object&lt;T&gt;</div>
<div class="ttc" id="anamespaceOpenKalman_1_1internal_html_a58d39fdab87fc43374d964cd410ce63c"><div class="ttname"><a href="namespaceOpenKalman_1_1internal.html#a58d39fdab87fc43374d964cd410ce63c">OpenKalman::internal::are_within_tolerance</a></div><div class="ttdeci">constexpr bool are_within_tolerance(const Arg1 &amp;arg1, const Arg2 &amp;arg2)</div><div class="ttdoc">Determine whether two numbers are within a rounding tolerance.</div><div class="ttdef"><b>Definition:</b> <a href="are__within__tolerance_8hpp_source.html#l00032">are_within_tolerance.hpp:32</a></div></div>
</div><!-- fragment --><p>This is a generalized identity matrix which may be rectangular (with zeros in all non-diagonal components. For rank &gt;2 tensors, every rank-2 slice comprising dimensions 0 and 1 must be an identity matrix as defined here. Every <a class="el" href="namespaceOpenKalman.html#a4d2ce6da5d4f3187281589b759364395">empty_object</a> is also an identity matrix. </p>

<p class="definition">Definition at line <a class="el" href="identity__matrix_8hpp_source.html#l00042">42</a> of file <a class="el" href="identity__matrix_8hpp_source.html">identity_matrix.hpp</a>.</p>

</div>
</div>
<a id="a357b81b7e7664f628fc14bcd5bb3bdc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357b81b7e7664f628fc14bcd5bb3bdc0">&#9670;&nbsp;</a></span>indexible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::indexible</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    interface::count_indices_defined_for&lt;std::decay_t&lt;T&gt;&gt;</div>
</div><!-- fragment --><p>T can be a tensor over a vector space, but can also be an analogous algebraic structure over a tensor product of modules over division rings (e.g., an vector-like structure that contains angles). </p>
<dl class="section see"><dt>See also</dt><dd>interface::indexible_object_traits::count_indices </dd></dl>

<p class="definition">Definition at line <a class="el" href="indexible_8hpp_source.html#l00030">30</a> of file <a class="el" href="indexible_8hpp_source.html">indexible.hpp</a>.</p>

</div>
</div>
<a id="a530caeba987ecaa553e5b8430818ee20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530caeba987ecaa553e5b8430818ee20">&#9670;&nbsp;</a></span>linearized_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t order = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::linearized_function</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="structOpenKalman_1_1internal_1_1is__linearized__function.html">oin::is_linearized_function&lt;std::decay_t&lt;T&gt;</a>, order&gt;::value</div>
<div class="ttc" id="astructOpenKalman_1_1internal_1_1is__linearized__function_html"><div class="ttname"><a href="structOpenKalman_1_1internal_1_1is__linearized__function.html">OpenKalman::internal::is_linearized_function</a></div><div class="ttdoc">Whether an object is a linearized function (with defined Jacobian and optionally Hessian functions).</div><div class="ttdef"><b>Definition:</b> <a href="TransformationTraits_8hpp_source.html#l00039">TransformationTraits.hpp:39</a></div></div>
</div><!-- fragment --><p>If order == 1, then the Jacobian is defined. If order == 2, then the Hessian is defined. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The function. </td></tr>
    <tr><td class="paramname">order</td><td>The maximum order in which T's Taylor series is defined. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TransformationTraits_8hpp_source.html#l00051">51</a> of file <a class="el" href="TransformationTraits_8hpp_source.html">TransformationTraits.hpp</a>.</p>

</div>
</div>
<a id="a34d179caf50325236f04ae3778c02519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d179caf50325236f04ae3778c02519">&#9670;&nbsp;</a></span>maybe_equivalent_to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::maybe_equivalent_to</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    detail::is_maybe_equivalent_to&lt;Ts...&gt;::value</div>
</div><!-- fragment --><p>Every descriptor in the set must be potentially equivalent to every other descriptor in the set. Sets of vector space descriptors are equivalent if they are treated functionally the same.</p><ul>
<li>Any descriptor or group of descriptor is equivalent to itself.</li>
<li>FixedDescriptor&lt;As...&gt; is equivalent to FixedDescriptor&lt;Bs...&gt;, if each As is equivalent to its respective Bs.</li>
<li>FixedDescriptor is equivalent to A, and vice versa.</li>
<li>Dynamic <a class="el" href="namespaceOpenKalman.html#a4a4a660c145525d68a44fad81f52d1b9">euclidean_vector_space_descriptor</a> objects are equivalent to any other <a class="el" href="namespaceOpenKalman.html#a4a4a660c145525d68a44fad81f52d1b9">euclidean_vector_space_descriptor</a>, <dl class="section user"><dt>Example:</dt><dd><code>equivalent_to&lt;Axis, FixedDescriptor&lt;Axis&gt;&gt;</code> </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="maybe__equivalent__to_8hpp_source.html#l00079">79</a> of file <a class="el" href="maybe__equivalent__to_8hpp_source.html">maybe_equivalent_to.hpp</a>.</p>

</div>
</div>
<a id="a2dd99301266e3bb4f1d2d92b69b324ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd99301266e3bb4f1d2d92b69b324ab">&#9670;&nbsp;</a></span>one_dimensional</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Qualification b = Qualification::unqualified&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::one_dimensional</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= indexible&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (not interface::one_dimensional_defined_for&lt;T, b&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> interface::indexible_object_traits&lt;std::decay_t&lt;T&gt;&gt;::<span class="keyword">template</span> one_dimensional&lt;b&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (interface::one_dimensional_defined_for&lt;T, b&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> detail::one_dimensional_impl&lt;T, b&gt;::value)</div>
</div><!-- fragment --><p>Each index also must have an equivalent <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> object. </p>

<p class="definition">Definition at line <a class="el" href="one__dimensional_8hpp_source.html#l00066">66</a> of file <a class="el" href="one__dimensional_8hpp_source.html">one_dimensional.hpp</a>.</p>

</div>
</div>
<a id="a39bf66c95289a9d90a189c843755687f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bf66c95289a9d90a189c843755687f">&#9670;&nbsp;</a></span>perturbation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Coeffs  = typename oin::PerturbationTraits&lt;T&gt;::RowCoefficients&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::perturbation</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (gaussian_distribution&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    equivalent_to&lt;typename oin::PerturbationTraits&lt;T&gt;::RowCoefficients, Coeffs&gt;) <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> transformation_input&lt;T, Coeffs&gt;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputCoefficients</td><td>The expected coefficients of the tests output. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TransformationTraits_8hpp_source.html#l00170">170</a> of file <a class="el" href="TransformationTraits_8hpp_source.html">TransformationTraits.hpp</a>.</p>

</div>
</div>
<a id="a72829d83ccbc836bfb60d395cd4d5331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72829d83ccbc836bfb60d395cd4d5331">&#9670;&nbsp;</a></span>scalar_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , ConstantType c = ConstantType::any&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::scalar_constant</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    (c == ConstantType::any <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> (detail::compile_time_scalar_constant&lt;T&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> detail::runtime_scalar_constant&lt;T&gt;)) <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a></div>
<div class="line">    (c == ConstantType::static_constant <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> detail::compile_time_scalar_constant&lt;T&gt;) <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a></div>
<div class="line">    (c == ConstantType::dynamic_constant <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> detail::runtime_scalar_constant&lt;T&gt;)</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">c</td><td>Whether the constant is known or unknown at compile time. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="scalar__constant_8hpp_source.html#l00103">103</a> of file <a class="el" href="scalar__constant_8hpp_source.html">scalar_constant.hpp</a>.</p>

</div>
</div>
<a id="aae7f9880c66287c68d382f6a1352d069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7f9880c66287c68d382f6a1352d069">&#9670;&nbsp;</a></span>scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::scalar_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    std::numeric_limits&lt;std::decay_t&lt;T&gt;&gt;::is_specialized <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> complex_number&lt;T&gt;</div>
</div><!-- fragment --><p>T can be any arithmetic, complex, or custom scalar type in which certain traits in <a class="el" href="structOpenKalman_1_1interface_1_1scalar__traits.html" title="Traits for scalar types, including user-defined scalar types.">interface::scalar_traits</a> are defined and typical math operations (+, -, *, /, and ==) are also defined. </p>

<p class="definition">Definition at line <a class="el" href="scalar__type_8hpp_source.html#l00030">30</a> of file <a class="el" href="scalar__type_8hpp_source.html">scalar_type.hpp</a>.</p>

</div>
</div>
<a id="a9bcd379baf13eb66452873164e6354f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bcd379baf13eb66452873164e6354f8">&#9670;&nbsp;</a></span>square_shaped</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Qualification b = Qualification::unqualified&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::square_shaped</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= one_dimensional&lt;T, b&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> (indexible&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (not interface::is_square_defined_for&lt;T, b&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> interface::indexible_object_traits&lt;std::decay_t&lt;T&gt;&gt;::<span class="keyword">template</span> is_square&lt;b&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (interface::is_square_defined_for&lt;T, b&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> ((b != Qualification::unqualified <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not has_dynamic_dimensions&lt;T&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">        (index_count_v&lt;T&gt; != 1 <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> dimension_size_of_index_is&lt;T, 0, 1, Qualification::depends_on_dynamic_shape&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">        (index_count_v&lt;T&gt; &lt; 2 <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> detail::maybe_square_shaped&lt;T&gt;(std::make_index_sequence&lt;index_count_v&lt;T&gt;&gt;{}))) <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a></div>
<div class="line">      (b == Qualification::unqualified <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> interface::indexible_object_traits&lt;std::decay_t&lt;T&gt;&gt;::<span class="keyword">template</span> is_triangular&lt;TriangleType::any, b&gt;)))</div>
</div><!-- fragment --><p>An object is square iff it meets the following requirements:</p><ul>
<li>each index (if any) has the name number of dimensions,</li>
<li>every <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> (omitting any trailing 1D Euclidean descriptors) is equivalent. <dl class="section note"><dt>Note</dt><dd>An empty (0-by-0) matrix or tensor is considered to be square. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">b</td><td>Defines what happens when one or more of the indices has dynamic dimension:</td></tr>
  </table>
  </dd>
</dl>
</li>
<li>if <code>b == <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832ab19eb7aa5ed583579f9827b838e3d191" title="At compile time, the property is known to apply.">Qualification::unqualified</a></code>: T is known at compile time to be square;</li>
<li>if <code>b == <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30" title="The property is not ruled out and depends on the dynamic shape.">Qualification::depends_on_dynamic_shape</a></code>: It is known at compile time that T <em>may</em> be square. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="square__shaped_8hpp_source.html#l00078">78</a> of file <a class="el" href="square__shaped_8hpp_source.html">square_shaped.hpp</a>.</p>

</div>
</div>
<a id="a1cc94c01586781f39e5e41a7a14378dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc94c01586781f39e5e41a7a14378dc">&#9670;&nbsp;</a></span>static_index_value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Z  = std::size_t&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::static_index_value</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    requires {</div>
<div class="line">      {std::decay_t&lt;T&gt;::value} -&gt; std::convertible_to&lt;Z&gt;;</div>
<div class="line">      {std::decay_t&lt;T&gt;{}} -&gt; std::convertible_to&lt;Z&gt;;</div>
<div class="line">    } <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> (not std::is_signed_v&lt;decltype(std::decay_t&lt;T&gt;::value)&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <span class="keyword">static_cast&lt;</span><span class="keywordtype">long</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(std::decay_t&lt;T&gt;::value) &gt;= 0) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (not std::same_as&lt;decltype(std::decay_t&lt;T&gt;::value), std::<span class="keywordtype">size_t</span>&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> std::decay_t&lt;T&gt;::value != <a class="code" href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">dynamic_size</a>)</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Z</td><td>the type to which the index must be convertible. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="static__index__value_8hpp_source.html#l00045">45</a> of file <a class="el" href="static__index__value_8hpp_source.html">static_index_value.hpp</a>.</p>

</div>
</div>
<a id="a188757d14b80eaab112f0aefa1031dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188757d14b80eaab112f0aefa1031dbe">&#9670;&nbsp;</a></span>transformation_input</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Coeffs  = typename oin::PerturbationTraits&lt;T&gt;::RowCoefficients&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::transformation_input</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    typed_matrix&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> vector&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> has_untyped_index&lt;T, 1&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> (not euclidean_transformed&lt;T&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    equivalent_to&lt;typename oin::PerturbationTraits&lt;T&gt;::RowCoefficients, Coeffs&gt;</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Coeffs</td><td>The expected coefficients of the tests input. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="TransformationTraits_8hpp_source.html#l00156">156</a> of file <a class="el" href="TransformationTraits_8hpp_source.html">TransformationTraits.hpp</a>.</p>

</div>
</div>
<a id="ae3191dafc41675832797c59b2a719eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3191dafc41675832797c59b2a719eba">&#9670;&nbsp;</a></span>triangular_adapter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::triangular_adapter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= interface::indexible_object_traits&lt;std::decay_t&lt;T&gt;&gt;::is_triangular_adapter <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    has_nested_object&lt;T&gt;</div>
</div><!-- fragment --><p>A triangular adapter takes a matrix and presents a view in which, in one or both triangular (or trapezoidal) sides on either side of the diagonal are zero. The matrix need not be square. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or tensor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="triangular__adapter_8hpp_source.html#l00043">43</a> of file <a class="el" href="triangular__adapter_8hpp_source.html">triangular_adapter.hpp</a>.</p>

</div>
</div>
<a id="adf1fd82767ce2a6be113c3ed4d96350c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1fd82767ce2a6be113c3ed4d96350c">&#9670;&nbsp;</a></span>triangular_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , TriangleType t = TriangleType::any&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::triangular_matrix</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= indexible&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (interface::indexible_object_traits&lt;std::decay_t&lt;T&gt;&gt;::<span class="keyword">template</span> is_triangular&lt;t&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> constant_diagonal_matrix&lt;T&gt;)</div>
</div><!-- fragment --><p>A triangular matrix need not be <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>, but it must be zero either above or below the diagonal (or both). For rank &gt;2 tensors, this must be applicable on every rank-2 slice comprising dimensions 0 and 1. </p><dl class="section note"><dt>Note</dt><dd>One-dimensional matrices or vectors are considered to be triangular, and a vector is triangular if every component other than its first component is zero. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or tensor. </td></tr>
    <tr><td class="paramname">t</td><td>The <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a> triangular if it is one-dimensional, and that is not necessarily known at compile time. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="triangular__matrix_8hpp_source.html#l00034">34</a> of file <a class="el" href="triangular__matrix_8hpp_source.html">triangular_matrix.hpp</a>.</p>

</div>
</div>
<a id="a4aecb900a734f8906da8e96db6e702a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aecb900a734f8906da8e96db6e702a6">&#9670;&nbsp;</a></span>untyped_adapter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::untyped_adapter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    eigen_diagonal_expr&lt;T&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> eigen_self_adjoint_expr&lt;T&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> eigen_triangular_expr&lt;T&gt;</div>
</div><!-- fragment --><p>Untyped adapter expressions are generally used whenever the native matrix library does not have an important built-in matrix type, such as a diagonal matrix, a triangular matrix, or a hermitian matrix. </p>

<p class="definition">Definition at line <a class="el" href="untyped__adapter_8hpp_source.html#l00029">29</a> of file <a class="el" href="untyped__adapter_8hpp_source.html">untyped_adapter.hpp</a>.</p>

</div>
</div>
<a id="ab737b3bbdad3ee74c92a344a6a18c447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab737b3bbdad3ee74c92a344a6a18c447">&#9670;&nbsp;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N = 0, Qualification b = Qualification::unqualified&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::vector</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    indexible&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> detail::vector_impl&lt;T, N, b&gt;::value</div>
</div><!-- fragment --><p>In this context, a vector is an object in which every index but one is 1D. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An indexible object </td></tr>
    <tr><td class="paramname">N</td><td>An index designating the "large" index (0 for a column vector, 1 for a row vector) </td></tr>
    <tr><td class="paramname">b</td><td>Whether the vector status is unqualified known at compile time (<a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832ab19eb7aa5ed583579f9827b838e3d191" title="At compile time, the property is known to apply.">Qualification::unqualified</a>), or only known at runtime (<a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30" title="The property is not ruled out and depends on the dynamic shape.">Qualification::depends_on_dynamic_shape</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceOpenKalman.html#a2f295961ec96698496f7ebbfd4de505e" title="Return true if T is a vector at runtime.">is_vector</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vector_8hpp_source.html#l00065">65</a> of file <a class="el" href="vector_8hpp_source.html">vector.hpp</a>.</p>

</div>
</div>
<a id="a6aa798b43668ea60705a78485a84a200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa798b43668ea60705a78485a84a200">&#9670;&nbsp;</a></span>vector_space_descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::vector_space_descriptor</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    fixed_vector_space_descriptor&lt;T&gt; <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> dynamic_vector_space_descriptor&lt;T&gt;</div>
</div><!-- fragment --><p>Such an object is a trait defining the number of dimensions and whether each dimension is modular. This includes anything that is either a <a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a> or a <a class="el" href="namespaceOpenKalman.html#a31eae8386d50ed98dc96326732ef9234">dynamic_vector_space_descriptor</a>. </p>

<p class="definition">Definition at line <a class="el" href="vector__space__descriptor_8hpp_source.html#l00029">29</a> of file <a class="el" href="vector__space__descriptor_8hpp_source.html">vector_space_descriptor.hpp</a>.</p>

</div>
</div>
<a id="af06c81bf543e750616dc3cb2115885d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06c81bf543e750616dc3cb2115885d8">&#9670;&nbsp;</a></span>vector_space_descriptors_match_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::vector_space_descriptors_match_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespaceOpenKalman.html#a71866768ca1d2b98352a34f58eac26a4">vector_space_descriptors_may_match_with</a>&lt;Ts...&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> ((not has_dynamic_dimensions&lt;Ts&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> ...)</div>
<div class="ttc" id="anamespaceOpenKalman_html_a71866768ca1d2b98352a34f58eac26a4"><div class="ttname"><a href="namespaceOpenKalman.html#a71866768ca1d2b98352a34f58eac26a4">OpenKalman::vector_space_descriptors_may_match_with</a></div><div class="ttdeci">concept vector_space_descriptors_may_match_with</div><div class="ttdoc">Specifies that indexible objects Ts may have equivalent dimensions and vector-space types.</div><div class="ttdef"><b>Definition:</b> <a href="vector__space__descriptors__may__match__with_8hpp_source.html#l00045">vector_space_descriptors_may_match_with.hpp:45</a></div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>A set of <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceOpenKalman.html#a71866768ca1d2b98352a34f58eac26a4" title="Specifies that indexible objects Ts may have equivalent dimensions and vector-space types.">vector_space_descriptors_may_match_with</a> </dd>
<dd>
<a class="el" href="namespaceOpenKalman.html#a4a1397f4d7afcc945903cb94f2058064" title="Return true if every set of vector_space_descriptor of a set of objects match.">vector_space_descriptors_match</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vector__space__descriptors__match__with_8hpp_source.html#l00030">30</a> of file <a class="el" href="vector__space__descriptors__match__with_8hpp_source.html">vector_space_descriptors_match_with.hpp</a>.</p>

</div>
</div>
<a id="a71866768ca1d2b98352a34f58eac26a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71866768ca1d2b98352a34f58eac26a4">&#9670;&nbsp;</a></span>vector_space_descriptors_may_match_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::vector_space_descriptors_may_match_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    (indexible&lt;Ts&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> ...) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    detail::vector_space_descriptors_may_match_with_impl&lt;Ts...&gt;(std::make_index_sequence&lt;std::max({std::size_t{0}, index_count_v&lt;Ts&gt;...})&gt;{})</div>
</div><!-- fragment --><p>Two dimensions are considered the same if their <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> are <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceOpenKalman.html#af06c81bf543e750616dc3cb2115885d8" title="Specifies that a set of indexible objects have equivalent vector space descriptors for each index.">vector_space_descriptors_match_with</a> </dd>
<dd>
<a class="el" href="namespaceOpenKalman.html#a4a1397f4d7afcc945903cb94f2058064" title="Return true if every set of vector_space_descriptor of a set of objects match.">vector_space_descriptors_match</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vector__space__descriptors__may__match__with_8hpp_source.html#l00045">45</a> of file <a class="el" href="vector__space__descriptors__may__match__with_8hpp_source.html">vector_space_descriptors_may_match_with.hpp</a>.</p>

</div>
</div>
<a id="a0446f0fba3feb5d14a40bf9d375ba31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0446f0fba3feb5d14a40bf9d375ba31e">&#9670;&nbsp;</a></span>wrappable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::wrappable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= indexible&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> (index_count_v&lt;T&gt; &gt;= 1) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (detail::wrappable_impl&lt;T&gt;(std::make_index_sequence&lt;index_count_v&lt;T&gt; - 1&gt;{}))</div>
</div><!-- fragment --><p>This indicates that T is suitable for wrapping along index 0. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceOpenKalman.html#af4aa86d3ef5ab79a607ecb7ce06d466f" title="Determine whether T is wrappable (i.e., all its dimensions other than potentially 0 are euclidean).">get_wrappable</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="wrappable_8hpp_source.html#l00046">46</a> of file <a class="el" href="wrappable_8hpp_source.html">wrappable.hpp</a>.</p>

</div>
</div>
<a id="abd7388b89ddb8b8aa2c0e1be66900dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7388b89ddb8b8aa2c0e1be66900dee">&#9670;&nbsp;</a></span>writable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept OpenKalman::writable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    indexible&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> interface::indexible_object_traits&lt;std::decay_t&lt;T&gt;&gt;::is_writable <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (not std::is_const_v&lt;std::remove_reference_t&lt;T&gt;&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> std::copy_constructible&lt;std::decay_t&lt;T&gt;&gt;</div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="writable_8hpp_source.html#l00029">29</a> of file <a class="el" href="writable_8hpp_source.html">writable.hpp</a>.</p>

</div>
</div>
<a id="a10408b0379abb2d3405f6401d563e149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10408b0379abb2d3405f6401d563e149">&#9670;&nbsp;</a></span>writable_by_component</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Indices  = std::conditional_t&lt;index_count_v&lt;T&gt; == dynamic_size, std::array&lt;std::size_t, index_count_v&lt;T&gt;&gt;, std::vector&lt;std::size_t&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::writable_by_component</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= indexible&lt;T&gt; <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> (not std::is_const_v&lt;std::remove_reference_t&lt;T&gt;&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a> (not <a class="code" href="namespaceOpenKalman.html#a4d2ce6da5d4f3187281589b759364395">empty_object</a>&lt;T&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    interface::set_component_defined_for&lt;T, std::add_lvalue_reference_t&lt;T&gt;, const typename scalar_type_of&lt;T&gt;::type&amp;, const Indices&amp;&gt;</div>
<div class="ttc" id="anamespaceOpenKalman_html_a4d2ce6da5d4f3187281589b759364395"><div class="ttname"><a href="namespaceOpenKalman.html#a4d2ce6da5d4f3187281589b759364395">OpenKalman::empty_object</a></div><div class="ttdeci">concept empty_object</div><div class="ttdoc">Specifies that an object is empty (i.e., at least one index is zero-dimensional).</div><div class="ttdef"><b>Definition:</b> <a href="empty__object_8hpp_source.html#l00037">empty_object.hpp:37</a></div></div>
</div><!-- fragment --><p>If T satisfies this concept, then set_component(...) is available with Indices. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceOpenKalman.html#af856ae93af81c5aa773607a257889e02" title="Set a component of an object at a particular set of indices.">set_component</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="writable__by__component_8hpp_source.html#l00033">33</a> of file <a class="el" href="writable__by__component_8hpp_source.html">writable_by_component.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa745cbaa0edbfed7d1da05691e07d47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa745cbaa0edbfed7d1da05691e07d47b">&#9670;&nbsp;</a></span>ConstantType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceOpenKalman.html#aa745cbaa0edbfed7d1da05691e07d47b">OpenKalman::ConstantType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa745cbaa0edbfed7d1da05691e07d47ba100b8cad7cf2a56f6df78f171f97a1ec"></a>any&#160;</td><td class="fielddoc"><p>The constant is determined either at compile time or runtime. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa745cbaa0edbfed7d1da05691e07d47ba32c2b7f95065494184e8b5799d3618e7"></a>dynamic_constant&#160;</td><td class="fielddoc"><p>The constant is unknown at compile time and is determined at runtime. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa745cbaa0edbfed7d1da05691e07d47baa90e37207f27e1996845a3c7d594fd0a"></a>static_constant&#160;</td><td class="fielddoc"><p>The constant is known at compile time. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="global-definitions_8hpp_source.html#l00120">120</a> of file <a class="el" href="global-definitions_8hpp_source.html">global-definitions.hpp</a>.</p>

</div>
</div>
<a id="aa8a9bbfcbe19f7fc489fd1405bfdce76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a9bbfcbe19f7fc489fd1405bfdce76">&#9670;&nbsp;</a></span>HermitianAdapterType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceOpenKalman.html#aa8a9bbfcbe19f7fc489fd1405bfdce76">OpenKalman::HermitianAdapterType</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This type can be statically cast from <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a> so that <code>lower</code>, <code>upper</code>, and <code>any</code> correspond to each other. The value <code>none</code> corresponds to <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209baa0e17e2709a0404ae3d7de03b8ea9093" title="A diagonal matrix (both a lower-left and an upper-right triangular matrix).">TriangleType::diagonal</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa8a9bbfcbe19f7fc489fd1405bfdce76a100b8cad7cf2a56f6df78f171f97a1ec"></a>any&#160;</td><td class="fielddoc"><p>Either lower or upper hermitian adapter. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa8a9bbfcbe19f7fc489fd1405bfdce76a81e073b428b50247daba38531dcf412a"></a>lower&#160;</td><td class="fielddoc"><p>A lower-left hermitian adapter. </p>
</td></tr>
<tr><td class="fieldname"><a id="aa8a9bbfcbe19f7fc489fd1405bfdce76a0122b4c2c01ee1c698ecc309d2b8eb5a"></a>upper&#160;</td><td class="fielddoc"><p>An upper-right hermitian adapter. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="global-definitions_8hpp_source.html#l00078">78</a> of file <a class="el" href="global-definitions_8hpp_source.html">global-definitions.hpp</a>.</p>

</div>
</div>
<a id="a3899b43bdfa17fa31303340b2dd9121e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3899b43bdfa17fa31303340b2dd9121e">&#9670;&nbsp;</a></span>Layout</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121e">OpenKalman::Layout</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3899b43bdfa17fa31303340b2dd9121ea334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"><p>No storage layout (e.g., if the elements are calculated rather than stored). </p>
</td></tr>
<tr><td class="fieldname"><a id="a3899b43bdfa17fa31303340b2dd9121ea7c4f29407893c334a6cb7a87bf045c0d"></a>right&#160;</td><td class="fielddoc"><p>Row-major storage (C or C++ style): contiguous storage in which the right-most index has a stride of 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3899b43bdfa17fa31303340b2dd9121ea811882fecd5c7618d7099ebbd39ea254"></a>left&#160;</td><td class="fielddoc"><p>Column-major storage (Fortran, Matlab, or Eigen style): contiguous storage in which the left-most extent has a stride of 1. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3899b43bdfa17fa31303340b2dd9121ea47101375aa96fa02cfb1d55fd00af989"></a>stride&#160;</td><td class="fielddoc"><p>A generalization of the above: a custom stride is specified for each index. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="global-definitions_8hpp_source.html#l00047">47</a> of file <a class="el" href="global-definitions_8hpp_source.html">global-definitions.hpp</a>.</p>

</div>
</div>
<a id="a3d8d9ff3bc2be3b04457b2ae3df89832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8d9ff3bc2be3b04457b2ae3df89832">&#9670;&nbsp;</a></span>Qualification</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832">OpenKalman::Qualification</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30" title="The property is not ruled out and depends on the dynamic shape.">Qualification::depends_on_dynamic_shape</a> means that the concept or trait may vary based on the dynamic shape of the argument, which is not known at compile time. For example:</p><ul>
<li><code><a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8" title="Specifies that an object is square (i.e., has equivalent vector_space_descriptor along each dimension...">square_shaped&lt;T, Qualification::unqualified&gt;</a></code> means that T is known at compile time to be a square matrix.</li>
<li><code><a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8" title="Specifies that an object is square (i.e., has equivalent vector_space_descriptor along each dimension...">square_shaped&lt;T, Qualification::depends_on_dynamic_shape&gt;</a></code> means that T <em>could</em> be a square matrix, but whether it actually <em>is</em> cannot be determined at compile time. </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3d8d9ff3bc2be3b04457b2ae3df89832ab19eb7aa5ed583579f9827b838e3d191"></a>unqualified&#160;</td><td class="fielddoc"><p>At compile time, the property is known to apply. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30"></a>depends_on_dynamic_shape&#160;</td><td class="fielddoc"><p>The property is not ruled out and depends on the dynamic shape. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="global-definitions_8hpp_source.html#l00093">93</a> of file <a class="el" href="global-definitions_8hpp_source.html">global-definitions.hpp</a>.</p>

</div>
</div>
<a id="a04d7114313206e555dfb932ccc82209b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d7114313206e555dfb932ccc82209b">&#9670;&nbsp;</a></span>TriangleType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">OpenKalman::TriangleType</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is generally applicable to a rank-2 tensor (e.g., a matrix). It also applies to tensors of rank &gt; 2, in which case every rank-2 slice over dimensions 0 and 1 must be a triangle of this type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a04d7114313206e555dfb932ccc82209baa0e17e2709a0404ae3d7de03b8ea9093"></a>diagonal&#160;</td><td class="fielddoc"><p>A diagonal matrix (both a lower-left and an upper-right triangular matrix). </p>
</td></tr>
<tr><td class="fieldname"><a id="a04d7114313206e555dfb932ccc82209ba81e073b428b50247daba38531dcf412a"></a>lower&#160;</td><td class="fielddoc"><p>A lower-left triangular matrix. </p>
</td></tr>
<tr><td class="fieldname"><a id="a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a"></a>upper&#160;</td><td class="fielddoc"><p>An upper-right triangular matrix. </p>
</td></tr>
<tr><td class="fieldname"><a id="a04d7114313206e555dfb932ccc82209ba100b8cad7cf2a56f6df78f171f97a1ec"></a>any&#160;</td><td class="fielddoc"><p>Lower, upper, or diagonal matrix. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="global-definitions_8hpp_source.html#l00060">60</a> of file <a class="el" href="global-definitions_8hpp_source.html">global-definitions.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Aliases</h2>
<a id="a03b16f3264522ab5b6be8215b82b7e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b16f3264522ab5b6be8215b82b7e9d">&#9670;&nbsp;</a></span>nested_object_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;has_nested_object T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceOpenKalman.html#a03b16f3264522ab5b6be8215b82b7e9d">OpenKalman::nested_object_of_t</a> = typedef typename <a class="el" href="structOpenKalman_1_1nested__object__of.html">nested_object_of</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A wrapper type that has a nested matrix. </td></tr>
    <tr><td class="paramname">i</td><td>Index of the dependency (0 by default) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="nested__object__of_8hpp_source.html#l00066">66</a> of file <a class="el" href="nested__object__of_8hpp_source.html">nested_object_of.hpp</a>.</p>

</div>
</div>
<a id="a3ffd6208ec107df3ffefbff512f0ad27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ffd6208ec107df3ffefbff512f0ad27">&#9670;&nbsp;</a></span>ZeroAdapter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible PatternObject, scalar_type Scalar = scalar_type_of_t&lt;PatternObject&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceOpenKalman.html#a3ffd6208ec107df3ffefbff512f0ad27">OpenKalman::ZeroAdapter</a> = typedef ConstantAdapter&lt;PatternObject, Scalar, 0&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PatternObject</td><td>An indexible object, in some library, defining the shape of the resulting zero object </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="forward-class-declarations_8hpp_source.html#l00094">94</a> of file <a class="el" href="forward-class-declarations_8hpp_source.html">forward-class-declarations.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acd2f2b564ae42b7d10f3391acdc97546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2f2b564ae42b7d10f3391acdc97546">&#9670;&nbsp;</a></span>and() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uniform_random_bit_generator re = std::mt19937, typed_matrix M, typename Cov &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a>&lt;M&gt; and <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt;M, 1&gt; and <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt;Cov&gt; OpenKalman::and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a>&lt; Cov &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>&lt; Cov &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">re</td><td>A random number engine. </td></tr>
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>. </td></tr>
    <tr><td class="paramname">Cov</td><td>A <a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a> or <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespaceOpenKalman.html#a2e676386d6ed5b7749578d8a4e966d96">gaussian_distribution</a>. </dd></dl>

</div>
</div>
<a id="ad077f442dad48355cf9818572813a758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad077f442dad48355cf9818572813a758">&#9670;&nbsp;</a></span>and() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uniform_random_bit_generator re = std::mt19937, typed_matrix M, typename Cov &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a>&lt;M&gt; and <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt;M, 1&gt; and <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt;Cov&gt; OpenKalman::and </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>&lt; Cov &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>&lt; Cov &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">re</td><td>A random number engine. </td></tr>
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>. </td></tr>
    <tr><td class="paramname">Cov</td><td>A <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a> or <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespaceOpenKalman.html#a2e676386d6ed5b7749578d8a4e966d96">gaussian_distribution</a>. </dd></dl>

</div>
</div>
<a id="a097e8249617b8aad6bc0dc736f93bda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097e8249617b8aad6bc0dc736f93bda1">&#9670;&nbsp;</a></span>and() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;covariance M, typed_matrix A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt;<a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt;A, 0&gt;::<a class="el" href="namespaceOpenKalman.html#a30391ef8ac72c2cbb79acee7ab1fd90f">ColumnCoefficients</a>, typename MatrixTraits&lt;std::decay_t&lt;M&gt; &gt; &gt; OpenKalman::and </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#afde753e8fa98ead4323ad7f74c6e314f">euclidean_transformed</a>&lt; A &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a>. </td></tr>
    <tr><td class="paramname">A</td><td>A <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>A scaled covariance Arg is A * Arg * adjoint(A). A scaled square root covariance L or U is also scaled accordingly, so that scale(L * adjoint(L)) = A * L * adjoint(L) * adjoint(A) or scale(adjoint(U) * U) = A * adjoint(U) * U * adjoint(A). </p>

</div>
</div>
<a id="a16ec07cc06e19af84f87471e4f387720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ec07cc06e19af84f87471e4f387720">&#9670;&nbsp;</a></span>and() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible Arg, vector_space_descriptor... Ds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman_1_1internal.html#abc8a076739643eb44a47a90d10f7974c">internal::not_more_fixed_than</a>&lt;Arg, Ds...&gt; OpenKalman::and </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman_1_1internal.html#a22f7a8daa8f3c006b00dd41ca4329a4c">internal::less_fixed_than</a>&lt; Arg, Ds... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Any vector space descriptors in the argument are overwritten. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>An <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> object. \taram Ds A set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> objects </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="make__vector__space__adapter_8hpp_source.html#l00029">29</a> of file <a class="el" href="make__vector__space__adapter_8hpp_source.html">make_vector_space_adapter.hpp</a>.</p>

</div>
</div>
<a id="ae7cd7ce40e47ba1c85cad4c4e45a1ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cd7ce40e47ba1c85cad4c4e45a1ec4">&#9670;&nbsp;</a></span>assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible To, vector_space_descriptors_may_match_with&lt; To &gt; From&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr To&amp;&amp; OpenKalman::assign </td>
          <td>(</td>
          <td class="paramtype">To &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">From &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The writable object to be assigned. </td></tr>
    <tr><td class="paramname">From</td><td>The indexible object from which to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the assigned object as modified </dd></dl>

<p class="definition">Definition at line <a class="el" href="assign_8hpp_source.html#l00051">51</a> of file <a class="el" href="assign_8hpp_source.html">assign.hpp</a>.</p>

</div>
</div>
<a id="a641b62efeed5cc744ce28951d6ca5601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641b62efeed5cc744ce28951d6ca5601">&#9670;&nbsp;</a></span>average_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;internal::has_uniform_fixed_vector_space_descriptors Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;Arg&gt; OpenKalman::average_reduce </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="section return"><dt>Returns</dt><dd>A scalar representing the average of all components. </dd></dl>

<p class="definition">Definition at line <a class="el" href="average__reduce_8hpp_source.html#l00085">85</a> of file <a class="el" href="average__reduce_8hpp_source.html">average_reduce.hpp</a>.</p>

</div>
</div>
<a id="a01c83504077bd3ab7538f265c37fbafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c83504077bd3ab7538f265c37fbafd">&#9670;&nbsp;</a></span>cholesky_factor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hermitian_matrix&lt; Qualification::depends_on_dynamic_shape &gt; A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a> OpenKalman::cholesky_factor </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This overload does not require specifying the TriangleType, which is either </p>
<h1><a class="anchor" id="autotoc_md12"></a>
TriangleType::diagonal if A is diagonal;</h1>
<h1><a class="anchor" id="autotoc_md13"></a>
the hermitian adapter triangle type of A, if it exists; or</h1>
<h1><a class="anchor" id="autotoc_md14"></a>
TriangleType::lower, by default.</h1>

<p class="definition">Definition at line <a class="el" href="cholesky__factor_8hpp_source.html#l00107">107</a> of file <a class="el" href="cholesky__factor_8hpp_source.html">cholesky_factor.hpp</a>.</p>

</div>
</div>
<a id="ae3eb9668bebd5c4243ff8a05def4dd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3eb9668bebd5c4243ff8a05def4dd05">&#9670;&nbsp;</a></span>cholesky_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;triangular_matrix A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires constexpr <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt;A, <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30">Qualification::depends_on_dynamic_shape</a>&gt;decltype(auto) <a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a> OpenKalman::cholesky_square </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>A square matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AA<sup>*</sup> (if A is lower <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>) or otherwise A<sup>*</sup>A. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cholesky__square_8hpp_source.html#l00033">33</a> of file <a class="el" href="cholesky__square_8hpp_source.html">cholesky_square.hpp</a>.</p>

</div>
</div>
<a id="abad3b0d5e413cdc9e6cf637e2ec3cbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad3b0d5e413cdc9e6cf637e2ec3cbd9">&#9670;&nbsp;</a></span>conjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::conjugate </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="conjugate_8hpp_source.html#l00033">33</a> of file <a class="el" href="conjugate_8hpp_source.html">conjugate.hpp</a>.</p>

</div>
</div>
<a id="a6968381bd677626dc7b09cf077e5cbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6968381bd677626dc7b09cf077e5cbcc">&#9670;&nbsp;</a></span>count_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;interface::count_indices_defined_for T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceOpenKalman.html#a8b8a5ca9cb2a660eb584981e1339b87a">index_value</a> auto OpenKalman::count_indices </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structOpenKalman_1_1index__count.html" title="The minimum number of indices need to access all the components of an object.">index_count</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="count__indices_8hpp_source.html#l00033">33</a> of file <a class="el" href="count__indices_8hpp_source.html">count_indices.hpp</a>.</p>

</div>
</div>
<a id="a0ddc3d4101bf4f5e66a21a3b52cca3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddc3d4101bf4f5e66a21a3b52cca3cb">&#9670;&nbsp;</a></span>EuclideanMean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;euclidean_transformed V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::EuclideanMean </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  EuclideanMean&lt; <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; V, 0 &gt;, <a class="el" href="namespaceOpenKalman.html#a03b16f3264522ab5b6be8215b82b7e9d">nested_object_of_t</a>&lt; V &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deduce template parameters from a typed_matrix_nestable, assuming axis-only coefficients. </p>

</div>
</div>
<a id="a14345f292887e27517c4ae21dfc23604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14345f292887e27517c4ae21dfc23604">&#9670;&nbsp;</a></span>from_euclidean_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> auto OpenKalman::from_euclidean_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>local_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>euclidean_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An element getter mapping an index i of type std::size_t to an element of <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> (e.g., <code>std::function&lt;double(std::size_t)</code>) </td></tr>
    <tr><td class="paramname">local_index</td><td>A local index accessing the coordinate in modular space. </td></tr>
    <tr><td class="paramname">euclidean_start</td><td>The starting location in Euclidean space within any larger set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="from__euclidean__element_8hpp_source.html#l00033">33</a> of file <a class="el" href="from__euclidean__element_8hpp_source.html">from_euclidean_element.hpp</a>.</p>

</div>
</div>
<a id="a468e4521e756fcbe5b3a2306513e54cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468e4521e756fcbe5b3a2306513e54cc">&#9670;&nbsp;</a></span>get_component() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Indices , std::enable_if_t&lt; indexible&lt; Arg &gt; and index_value&lt;  decltype, int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::get_component </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Indices &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The object to be accessed. </td></tr>
    <tr><td class="paramname">Indices</td><td>A sized input range containing the indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="namespaceOpenKalman.html#a72829d83ccbc836bfb60d395cd4d5331">scalar_constant</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="get__component_8hpp_source.html#l00058">58</a> of file <a class="el" href="get__component_8hpp_source.html">get_component.hpp</a>.</p>

</div>
</div>
<a id="a2e23c6db3dac174912de398cce549901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e23c6db3dac174912de398cce549901">&#9670;&nbsp;</a></span>get_component() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Indices , std::enable_if_t&lt; indexible&lt; Arg &gt; and index_value&lt; Indices &gt; and(not empty_object&lt; Arg &gt;), int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::get_component </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Indices &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="get__component_8hpp_source.html#l00076">76</a> of file <a class="el" href="get__component_8hpp_source.html">get_component.hpp</a>.</p>

</div>
</div>
<a id="a0c7c14154c4c8afd53aafaf206202e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7c14154c4c8afd53aafaf206202e0e">&#9670;&nbsp;</a></span>get_component() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename... I, std::enable_if_t&lt; indexible&lt; Arg &gt; and(... and index_value&lt; I &gt;) and(index_count&lt; Arg &gt;::value==dynamic_size or sizeof...(I) &gt;=index_count&lt; Arg &gt;::value) and(not empty_object&lt; Arg &gt;) and internal::static_indices_within_bounds&lt; Arg, I... &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::get_component </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>The number of indices must be at least <code>index_count_v&lt;Arg&gt;</code>. If the indices are integral constants, the function performs compile-time bounds checking to the extent possible. </p>

<p class="definition">Definition at line <a class="el" href="get__component_8hpp_source.html#l00120">120</a> of file <a class="el" href="get__component_8hpp_source.html">get_component.hpp</a>.</p>

</div>
</div>
<a id="a12d3edfd0e8553eafbb1983c29491114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d3edfd0e8553eafbb1983c29491114">&#9670;&nbsp;</a></span>get_vector_space_descriptor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N = 0, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires interface::get_vector_space_descriptor_defined_for&lt;T&gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> constexpr detail::count_is_zero&lt;T&gt;::value <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> auto OpenKalman::get_vector_space_descriptor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>An index value known at compile time. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="get__vector__space__descriptor_8hpp_source.html#l00100">100</a> of file <a class="el" href="get__vector__space__descriptor_8hpp_source.html">get_vector_space_descriptor.hpp</a>.</p>

</div>
</div>
<a id="af4aa86d3ef5ab79a607ecb7ce06d466f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4aa86d3ef5ab79a607ecb7ce06d466f">&#9670;&nbsp;</a></span>get_wrappable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;interface::count_indices_defined_for T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::get_wrappable </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceOpenKalman.html#a0446f0fba3feb5d14a40bf9d375ba31e" title="Specifies that every fixed-size index of T (other than potentially index 0) is euclidean.">wrappable</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="get__wrappable_8hpp_source.html#l00043">43</a> of file <a class="el" href="get__wrappable_8hpp_source.html">get_wrappable.hpp</a>.</p>

</div>
</div>
<a id="a56ae054a928c412ebde383d1274645e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ae054a928c412ebde383d1274645e8">&#9670;&nbsp;</a></span>get_wrapped_component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> auto OpenKalman::get_wrapped_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>local_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The wrapping operation is equivalent to mapping from modular space to Euclidean space and then back again, or in other words, performing <code>to_euclidean_element</code> followed by <code>from_euclidean_element<code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An element getter mapping an index i of type std::size_t to an element of <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> (e.g., <code>std::function&lt;double(std::size_t)</code>) </td></tr>
    <tr><td class="paramname">local_index</td><td>A local index accessing the element. </td></tr>
    <tr><td class="paramname">start</td><td>The starting location of the element within any larger set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a>. </td></tr>
  </table>
  </dd>
</dl>
<p></code></code></p>

<p class="definition">Definition at line <a class="el" href="get__wrapped__component_8hpp_source.html#l00034">34</a> of file <a class="el" href="get__wrapped__component_8hpp_source.html">get_wrapped_component.hpp</a>.</p>

</div>
</div>
<a id="aab8da59cacacdde8a92007912d373070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8da59cacacdde8a92007912d373070">&#9670;&nbsp;</a></span>inverse_scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;covariance M, std::convertible_to&lt; scalar_type_of_t&lt; M &gt;&gt; S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::inverse_scale </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale a covariance by the inverse of a scalar factor. Equivalent by division by the square of a scalar. For a square root covariance, this is equivalent to division by the scalar. </p>

<p class="definition">Definition at line <a class="el" href="covariance-arithmetic_8hpp_source.html#l00544">544</a> of file <a class="el" href="covariance-arithmetic_8hpp_source.html">covariance-arithmetic.hpp</a>.</p>

</div>
</div>
<a id="a1e0a0786d9c0a6ca9f3a2edc2fc89bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0a0786d9c0a6ca9f3a2edc2fc89bed">&#9670;&nbsp;</a></span>is_one_dimensional()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;interface::count_indices_defined_for T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::is_one_dimensional </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Each index also must have an equivalent <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> object. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor or matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="is__one__dimensional_8hpp_source.html#l00043">43</a> of file <a class="el" href="is__one__dimensional_8hpp_source.html">is_one_dimensional.hpp</a>.</p>

</div>
</div>
<a id="ae863fa1c417402776c130e558369c6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae863fa1c417402776c130e558369c6d4">&#9670;&nbsp;</a></span>is_square_shaped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;interface::count_indices_defined_for T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto OpenKalman::is_square_shaped </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An object is square-shaped if it has the same size and <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> type along every index (excluding trailing 1D indices). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A tensor or matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::optional which includes the <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> object if T is square. The result is convertible to <code>bool</code>: if true, then T is square. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8" title="Specifies that an object is square (i.e., has equivalent vector_space_descriptor along each dimension...">square_shaped</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="is__square__shaped_8hpp_source.html#l00063">63</a> of file <a class="el" href="is__square__shaped_8hpp_source.html">is_square_shaped.hpp</a>.</p>

</div>
</div>
<a id="a2f295961ec96698496f7ebbfd4de505e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f295961ec96698496f7ebbfd4de505e">&#9670;&nbsp;</a></span>is_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N = 0, interface::count_indices_defined_for T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::is_vector </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>In this context, a vector is an object in which every index but one is 1D. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>An index designating the "large" index (e.g., 0 for a column vector, 1 for a row vector) </td></tr>
    <tr><td class="paramname">T</td><td>A tensor or matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447" title="T is a vector (e.g., column or row vector).">vector</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="is__vector_8hpp_source.html#l00044">44</a> of file <a class="el" href="is__vector_8hpp_source.html">is_vector.hpp</a>.</p>

</div>
</div>
<a id="a8482a5fd9758debdb1214b304e765525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8482a5fd9758debdb1214b304e765525">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fixed_vector_space_descriptor FixedDescriptor, TriangleType triangle_type, typed_matrix_nestable Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt;Arg&gt; auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2Covariance_8hpp_source.html#l00914">914</a> of file <a class="el" href="adapters_2Covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a9177239a3492a45c5e2d407663429cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9177239a3492a45c5e2d407663429cdb">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TriangleType triangle_type, typed_matrix_nestable Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt; Arg &gt; auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a writable, uninitialized Covariance, with nested triangular type based on a <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2Covariance_8hpp_source.html#l00953">953</a> of file <a class="el" href="adapters_2Covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a6ab5575c973a22e0e02cb8c641e1c10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab5575c973a22e0e02cb8c641e1c10c">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;self_adjoint_covariance T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2Covariance_8hpp_source.html#l00987">987</a> of file <a class="el" href="adapters_2Covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="ae9d673fd7f55bacbd8c6257a9aa29548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d673fd7f55bacbd8c6257a9aa29548">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt;Arg&gt; auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2Covariance_8hpp_source.html#l01060">1060</a> of file <a class="el" href="adapters_2Covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a5810b2ed52134bd24e82bf47493b8c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5810b2ed52134bd24e82bf47493b8c2e">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;self_adjoint_covariance Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2Covariance_8hpp_source.html#l00970">970</a> of file <a class="el" href="adapters_2Covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a2f78757e507c466b20ccd85294e47aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f78757e507c466b20ccd85294e47aea">&#9670;&nbsp;</a></span>make_covariance() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt;Arg&gt; auto OpenKalman::make_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2Covariance_8hpp_source.html#l01005">1005</a> of file <a class="el" href="adapters_2Covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a3a81f86cc97db31634eae30b9887c5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a81f86cc97db31634eae30b9887c5fb">&#9670;&nbsp;</a></span>make_diagonal_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a> auto OpenKalman::make_diagonal_matrix </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A vector or higher-order tensor reflecting the diagonal(s). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="make__diagonal__matrix_8hpp_source.html#l00057">57</a> of file <a class="el" href="make__diagonal__matrix_8hpp_source.html">make_diagonal_matrix.hpp</a>.</p>

</div>
</div>
<a id="a756493b5adefecfb121d7dc3b7b4132e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756493b5adefecfb121d7dc3b7b4132e">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix_nestable M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new Euclidean mean is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="EuclideanMean_8hpp_source.html#l00393">393</a> of file <a class="el" href="EuclideanMean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="a4d746240ab12ed086adb0da881876812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d746240ab12ed086adb0da881876812">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt;Arg, 1&gt; auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A typed_matrix (i.e., Matrix, Mean, or EuclideanMean). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="EuclideanMean_8hpp_source.html#l00352">352</a> of file <a class="el" href="EuclideanMean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="ae2874fe45e525be71f2256270fedb857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2874fe45e525be71f2256270fedb857">&#9670;&nbsp;</a></span>make_euclidean_mean() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix_nestable M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_euclidean_mean </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="EuclideanMean_8hpp_source.html#l00335">335</a> of file <a class="el" href="EuclideanMean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="a4d1ed2a363bd8790676ea87e9ccb5029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1ed2a363bd8790676ea87e9ccb5029">&#9670;&nbsp;</a></span>make_GaussianDistribution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix M, covariance Cov, std::uniform_random_bit_generator re = std::mt19937&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a>&lt;M&gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt;M, 1&gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt;<a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt;M, 0&gt;, <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt;Cov, 0&gt; &gt; auto OpenKalman::make_GaussianDistribution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>. </td></tr>
    <tr><td class="paramname">Cov</td><td>A <a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a>. </td></tr>
    <tr><td class="paramname">re</td><td>A random number engine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespaceOpenKalman.html#a2e676386d6ed5b7749578d8a4e966d96">gaussian_distribution</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="GaussianDistribution_8hpp_source.html#l00652">652</a> of file <a class="el" href="GaussianDistribution_8hpp_source.html">GaussianDistribution.hpp</a>.</p>

</div>
</div>
<a id="ada5c83f78a68c000f6365c4f1601eb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5c83f78a68c000f6365c4f1601eb22">&#9670;&nbsp;</a></span>make_GaussianDistribution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;gaussian_distribution D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_GaussianDistribution </td>
          <td>(</td>
          <td class="paramtype">D &amp;&amp;&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>Another <a class="el" href="namespaceOpenKalman.html#a2e676386d6ed5b7749578d8a4e966d96">gaussian_distribution</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespaceOpenKalman.html#a2e676386d6ed5b7749578d8a4e966d96">gaussian_distribution</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="GaussianDistribution_8hpp_source.html#l00494">494</a> of file <a class="el" href="GaussianDistribution_8hpp_source.html">GaussianDistribution.hpp</a>.</p>

</div>
</div>
<a id="a4aaf087f2ae09405e334c02bd396e8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aaf087f2ae09405e334c02bd396e8fa">&#9670;&nbsp;</a></span>make_identity_matrix_like() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;scalar_type Scalar, indexible Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceOpenKalman.html#a2a52b813621d6f1567234b83e0cad2bb">identity_matrix</a> auto OpenKalman::make_identity_matrix_like </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The matrix or array on which the new identity matrix is patterned. It need not be square. </td></tr>
    <tr><td class="paramname">Scalar</td><td>A scalar type for the new matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An identity matrix of the same dimensions as Arg (even if not square). </dd></dl>

<p class="definition">Definition at line <a class="el" href="make__identity__matrix__like_8hpp_source.html#l00088">88</a> of file <a class="el" href="make__identity__matrix__like_8hpp_source.html">make_identity_matrix_like.hpp</a>.</p>

</div>
</div>
<a id="a810cb1bd7aec431e68f50c081cc9f295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810cb1bd7aec431e68f50c081cc9f295">&#9670;&nbsp;</a></span>make_identity_matrix_like() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceOpenKalman.html#a2a52b813621d6f1567234b83e0cad2bb">identity_matrix</a> auto OpenKalman::make_identity_matrix_like </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The matrix or array on which the new zero matrix is patterned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An identity matrix of the same dimensions as Arg (even if not square). </dd></dl>

<p class="definition">Definition at line <a class="el" href="make__identity__matrix__like_8hpp_source.html#l00110">110</a> of file <a class="el" href="make__identity__matrix__like_8hpp_source.html">make_identity_matrix_like.hpp</a>.</p>

</div>
</div>
<a id="a5b34fbabbe7b5ab3293412cf4bd24d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b34fbabbe7b5ab3293412cf4bd24d80">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix_nestable M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new mean is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="adapters_2Mean_8hpp_source.html#l00497">497</a> of file <a class="el" href="adapters_2Mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="ac6ac38809e1f1fcee2f556ffde613c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ac38809e1f1fcee2f556ffde613c51">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt;Arg, 1&gt; auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A typed_matrix (i.e., Matrix, Mean, or EuclideanMean). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="adapters_2Mean_8hpp_source.html#l00455">455</a> of file <a class="el" href="adapters_2Mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="aa07b02c4880d0e72ef0e96b05624fb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07b02c4880d0e72ef0e96b05624fb48">&#9670;&nbsp;</a></span>make_mean() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix_nestable M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_mean </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2Mean_8hpp_source.html#l00438">438</a> of file <a class="el" href="adapters_2Mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="a606ee0d83d6a4f542a876b81a454cb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606ee0d83d6a4f542a876b81a454cb1d">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg requires <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a>&lt;Arg&gt; auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a writable, uninitialized SquareRootCovariance based on a <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>.</p>
<p>Make a writable, uninitialized SquareRootCovariance from a <a class="el" href="namespaceOpenKalman.html#a8b3391652c86c0ea55fa64d7aa61216a">triangular_covariance</a>.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2SquareRootCovariance_8hpp_source.html#l00759">759</a> of file <a class="el" href="adapters_2SquareRootCovariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="a0bd09652a3ae438b68339b039ec3a735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd09652a3ae438b68339b039ec3a735">&#9670;&nbsp;</a></span>make_square_root_covariance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;covariance_nestable Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::make_square_root_covariance </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a SquareRootCovariance based on another <a class="el" href="namespaceOpenKalman.html#a8b3391652c86c0ea55fa64d7aa61216a">triangular_covariance</a>.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedDescriptor</td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2SquareRootCovariance_8hpp_source.html#l00691">691</a> of file <a class="el" href="adapters_2SquareRootCovariance_8hpp_source.html">SquareRootCovariance.hpp</a>.</p>

</div>
</div>
<a id="aef005135c9c2fe905e52a3f722efdac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef005135c9c2fe905e52a3f722efdac6">&#9670;&nbsp;</a></span>make_zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> constexpr T <a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a> auto OpenKalman::make_zero </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>The new scalar type is also derived from T. </p>

<p class="definition">Definition at line <a class="el" href="make__zero_8hpp_source.html#l00057">57</a> of file <a class="el" href="make__zero_8hpp_source.html">make_zero.hpp</a>.</p>

</div>
</div>
<a id="a13ce51f24958dff5bdd6adcdf5390e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ce51f24958dff5bdd6adcdf5390e1a">&#9670;&nbsp;</a></span>Mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix_nestable V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires (<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt;RowCoefficients&gt; == index_dimension_of_v&lt;NestedMatrix, 0&gt;) <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> (not std OpenKalman::Mean </td>
          <td>(</td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  Mean&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1Dimensions.html">Dimensions</a>&lt; index_dimension_of_v&lt; V, 0 &gt;&gt;, passable_t&lt; V &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deduce template parameters from a typed_matrix_nestable, assuming untyped <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a>. </p>

</div>
</div>
<a id="a09023dc82cbe71e465ac32184fd325c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09023dc82cbe71e465ac32184fd325c3">&#9670;&nbsp;</a></span>nested_object()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;has_nested_object Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::nested_object </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">i</td><td>Index of the nested matrix (0 for the 1st, 1 for the 2nd, etc.). </td></tr>
    <tr><td class="paramname">Arg</td><td>A wrapper that has at least one nested object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>interface::indexible_object_traits::nested_object </dd></dl>

<p class="definition">Definition at line <a class="el" href="nested__object_8hpp_source.html#l00034">34</a> of file <a class="el" href="nested__object_8hpp_source.html">nested_object.hpp</a>.</p>

</div>
</div>
<a id="a689b926c307aee8a9b8c177b1c7a389f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689b926c307aee8a9b8c177b1c7a389f">&#9670;&nbsp;</a></span>or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;vector&lt; 0, Qualification::depends_on_dynamic_shape &gt; Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#ab737b3bbdad3ee74c92a344a6a18c447">vector</a>&lt;Arg&gt; OpenKalman::or </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>&lt; Arg &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="structOpenKalman_1_1DiagonalMatrix.html">DiagonalMatrix</a>&lt; passable_t&lt; Arg &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A column vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a657983b53745e10f84cc229af98a0978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657983b53745e10f84cc229af98a0978">&#9670;&nbsp;</a></span>QR_decomposition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>&lt;<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">TriangleType::upper</a>&gt; OpenKalman::QR_decomposition </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>U as an upper <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="QR__decomposition_8hpp_source.html#l00033">33</a> of file <a class="el" href="QR__decomposition_8hpp_source.html">QR_decomposition.hpp</a>.</p>

</div>
</div>
<a id="a7b41f709d7fda5e8641b771bcc99c9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b41f709d7fda5e8641b771bcc99c9d0">&#9670;&nbsp;</a></span>rank_update_hermitian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hermitian_matrix&lt; Qualification::depends_on_dynamic_shape &gt; A, indexible U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#acb4ff0c32c70ea24cfc42faaa4ae58d2">dimension_size_of_index_is</a>&lt;U, 0, index_dimension_of_v&lt;A, 0&gt;, <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30">Qualification::depends_on_dynamic_shape</a>&gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#acb4ff0c32c70ea24cfc42faaa4ae58d2">dimension_size_of_index_is</a>&lt;U, 0, index_dimension_of_v&lt;A, 1&gt;, <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30">Qualification::depends_on_dynamic_shape</a>&gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> std::convertible_to&lt;<a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;U&gt;, const <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;A&gt; &gt;decltype(auto) <a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a> OpenKalman::rank_update_hermitian </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; A &gt;&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This may (or may not) be performed as an in-place operation if argument A is writable and hermitian.</dd></dl>
<p>The update is A += UU<sup>*</sup>, returning the updated hermitian A. If A is an lvalue reference, hermitian, and writable, it will be updated in place and the return value will be an lvalue reference to the same, updated A. Otherwise, the function returns a new matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The hermitian matrix to be rank updated. </td></tr>
    <tr><td class="paramname">U</td><td>The update vector or matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an updated native, writable matrix in hermitian form. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rank__update__hermitian_8hpp_source.html#l00045">45</a> of file <a class="el" href="rank__update__hermitian_8hpp_source.html">rank_update_hermitian.hpp</a>.</p>

</div>
</div>
<a id="a68ce1958c2e246aca54146613ee31339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ce1958c2e246aca54146613ee31339">&#9670;&nbsp;</a></span>rank_update_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;triangular_matrix&lt; TriangleType::any &gt; A, indexible U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires <a class="el" href="namespaceOpenKalman.html#acb4ff0c32c70ea24cfc42faaa4ae58d2">dimension_size_of_index_is</a>&lt;U, 0, index_dimension_of_v&lt;A, 0&gt;, <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30">Qualification::depends_on_dynamic_shape</a>&gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> <a class="el" href="namespaceOpenKalman.html#acb4ff0c32c70ea24cfc42faaa4ae58d2">dimension_size_of_index_is</a>&lt;U, 0, index_dimension_of_v&lt;A, 1&gt;, <a class="el" href="namespaceOpenKalman.html#a3d8d9ff3bc2be3b04457b2ae3df89832a6b95fbc11c80f40b0df15be03809cf30">Qualification::depends_on_dynamic_shape</a>&gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> std::convertible_to&lt;<a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;U&gt;, const <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;A&gt; &gt;decltype(auto) <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>&lt;<a class="el" href="namespaceOpenKalman.html#ac8913d4eca256134749dc085bf617466">triangle_type_of_v</a>&lt;A&gt; == <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">TriangleType::upper</a> ? <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">TriangleType::upper</a> : <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba81e073b428b50247daba38531dcf412a">TriangleType::lower</a>&gt; OpenKalman::rank_update_triangular </td>
          <td>(</td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; A &gt;&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This may (or may not) be performed as an in-place operation if argument A is writable.</dd></dl>
<ul>
<li>If A is lower-triangular, diagonal, or one-by-one, the update is AA<sup>*</sup> += UU<sup>*</sup>, returning the updated A.</li>
<li>If A is upper-triangular, the update is A<sup>*</sup>A += UU<sup>*</sup>, returning the updated A.</li>
<li>If A is an lvalue reference and is writable, it will be updated in place and the return value will be an lvalue reference to the same, updated A. Otherwise, the function returns a new matrix. <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The matrix to be rank updated. </td></tr>
    <tr><td class="paramname">U</td><td>The update vector or matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an updated native, writable matrix in triangular (or diagonal) form. </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="rank__update__triangular_8hpp_source.html#l00048">48</a> of file <a class="el" href="rank__update__triangular_8hpp_source.html">rank_update_triangular.hpp</a>.</p>

</div>
</div>
<a id="a2a9995d627138ebb17ba9e7363a319e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9995d627138ebb17ba9e7363a319e1">&#9670;&nbsp;</a></span>reduce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t index, std::size_t... indices, typename BinaryFunction , internal::has_uniform_fixed_vector_space_descriptors&lt; index, indices... &gt; Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires constexpr std::is_invocable_r_v&lt;<a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;Arg&gt;, BinaryFunction&amp;&amp;, <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;Arg&gt;, <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;Arg&gt; &gt;decltype(auto) <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> OpenKalman::reduce </td>
          <td>(</td>
          <td class="paramtype">BinaryFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The binary function must be associative. (This is not enforced, but the order of operation is undefined.) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index</td><td>an index to be reduced. For example, if the index is 0, the result will have only one row. If the index is 1, the result will have only one column. </td></tr>
    <tr><td class="paramname">indices</td><td>Other indices to be reduced. Because the binary function is associative, the order of the indices does not matter. </td></tr>
    <tr><td class="paramname">BinaryFunction</td><td>A binary function invocable with two values of type <code>scalar_type_of_t&lt;Arg&gt;</code>. It must be an associative function. Preferably, it should be a constexpr function, and even more preferably, it should be a standard c++ function such as std::plus or std::multiplies. </td></tr>
    <tr><td class="paramname">Arg</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector or tensor with reduced dimensions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="reduce_8hpp_source.html#l00143">143</a> of file <a class="el" href="reduce_8hpp_source.html">reduce.hpp</a>.</p>

</div>
</div>
<a id="a07bf477a67e664cf9838c07e15a327f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bf477a67e664cf9838c07e15a327f5">&#9670;&nbsp;</a></span>reduce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BinaryFunction , internal::has_uniform_fixed_vector_space_descriptors Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires constexpr std::is_invocable_r_v&lt;<a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;Arg&gt;, BinaryFunction&amp;&amp;, <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;Arg&gt;, <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;Arg&gt; &gt; <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt;Arg&gt; OpenKalman::reduce </td>
          <td>(</td>
          <td class="paramtype">const BinaryFunction &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Arg &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>The binary function must be associative. (This is not enforced, but the order of operation is undefined.) </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">BinaryFunction</td><td>A binary function invocable with two values of type <code>scalar_type_of_t&lt;Arg&gt;</code>. It must be an associative function. Preferably, it should be a constexpr function, and even more preferably, it should be a standard c++ function such as std::plus or std::multiplies. </td></tr>
    <tr><td class="paramname">Arg</td><td>The tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A scalar representing a complete reduction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="reduce_8hpp_source.html#l00180">180</a> of file <a class="el" href="reduce_8hpp_source.html">reduce.hpp</a>.</p>

</div>
</div>
<a id="a33a641e63358c6f36058cdd8380538b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a641e63358c6f36058cdd8380538b4">&#9670;&nbsp;</a></span>requires() <span class="overload">[1/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible PatternMatrix, std::size_t... indices, std::uniform_random_bit_generator random_number_generator, vector_space_descriptor... Ds, typename... Dists&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; std::tuple_element_t&lt; indices, std::tuple&lt; Ds... &gt;&gt;&gt;)&#160;</td>
          <td class="paramname"><em>and ...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is essentially a specialized version of n_ary_operation with the nullary operator being a randomization function. The distributions are allocated to each element of the object, according to one of the following options:</p><ul>
<li>One distribution for all elements. The following example constructs a 2-by-2 matrix (m) in which each element is a random value selected based on a distribution with mean 1.0 and standard deviation 0.3: <div class="fragment"><div class="line"><span class="keyword">using</span> N = std::normal_distribution&lt;double&gt;;</div>
<div class="line"><span class="keyword">using</span> Mat = Eigen::Matrix&lt;double, 2, 2&gt;;</div>
<div class="line"><span class="keyword">auto</span> g = std::mt19937 {};</div>
<div class="line">Mat m = randomize&lt;Mat&gt;(g, std::tuple {2, 2}, N {1.0, 0.3}));</div>
</div><!-- fragment --></li>
<li>One distribution for each element. The following code constructs a 2-by-2 matrix m containing random values around mean 1.0, 2.0, 3.0, and 4.0 (in row-major order), with standard deviations of 0.3, 0.3, 0.0 (by default, since no s.d. is specified as a parameter), and 0.3: <div class="fragment"><div class="line"><span class="keyword">using</span> N = std::normal_distribution&lt;double&gt;;</div>
<div class="line"><span class="keyword">auto</span> m = randomize&lt;Eigen::Matrix&lt;double, 2, 2&gt;, 0, 1&gt;(g,</div>
<div class="line">  std::tuple {Dimensions&lt;2&gt;{}, Dimensions&lt;2&gt;{}}, N {1.0, 0.3}, N {2.0, 0.3}, 3.0, N {4.0, 0.3})));</div>
</div><!-- fragment --></li>
<li>One distribution for each row. The following code constructs a 3-by-2 (n) or 2-by-2 (o) matrices in which elements in each row are selected according to the three (n) or two (o) listed distribution parameters: <div class="fragment"><div class="line"><span class="keyword">auto</span> n = randomize&lt;Eigen::Matrix&lt;double, 3, 2&gt;, 0&gt;(g, std::tuple {Dimensions&lt;3&gt;{}, 2},</div>
<div class="line">  N {1.0, 0.3}, 2.0, N {3.0, 0.3})));</div>
<div class="line"><span class="keyword">auto</span> o = randomize&lt;Eigen::Matrix&lt;double, 2, 2&gt;, 0&gt;(g, std::tuple {Dimensions&lt;2&gt;{}, 2},</div>
<div class="line">  N {1.0, 0.3}, N {2.0, 0.3})));</div>
</div><!-- fragment --></li>
<li>One distribution for each column. The following code constructs 2-by-3 matrix p in which elements in each column are selected according to the three listed distribution parameters: <div class="fragment"><div class="line"><span class="keyword">auto</span> p = randomize&lt;Eigen::Matrix&lt;double, 2, 3&gt;, 1&gt;(g, std::tuple {2, Dimensions&lt;3&gt;{}},</div>
<div class="line">  N {1.0, 0.3}, 2.0, N {3.0, 0.3})));</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PatternMatrix</td><td>An indexible object corresponding to the result type. Its dimensions need not match the specified dimensions Ds </td></tr>
    <tr><td class="paramname">indices</td><td>The indices, if any, for which there is a distinct distribution. If not provided, this can in some cases be inferred from the number of Dists provided. </td></tr>
    <tr><td class="paramname">random_number_generator</td><td>The random number generator (e.g., std::mt19937). </td></tr>
    <tr><td class="paramname">Ds</td><td><a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> objects for each index the result. They need not correspond to the dimensions of PatternMatrix. </td></tr>
    <tr><td class="paramname">Dists</td><td>One or more distributions (e.g., std::normal_distribution&lt;double&gt;) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>n_ary_operation </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a644162964434183513f9d121ec4ec21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644162964434183513f9d121ec4ec21e">&#9670;&nbsp;</a></span>requires() <span class="overload">[2/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible PatternMatrix, std::size_t... indices, vector_space_descriptor... Ds, typename... Operations&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">(<a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; std::tuple_element_t&lt; indices, std::tuple&lt; Ds... &gt;&gt;&gt;)&#160;</td>
          <td class="paramname"><em>and ...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Examples:</p><ul>
<li>One operation for the entire matrix <div class="fragment"><div class="line"><span class="keyword">auto</span> ds23 = std::tuple {Dimensions&lt;2&gt;{}, Dimensions&lt;3&gt;{}};</div>
<div class="line"><span class="keyword">auto</span> M = Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt;</div>
<div class="line">std::cout &lt;&lt; n_ary_operation&lt;M&gt;(ds23, [](<span class="keyword">auto</span> arg){<span class="keywordflow">return</span> 7;}) &lt;&lt; std::endl;</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">7, 7, 7,</div>
<div class="line">7, 7, 7</div>
</div><!-- fragment --></li>
<li>One operation for each element <div class="fragment"><div class="line">std::cout &lt;&lt; n_ary_operation&lt;M, 0, 1&gt;(ds23, []{<span class="keywordflow">return</span> 4;}, []{<span class="keywordflow">return</span> 5;}, []{<span class="keywordflow">return</span> 6;}, []{<span class="keywordflow">return</span> 7;}, []{<span class="keywordflow">return</span> 8;}, []{<span class="keywordflow">return</span> 9;});</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">4, 5, 6,</div>
<div class="line">7, 8, 9</div>
</div><!-- fragment --></li>
<li>One operation for each row <div class="fragment"><div class="line"><span class="keyword">auto</span> ds23a = std::tuple {Dimensions&lt;2&gt;{}, Dimensions{3}};</div>
<div class="line">std::cout &lt;&lt; n_ary_operation&lt;M, 0&gt;(ds23a, []{<span class="keywordflow">return</span> 5;}, []{<span class="keywordflow">return</span> 6;});</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">5, 5, 5,</div>
<div class="line">6, 6, 6</div>
</div><!-- fragment --></li>
<li>One operation for each column <div class="fragment"><div class="line"><span class="keyword">auto</span> ds23b = std::tuple {Dimensions{2}, Dimensions&lt;3&gt;{}};</div>
<div class="line">std::cout &lt;&lt; n_ary_operation&lt;M, 1&gt;(ds23b, []{<span class="keywordflow">return</span> 5;}, []{<span class="keywordflow">return</span> 6;}, []{<span class="keywordflow">return</span> 7;});</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">5, 6, 7,</div>
<div class="line">5, 6, 7</div>
</div><!-- fragment --></li>
<li>One operation for each column, with indices <div class="fragment"><div class="line"><span class="keyword">auto</span> ds23b = std::tuple {Dimensions{2}, Dimensions&lt;3&gt;{}};</div>
<div class="line"><span class="keyword">auto</span> op1 = [](std::size_t r, std::size_t c){ <span class="keywordflow">return</span> 5 + r + c; };</div>
<div class="line"><span class="keyword">auto</span> op2 = [](std::size_t r, std::size_t c){ <span class="keywordflow">return</span> 6 + r + c; };</div>
<div class="line"><span class="keyword">auto</span> op3 = [](std::size_t r, std::size_t c){ <span class="keywordflow">return</span> 7 + r + c; };</div>
<div class="line">std::cout &lt;&lt; n_ary_operation&lt;M, 1&gt;(ds23b, []{<span class="keywordflow">return</span> 5;}, []{<span class="keywordflow">return</span> 6;}, []{<span class="keywordflow">return</span> 7;});</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">5, 7, 9,</div>
<div class="line">6, 8, 10</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PatternMatrix</td><td>A matrix or array corresponding to the result type. Its purpose is to indicate the library from which to create a resulting matrix, and its dimensions need not match the specified dimensions Ds </td></tr>
    <tr><td class="paramname">indices</td><td>The indices, if any, along which there will be a different operator for each element along that index. </td></tr>
    <tr><td class="paramname">Ds</td><td><a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> objects for each index of the result. <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> objects corresponding to indices must be of a <a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a> type. </td></tr>
    <tr><td class="paramname">Operations</td><td>The nullary operations. The number of operations must equal the product of each dimension Ds corresponding to indices. The order of the operations depends on the order of indices, with the left-most index being the most major, and the right-most index being the most minor. For example, if indices are {0, 1} for a matrix result, the operations must be in row-major order. If the indices are {1, 0}, the operations must be in column-major order. Each operation may be invocable with no arguments or invocable with as many indices as there are <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> Ds. (If the index corresponds to one of designaged <code>indices</code>, then the operation will be called with <code>std::integral_constant&lt;std::size_t, <em>index</em>&gt;{}</code> for that index, instead of <code>std::size_t</code>.)) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix or array in which each component is the result of calling Operation and which has dimensions corresponding to Ds </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a22044e4971a0bb5c7d30297c5c0c1a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22044e4971a0bb5c7d30297c5c0c1a90">&#9670;&nbsp;</a></span>requires() <span class="overload">[3/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible T, Layout layout = Layout::none, scalar_type S = scalar_type_of_t&lt;T&gt;, std::integral auto... D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">(std::is_integral_v&lt; decltype(D)&gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> D &gt;=0)&#160;</td>
          <td class="paramname"><em>and ...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or array from the relevant matrix library. </td></tr>
    <tr><td class="paramname">layout</td><td>The /ref Layout of the result. </td></tr>
    <tr><td class="paramname">S</td><td>A scalar type (may or may not be scalar_type_of_t&lt;T&gt;. </td></tr>
    <tr><td class="paramname">D</td><td>Integral values defining the dimensions of the new matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e4a36e61209a0b9363824ad1c155fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4a36e61209a0b9363824ad1c155fdb">&#9670;&nbsp;</a></span>requires() <span class="overload">[4/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible Arg, index_value... Factors&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">... &#160;</td>
          <td class="paramname"><em>and</em>dynamic_index_value&lt; Factors &gt; or requires { requires Factors::value &gt; 0;}</td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The operation may increase the order of the object by specifying factors greater than 1 for higher indices. Any such higher indices will have a <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> of <code>Dimensions&lt;n&gt;<code> where <code>n</code> is the factor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The object. </td></tr>
    <tr><td class="paramname">Factors</td><td>A set of factors, each an <a class="el" href="namespaceOpenKalman.html#a8b8a5ca9cb2a660eb584981e1339b87a">index_value</a>, indicating the increase in size of each index. Any omitted trailing factors are treated as factor 1 (no broadcasting along that index). </td></tr>
  </table>
  </dd>
</dl>
<p></code></code></p>

</div>
</div>
<a id="a853f3380f60f775ca40e8c0849f5678c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853f3380f60f775ca40e8c0849f5678c">&#9670;&nbsp;</a></span>requires() <span class="overload">[5/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;interface::count_indices_defined_for T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires interface::get_vector_space_descriptor_defined_for&lt; T &gt; <a class="el" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a> OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a tuple of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> defining the dimensions of T.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or array</td></tr>
  </table>
  </dd>
</dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>This overload is only enabled if all dimensions of T are known at compile time. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="all__vector__space__descriptors_8hpp_source.html#l00039">39</a> of file <a class="el" href="all__vector__space__descriptors_8hpp_source.html">all_vector_space_descriptors.hpp</a>.</p>

</div>
</div>
<a id="a7427f719088d74894a03c68f0bfdb778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7427f719088d74894a03c68f0bfdb778">&#9670;&nbsp;</a></span>requires() <span class="overload">[6/60]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg Arg OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>&lt; Arg &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>&lt; Arg &gt;                                                                &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a writable, uninitialized SquareRootCovariance from a <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> or <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>.</p>
<p>Make a writable, uninitialized SquareRootCovariance from a <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a> or <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>The coefficients will be Axis.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2Covariance_8hpp_source.html#l00883">883</a> of file <a class="el" href="adapters_2Covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a8438538fe4e22ca1adba45e0f2a9e21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8438538fe4e22ca1adba45e0f2a9e21d">&#9670;&nbsp;</a></span>requires() <span class="overload">[7/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fixed_vector_space_descriptor FixedDescriptor, TriangleType triangle_type, covariance_nestable Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;                                                                                     &#160;</td>
          <td class="paramname"> = <code>=&#160;index_dimension_of_v&lt;Arg,&#160;0&gt;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedDescriptor</td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower, diagonal). </td></tr>
    <tr><td class="paramname">Arg</td><td>A <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a> with size matching FixedDescriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a389f725d61029bd7034f2723b3bf37a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389f725d61029bd7034f2723b3bf37a2">&#9670;&nbsp;</a></span>requires() <span class="overload">[8/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fixed_vector_space_descriptor FixedDescriptor, covariance_nestable Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;       &#160;</td>
          <td class="paramname"> = <code>=&#160;index_dimension_of_v&lt;Arg,&#160;0&gt;</code></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a SquareRootCovariance from a <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>, specifying the coefficients.</p>
<p>Make a Mean from a typed_matrix_nestable, specifying the row fixed_vector_space_descriptor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedDescriptor</td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">Arg</td><td>A <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a> with size matching FixedDescriptor.</td></tr>
    <tr><td class="paramname">FixedDescriptor</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>A typed_matrix_nestable with size matching ColumnCoefficients. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="adapters_2Covariance_8hpp_source.html#l00728">728</a> of file <a class="el" href="adapters_2Covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="a1bfc60abb9ea187ae2a341af555a26ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfc60abb9ea187ae2a341af555a26ab">&#9670;&nbsp;</a></span>requires() <span class="overload">[9/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fixed_vector_space_descriptor RowCoefficients, fixed_vector_space_descriptor ColumnCoefficients, typed_matrix_nestable NestedMatrix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt; RowCoefficients &gt;&#160;</td>
          <td class="paramname"> = <code>=index_dimension_of_v&lt;&#160;NestedMatrix,&#160;0&#160;&gt;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">== index_dimension_of_v&lt;NestedMatrix, 1&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (not std::is_rvalue_reference_v&lt;NestedMatrix&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (dynamic_vector_space_descriptor&lt;RowCoefficients&gt; == dynamic_dimension&lt;NestedMatrix, 0&gt;) <a class="code" href="namespaceOpenKalman_1_1internal.html#a53169174d184acbdedc1cc4ea339a542">and</a></div>
<div class="line">    (dynamic_vector_space_descriptor&lt;ColumnCoefficients&gt; == dynamic_dimension&lt;NestedMatrix, 1&gt;)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>Matrix</div>
</div><!-- fragment --><p>It is a wrapper for a native matrix type from a supported matrix library such as Eigen. The matrix can be thought of as a tests from X to Y, where the coefficients for each of X and Y are typed. Example declarations:</p><ul>
<li><code>Matrix&lt;FixedDescriptor&lt;Axis, Axis, angle::Radians&gt;, FixedDescriptor&lt;Axis, Axis&gt;, eigen_matrix_t&lt;double, 3, 2&gt;&gt; x;</code></li>
<li><code>Matrix&lt;double, FixedDescriptor&lt;Axis, Axis, angle::Radians&gt;, FixedDescriptor&lt;Axis, Axis&gt;, eigen_matrix_t&lt;double, 3, 2&gt;&gt; x;</code> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RowCoefficients</td><td>A set of coefficients (e.g., Axis, Spherical, etc.) corresponding to the rows. </td></tr>
    <tr><td class="paramname">ColumnCoefficients</td><td>Another set of coefficients corresponding to the columns. </td></tr>
    <tr><td class="paramname">NestedMatrix</td><td>The underlying native matrix or matrix expression. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ac41b180a0cc4fc25400b148416966af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41b180a0cc4fc25400b148416966af0">&#9670;&nbsp;</a></span>requires() <span class="overload">[10/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;vector_space_descriptor T, index_value Offset, index_value Extent&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#a04ca7c438cbddb3fd487e299c4d185ea">dynamic_index_value</a>&lt; Offset &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> Offset::value &gt;=&#160;</td>
          <td class="paramname"><em>0</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">offset</td><td>The beginning location of the slice. </td></tr>
    <tr><td class="paramname">extent</td><td>The size of the slize. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="get__vector__space__descriptor__slice_8hpp_source.html#l00097">97</a> of file <a class="el" href="get__vector__space__descriptor__slice_8hpp_source.html">get_vector_space_descriptor_slice.hpp</a>.</p>

</div>
</div>
<a id="a0e049482086d430a8cfd7d538de5a02a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e049482086d430a8cfd7d538de5a02a">&#9670;&nbsp;</a></span>requires() <span class="overload">[11/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;wrappable Arg, vector_space_descriptor V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#a31eae8386d50ed98dc96326732ef9234">dynamic_vector_space_descriptor</a>&lt; V &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a6e91b2f6875a87b261fa4929a5ab00c8">dynamic_dimension</a>&lt; Arg, 0 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a2865e545918d7edd76731d5fe5f1e57f">has_untyped_index</a>&lt; Arg, 0 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a7f7ac95c22475788a1bc2adf9315ba5d">equivalent_to</a>&lt; V, <a class="el" href="namespaceOpenKalman.html#ad41181972b06178290c0a128453ed5ed">vector_space_descriptor_of_t</a>&lt; Arg, 0 &gt;&gt;                &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A matrix or tensor. </td></tr>
    <tr><td class="paramname">V</td><td>The new vector space descriptor of index 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac95e245ac127ab6485c5620d73bdcc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95e245ac127ab6485c5620d73bdcc45">&#9670;&nbsp;</a></span>requires() <span class="overload">[12/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fixed_vector_space_descriptor FixedDescriptor, typed_matrix_nestable M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#a399b0547d1b74a66dd68157b927b3e5d">euclidean_dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;                                                                             &#160;</td>
          <td class="paramname"> = <code>=&#160;index_dimension_of_v&lt;M,&#160;0&gt;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedDescriptor</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new matrix is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="EuclideanMean_8hpp_source.html#l00370">370</a> of file <a class="el" href="EuclideanMean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="a259728001228946002a0af7de1d0d3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259728001228946002a0af7de1d0d3ff">&#9670;&nbsp;</a></span>requires() <span class="overload">[13/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fixed_vector_space_descriptor FixedDescriptor, typed_matrix_nestable M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#a399b0547d1b74a66dd68157b927b3e5d">euclidean_dimension_size_of_v</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a> &gt;                        &#160;</td>
          <td class="paramname"> = <code>=&#160;index_dimension_of_v&lt;M,&#160;0&gt;</code></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedDescriptor</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>A typed_matrix_nestable with size matching ColumnCoefficients. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="EuclideanMean_8hpp_source.html#l00314">314</a> of file <a class="el" href="EuclideanMean_8hpp_source.html">EuclideanMean.hpp</a>.</p>

</div>
</div>
<a id="ad7ac94f121a52f7fe8274cbea98a020d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ac94f121a52f7fe8274cbea98a020d">&#9670;&nbsp;</a></span>requires() <span class="overload">[14/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;distribution Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#a4a4a660c145525d68a44fad81f52d1b9">euclidean_vector_space_descriptor</a>&lt; <a class="el" href="namespaceOpenKalman.html#a30391ef8ac72c2cbb79acee7ab1fd90f">ColumnCoefficients</a> &gt;            &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract a stochastic value to each column of the matrix, based on a distribution. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2Matrix_8hpp_source.html#l00212">212</a> of file <a class="el" href="adapters_2Matrix_8hpp_source.html">Matrix.hpp</a>.</p>

</div>
</div>
<a id="a013d327a3160b745be215edbae838908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013d327a3160b745be215edbae838908">&#9670;&nbsp;</a></span>requires() <span class="overload">[15/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;square_shaped&lt; Qualification::depends_on_dynamic_shape &gt; Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">index_count_v&lt; Arg &gt;                                                                               &#160;</td>
          <td class="paramname"> = <code>=&#160;<a class="el" href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">dynamic_size</a>&#160;<a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a>&#160;index_count_v&lt;Arg&gt;&#160;&lt;=&#160;2</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb49017fa9becb89a9c9f1f1eeb6cfe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb49017fa9becb89a9c9f1f1eeb6cfe4">&#9670;&nbsp;</a></span>requires() <span class="overload">[16/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;square_shaped&lt; Qualification::depends_on_dynamic_shape &gt; NestedMatrix, HermitianAdapterType storage_triangle&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">index_count_v&lt; NestedMatrix &gt;&lt;=&#160;</td>
          <td class="paramname"><em>2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">== HermitianAdapterType::lower <a class="code" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> storage_triangle == HermitianAdapterType::upper) and</div>
<div class="line">    (not constant_matrix&lt;NestedMatrix&gt; or <a class="code" href="namespaceOpenKalman.html#a6865fd1e6b35c6be70b2f464dfd6497b">real_axis_number</a>&lt;constant_coefficient&lt;NestedMatrix&gt;&gt;) <a class="code" href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">and</a></div>
<div class="line">    (not constant_diagonal_matrix&lt;NestedMatrix&gt; or <a class="code" href="namespaceOpenKalman.html#a6865fd1e6b35c6be70b2f464dfd6497b">real_axis_number</a>&lt;constant_diagonal_coefficient&lt;NestedMatrix&gt;&gt;) and</div>
<div class="line">    (not <a class="code" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>&lt;NestedMatrix, <a class="code" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a>::any&gt; or <a class="code" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a>&lt;NestedMatrix, static_cast&lt;<a class="code" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a>&gt;(storage_triangle)&gt;)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  struct <a class="code" href="namespaceOpenKalman.html#a4e79984a568eff69b0cfc035563f193f">SelfAdjointMatrix</a></div>
<div class="ttc" id="anamespaceOpenKalman_html_a04d7114313206e555dfb932ccc82209b"><div class="ttname"><a href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">OpenKalman::TriangleType</a></div><div class="ttdeci">TriangleType</div><div class="ttdoc">The type of a triangular matrix.</div><div class="ttdef"><b>Definition:</b> <a href="global-definitions_8hpp_source.html#l00060">global-definitions.hpp:60</a></div></div>
<div class="ttc" id="anamespaceOpenKalman_html_a097e8249617b8aad6bc0dc736f93bda1"><div class="ttname"><a href="namespaceOpenKalman.html#a097e8249617b8aad6bc0dc736f93bda1">OpenKalman::and</a></div><div class="ttdeci">requires equivalent_to&lt; vector_space_descriptor_of_t&lt; A, 0 &gt;::ColumnCoefficients, typename MatrixTraits&lt; std::decay_t&lt; M &gt; &gt; &gt; and(not euclidean_transformed&lt; A &gt;) inline auto scale(M &amp;&amp;m</div><div class="ttdoc">Scale a covariance by a matrix.</div></div>
<div class="ttc" id="anamespaceOpenKalman_html_a4e79984a568eff69b0cfc035563f193f"><div class="ttname"><a href="namespaceOpenKalman.html#a4e79984a568eff69b0cfc035563f193f">OpenKalman::SelfAdjointMatrix</a></div><div class="ttdeci">SelfAdjointMatrix(M &amp;&amp;) -&gt; SelfAdjointMatrix&lt; std::conditional_t&lt; hermitian_adapter&lt; M &gt;, passable_t&lt; nested_object_of_t&lt; M &amp;&amp; &gt;&gt;, passable_t&lt; M &gt;&gt;, hermitian_adapter&lt; M &gt; ? hermitian_adapter_type_of_v&lt; M &gt; :HermitianAdapterType::lower &gt;</div><div class="ttdoc">Deduction guide for converting Eigen::SelfAdjointView to SelfAdjointMatrix.</div></div>
<div class="ttc" id="anamespaceOpenKalman_html_adf1fd82767ce2a6be113c3ed4d96350c"><div class="ttname"><a href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">OpenKalman::triangular_matrix</a></div><div class="ttdeci">concept triangular_matrix</div><div class="ttdoc">Specifies that a type is a triangular matrix (upper, lower, or diagonal).</div><div class="ttdef"><b>Definition:</b> <a href="triangular__matrix_8hpp_source.html#l00034">triangular_matrix.hpp:34</a></div></div>
</div><!-- fragment --><p>A <a class="el" href="namespaceOpenKalman.html#ae3191dafc41675832797c59b2a719eba">triangular_adapter</a>, where components above or below the diagonal (or both) are zero.</p>
<p>The matrix is guaranteed to be hermitian. Implicit conversions are available from any <a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a> of compatible size. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NestedMatrix</td><td>A nested <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a> expression, on which the self-adjoint matrix is based. </td></tr>
    <tr><td class="paramname">storage_triangle</td><td>The HermitianAdapterType (<a class="el" href="namespaceOpenKalman.html#aa8a9bbfcbe19f7fc489fd1405bfdce76a81e073b428b50247daba38531dcf412a">lower</a> or <a class="el" href="namespaceOpenKalman.html#aa8a9bbfcbe19f7fc489fd1405bfdce76a0122b4c2c01ee1c698ecc309d2b8eb5a">upper</a>) in which the data is stored. Matrix elements outside this triangle/diagonal are ignored. If the matrix is lower or upper triangular, elements are mapped (as complex conjugates) from this selected triangle to the elements in the other triangle to ensure that the matrix is hermitian. Also, any imaginary part of the diagonal elements is discarded. If storage_triangle is <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209baa0e17e2709a0404ae3d7de03b8ea9093" title="A diagonal matrix (both a lower-left and an upper-right triangular matrix).">TriangleType::diagonal</a>, 0 is automatically mapped to each matrix element outside the diagonal.</td></tr>
  </table>
  </dd>
</dl>
<p>The matrix may be a diagonal matrix if triangle_type is <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209baa0e17e2709a0404ae3d7de03b8ea9093" title="A diagonal matrix (both a lower-left and an upper-right triangular matrix).">TriangleType::diagonal</a>. Implicit conversions are available from any <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a> of compatible size. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NestedMatrix</td><td>A nested matrix on which the triangular matrix is based. Components above or below the diagonal (or both) are ignored and will read as zero. </td></tr>
    <tr><td class="paramname">triangle_type</td><td>The TriangleType (<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba81e073b428b50247daba38531dcf412a">lower</a>, <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">upper</a>, or <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209baa0e17e2709a0404ae3d7de03b8ea9093">diagonal</a>) in which the data is stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb0856fb135cd5d4752d11f89768c76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0856fb135cd5d4752d11f89768c76e">&#9670;&nbsp;</a></span>requires() <span class="overload">[17/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fixed_vector_space_descriptor FixedDescriptor, typed_matrix_nestable M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">index_dimension_of_v&lt; M, 0 &gt;                                                                   &#160;</td>
          <td class="paramname"> = <code>=&#160;<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt;<a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1FixedDescriptor.html">FixedDescriptor</a>&gt;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedDescriptor</td><td>The coefficient types corresponding to the rows. </td></tr>
    <tr><td class="paramname">M</td><td>a typed_matrix_nestable on which the new matrix is based. It will be converted to a self_contained type if it is not already self-contained. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="adapters_2Mean_8hpp_source.html#l00473">473</a> of file <a class="el" href="adapters_2Mean_8hpp_source.html">Mean.hpp</a>.</p>

</div>
</div>
<a id="adf85d6d9b731225e0dbfb59857fa967f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf85d6d9b731225e0dbfb59857fa967f">&#9670;&nbsp;</a></span>requires() <span class="overload">[18/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fixed_vector_space_descriptor Descriptor, typed_matrix_nestable MeanNestedMatrix, covariance_nestable CovarianceNestedMatrix, std::uniform_random_bit_generator random_number_engine = std::mt19937&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">index_dimension_of_v&lt; MeanNestedMatrix, 0 &gt;   &#160;</td>
          <td class="paramname"> = <code>=&#160;index_dimension_of_v&lt;CovarianceNestedMatrix,&#160;0&gt;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Descriptor</td><td>Coefficient types. </td></tr>
    <tr><td class="paramname">MeanNestedMatrix</td><td>The underlying native matrix for the Mean. </td></tr>
    <tr><td class="paramname">CovarianceNestedMatrix</td><td>The underlying native matrix (triangular or self-adjoint) for the Covariance. </td></tr>
    <tr><td class="paramname">random_number_engine</td><td>A random number engine compatible with the c++ standard library (e.g., std::mt19937). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49d55b0a864c70e600ef1985f436eaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d55b0a864c70e600ef1985f436eaf2">&#9670;&nbsp;</a></span>requires() <span class="overload">[19/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fixed_vector_space_descriptor InputCoefficients, fixed_vector_space_descriptor OutputCoefficients, typed_matrix_nestable TransformationMatrix, typed_matrix_nestable ... PerturbationTransformationMatrices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">index_dimension_of_v&lt; TransformationMatrix, 0 &gt; &#160;</td>
          <td class="paramname"> = <code>=&#160;<a class="el" href="namespaceOpenKalman.html#a592e04b6d486227e1e469eaceae0e17a">dimension_size_of_v</a>&lt;OutputCoefficients&gt;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputCoefficients</td><td>Coefficient types for the input. </td></tr>
    <tr><td class="paramname">OutputCoefficients</td><td>Coefficient types for the output. </td></tr>
    <tr><td class="paramname">TransformationMatrix</td><td><a class="el" href="structOpenKalman_1_1Transformation.html" title="A tests from one single-column vector to another.">Transformation</a> matrix. It is a native matrix type with rows corresponding to OutputCoefficients and columns corresponding to InputCoefficients. </td></tr>
    <tr><td class="paramname">PerturbationTransformationMatrices</td><td><a class="el" href="structOpenKalman_1_1Transformation.html" title="A tests from one single-column vector to another.">Transformation</a> matrices for each potential perturbation term. if the parameter is not given, the tests matrix is assumed to be identity (i.e., it is a translation). It is a native matrix type with both rows and columns corresponding to OutputCoefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1057a6c9a969b189dd249d34fa84a5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1057a6c9a969b189dd249d34fa84a5ad">&#9670;&nbsp;</a></span>requires() <span class="overload">[20/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible T, Layout layout = Layout::none, scalar_type Scalar = scalar_type_of_t&lt;T&gt;, vector_space_descriptor... D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">layout !&#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea47101375aa96fa02cfb1d55fd00af989">Layout::stride</a></code></td><td>)</td>
          <td> = typename detail::dense_writable_matrix_impl&lt;T, layout, std::decay_t&lt;S&gt;, D...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias for a dense, writable matrix, patterned on parameter T.</p>
<p>The result will be uninitialized. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A dummy matrix or array from the relevant library (size, shape, and layout are ignored) </td></tr>
    <tr><td class="paramname">layout</td><td>The <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121e">Layout</a> of the resulting object. If this is <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea334c4a4c42fdb79d7ebc3e73b517e6f8" title="No storage layout (e.g., if the elements are calculated rather than stored).">Layout::none</a>, it will be the default layout for the library of T. </td></tr>
    <tr><td class="paramname">Scalar</td><td>The scalar type of the resulting object (by default, it is the same scalar type as T). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>a tuple of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> describing dimensions of each index. Trailing 1D indices my be omitted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or array from the relevant matrix library. </td></tr>
    <tr><td class="paramname">S</td><td>A scalar type (may or may not be scalar_type_of_t&lt;T&gt;. </td></tr>
    <tr><td class="paramname">layout</td><td>The /ref Layout of the result. </td></tr>
    <tr><td class="paramname">D</td><td><a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> objects defining the dimensions of the new matrix. This will be derived from T if omitted. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="make__dense__object_8hpp_source.html#l00032">32</a> of file <a class="el" href="make__dense__object_8hpp_source.html">make_dense_object.hpp</a>.</p>

</div>
</div>
<a id="a76d1a2a695e2247ebce3e5ed48c4703b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d1a2a695e2247ebce3e5ed48c4703b">&#9670;&nbsp;</a></span>requires() <span class="overload">[21/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible T, Layout layout = Layout::none, scalar_type Scalar = scalar_type_of_t&lt;T&gt;, indexible Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">layout !       &#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea47101375aa96fa02cfb1d55fd00af989">Layout::stride</a></code></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A dummy matrix or array from the relevant library (size, shape, and layout are ignored) </td></tr>
    <tr><td class="paramname">layout</td><td>The <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121e">Layout</a> of the resulting object. If this is <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea334c4a4c42fdb79d7ebc3e73b517e6f8" title="No storage layout (e.g., if the elements are calculated rather than stored).">Layout::none</a>, the interface will decide the layout. </td></tr>
    <tr><td class="paramname">Scalar</td><td>The Scalar type of the new matrix, if different than that of Arg </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The object from which the new matrix is based </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="to__dense__object_8hpp_source.html#l00044">44</a> of file <a class="el" href="to__dense__object_8hpp_source.html">to_dense_object.hpp</a>.</p>

</div>
</div>
<a id="ae6c85109f94ecc1cdfee3cfa7fd7c271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c85109f94ecc1cdfee3cfa7fd7c271">&#9670;&nbsp;</a></span>requires() <span class="overload">[22/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Layout layout, scalar_type Scalar, indexible Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">layout !      &#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea47101375aa96fa02cfb1d55fd00af989">Layout::stride</a></code></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">layout</td><td>The <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121e">Layout</a> of the resulting object. If this is <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea334c4a4c42fdb79d7ebc3e73b517e6f8" title="No storage layout (e.g., if the elements are calculated rather than stored).">Layout::none</a>, the interface will decide the layout. </td></tr>
    <tr><td class="paramname">Scalar</td><td>The Scalar type of the new matrix, if different than that of Arg </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The object from which the new matrix is based </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="to__dense__object_8hpp_source.html#l00078">78</a> of file <a class="el" href="to__dense__object_8hpp_source.html">to_dense_object.hpp</a>.</p>

</div>
</div>
<a id="aca3cd9b9bd51d5576d1546a97e7279c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3cd9b9bd51d5576d1546a97e7279c6">&#9670;&nbsp;</a></span>requires() <span class="overload">[23/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Layout layout = Layout::none, indexible Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">layout !     &#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea47101375aa96fa02cfb1d55fd00af989">Layout::stride</a></code></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">layout</td><td>The <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121e">Layout</a> of the resulting object (optional). If this is omitted or <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea334c4a4c42fdb79d7ebc3e73b517e6f8" title="No storage layout (e.g., if the elements are calculated rather than stored).">Layout::none</a>, the interface will decide the layout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The object from which the new matrix is based </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="to__dense__object_8hpp_source.html#l00102">102</a> of file <a class="el" href="to__dense__object_8hpp_source.html">to_dense_object.hpp</a>.</p>

</div>
</div>
<a id="aeadc3b8d1b3899d9d9554ab5ab9bc8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeadc3b8d1b3899d9d9554ab5ab9bc8fd">&#9670;&nbsp;</a></span>requires() <span class="overload">[24/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Layout layout = Layout::right, indexible Arg, scalar_type ... S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">layout                                                 &#160;</td>
          <td class="paramname"> = <code>=&#160;<a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea7c4f29407893c334a6cb7a87bf045c0d">Layout::right</a>&#160;<a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a>&#160;layout&#160;==&#160;<a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea811882fecd5c7618d7099ebbd39ea254">Layout::left</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>The scalar components are listed in the specified layout order, as follows:</p><ul>
<li>Layout::left: column-major;</li>
<li>Layout::right: row-major (the default). <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">layout</td><td>The <a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121e">Layout</a> of Args and the resulting object (<a class="el" href="namespaceOpenKalman.html#a3899b43bdfa17fa31303340b2dd9121ea7c4f29407893c334a6cb7a87bf045c0d">Layout::right</a> if unspecified). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The object to be modified. </td></tr>
    <tr><td class="paramname">s</td><td>Scalar values to fill the new matrix. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="fill__components_8hpp_source.html#l00033">33</a> of file <a class="el" href="fill__components_8hpp_source.html">fill_components.hpp</a>.</p>

</div>
</div>
<a id="a166c8fd0ea3c99895cd0f03e5bd33e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166c8fd0ea3c99895cd0f03e5bd33e21">&#9670;&nbsp;</a></span>requires() <span class="overload">[25/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">max_tensor_order_v&lt; Arg &gt;&lt;=&#160;</td>
          <td class="paramname"><em>2</em></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the transpose of a matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="adjoint_8hpp_source.html#l00029">29</a> of file <a class="el" href="adjoint_8hpp_source.html">adjoint.hpp</a>.</p>

</div>
</div>
<a id="a817c87490aba57d1def8ff710575e905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817c87490aba57d1def8ff710575e905">&#9670;&nbsp;</a></span>requires() <span class="overload">[26/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;square_shaped&lt; Qualification::depends_on_dynamic_shape &gt; Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">max_tensor_order_v&lt; Arg &gt;&lt;=&#160;</td>
          <td class="paramname"><em>2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the trace of a matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A square matrix</td></tr>
  </table>
  </dd>
</dl>
<p>This is a generalized trace that applies to rectangular matrices. If the argument is rectangular, this function returns the trace of the square sub-matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The matrix </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="determinant_8hpp_source.html#l00038">38</a> of file <a class="el" href="determinant_8hpp_source.html">determinant.hpp</a>.</p>

</div>
</div>
<a id="a7ad3939ca2912e042aac6a4fc704e2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad3939ca2912e042aac6a4fc704e2f1">&#9670;&nbsp;</a></span>requires() <span class="overload">[27/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fixed_vector_space_descriptor C, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">N !                           &#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespaceOpenKalman.html#a0f663d3bacbc3dc52fb0eb3c0412b514">dynamic_size</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">C</td><td>A <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> object to be repeated. </td></tr>
    <tr><td class="paramname">N</td><td>The number of times to repeat coefficient C. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="replicate__fixed__vector__space__descriptor_8hpp_source.html#l00030">30</a> of file <a class="el" href="replicate__fixed__vector__space__descriptor_8hpp_source.html">replicate_fixed_vector_space_descriptor.hpp</a>.</p>

</div>
</div>
<a id="a86ddde5dc21c15f822135690e0ca248b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ddde5dc21c15f822135690e0ca248b">&#9670;&nbsp;</a></span>requires() <span class="overload">[28/60]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> Arg OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>&lt; Arg &gt;                                                                  &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FixedDescriptor</td><td>The coefficient types corresponding to the rows and columns. </td></tr>
    <tr><td class="paramname">TriangleType</td><td>The type of the nested triangular matrix (upper, lower). </td></tr>
    <tr><td class="paramname">Arg</td><td>A square, self-adjoint <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a> with size matching FixedDescriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d2b69064ea0d93b624e21c3ad978c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2b69064ea0d93b624e21c3ad978c1b">&#9670;&nbsp;</a></span>requires() <span class="overload">[29/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix_nestable M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>&lt; M &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> &amp;&amp; -&gt;  <a class="el" href="namespaceOpenKalman.html#a05cfddbbcf6833742c53fec3f3c007ec">Covariance</a>&lt; <a class="el" href="structOpenKalman_1_1vector__space__descriptors_1_1Dimensions.html">Dimensions</a>&lt; index_dimension_of_v&lt; M, 0 &gt;&gt;, typename MatrixTraits&lt; std::decay_t&lt; M &gt;&gt;::template SelfAdjointMatrixFrom&lt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deduce SquareRootCovariance type from a square <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>. </p>

</div>
</div>
<a id="a8bfe18f8569a2d34da92c5d348c5d6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfe18f8569a2d34da92c5d348c5d6bf">&#9670;&nbsp;</a></span>requires() <span class="overload">[30/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;hermitian_adapter Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>&lt; Arg &gt;        &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from a hermitian matrix, of the opposite storage type, that is not a wrapper.</p>
<p>Construct from a hermitian matrix of the same storage type and is not a wrapper. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2SelfAdjointMatrix_8hpp_source.html#l00115">115</a> of file <a class="el" href="adapters_2SelfAdjointMatrix_8hpp_source.html">SelfAdjointMatrix.hpp</a>.</p>

</div>
</div>
<a id="a438a0a35c1b418a083708dccf3d06255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438a0a35c1b418a083708dccf3d06255">&#9670;&nbsp;</a></span>requires() <span class="overload">[31/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t index, std::size_t... indices, internal::has_uniform_fixed_vector_space_descriptors&lt; index, indices... &gt; Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#a4d2ce6da5d4f3187281589b759364395">empty_object</a>&lt; Arg &gt;                 &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">index</td><td>an index to be reduced. For example, if the index is 0, the result will have only one row. If the index is 1, the result will have only one column. </td></tr>
    <tr><td class="paramname">indices</td><td>Other indices to be reduced. Because the binary function is associative, the order of the indices does not matter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector or tensor with reduced dimensions. </dd></dl>

<p class="definition">Definition at line <a class="el" href="average__reduce_8hpp_source.html#l00051">51</a> of file <a class="el" href="average__reduce_8hpp_source.html">average_reduce.hpp</a>.</p>

</div>
</div>
<a id="a53037a5c9000410a8fa8e43e05dd5cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53037a5c9000410a8fa8e43e05dd5cd0">&#9670;&nbsp;</a></span>requires() <span class="overload">[32/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#afde753e8fa98ead4323ad7f74c6e314f">euclidean_transformed</a>&lt; A &gt;                                              &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>The matrix to be decomposed satisfying <code><a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c" title="Specifies that a type is a triangular matrix (upper, lower, or diagonal).">triangular_matrix&lt;A, TriangleType::lower&gt;</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L as a lower <a class="el" href="namespaceOpenKalman.html#adf1fd82767ce2a6be113c3ed4d96350c">triangular_matrix</a> which is also <a class="el" href="namespaceOpenKalman.html#a9bcd379baf13eb66452873164e6354f8">square_shaped</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="LQ__decomposition_8hpp_source.html#l00027">27</a> of file <a class="el" href="LQ__decomposition_8hpp_source.html">LQ_decomposition.hpp</a>.</p>

</div>
</div>
<a id="a5219de18d1ade23e3ac70972d585cb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5219de18d1ade23e3ac70972d585cb3a">&#9670;&nbsp;</a></span>requires() <span class="overload">[33/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible Arg, vector_space_descriptor D0, vector_space_descriptor D1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; D0 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not <a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; D1 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman_1_1internal.html#a601527fae38b2760d48bb409307dcd88">internal::prefix_of</a>&lt; D0, D1 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman_1_1internal.html#a601527fae38b2760d48bb409307dcd88">internal::prefix_of</a>&lt; D1, D0 &gt;                                           &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A vector or higher-order tensor reflecting the diagonal(s). </td></tr>
    <tr><td class="paramname">D0</td><td>The <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> for the rows. </td></tr>
    <tr><td class="paramname">D1</td><td>The <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> for the columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbe0a0d1c311f0eb1361c678e6591dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe0a0d1c311f0eb1361c678e6591dc9">&#9670;&nbsp;</a></span>requires() <span class="overload">[34/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible T, scalar_type Scalar = scalar_type_of_t&lt;T&gt;, vector_space_descriptor D0, vector_space_descriptor D1, vector_space_descriptor... Ds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; D0 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not <a class="el" href="namespaceOpenKalman.html#a055e7b9e1a13db048847821c1d71dd5f">fixed_vector_space_descriptor</a>&lt; D1 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman_1_1internal.html#a601527fae38b2760d48bb409307dcd88">internal::prefix_of</a>&lt; D0, D1 &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman_1_1internal.html#a601527fae38b2760d48bb409307dcd88">internal::prefix_of</a>&lt; D1, D0 &gt;           &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Any matrix or tensor within the relevant library. </td></tr>
    <tr><td class="paramname">Scalar</td><td>An optional scalar type for the new zero matrix. By default, T's scalar type is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ds</td><td>A set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> items defining the dimensions of each index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89161eb6db1c601c18018dc3f87c3e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89161eb6db1c601c18018dc3f87c3e48">&#9670;&nbsp;</a></span>requires() <span class="overload">[35/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible NestedObject&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#a8790c861060ce4dfc9868d45a10d73c4">from_euclidean_expr</a>&lt; NestedObject &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the counterpart expression to <a class="el" href="structOpenKalman_1_1FromEuclideanExpr.html" title="An expression that transforms angular or other modular vector space descriptors back from Euclidean s...">FromEuclideanExpr</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NestedObject</td><td>The pre-transformed column vector, or set of column vectors in the form of a matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0cecabf2d6451987477317b5c7805a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0cecabf2d6451987477317b5c7805a4">&#9670;&nbsp;</a></span>requires() <span class="overload">[36/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;fixed_vector_space_descriptor... Ds, indexible Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#a2df14967a1282177068bd8aaff491e65">has_dynamic_dimensions</a>&lt; Arg &gt;                                          &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="make__vector__space__adapter_8hpp_source.html#l00050">50</a> of file <a class="el" href="make__vector__space__adapter_8hpp_source.html">make_vector_space_adapter.hpp</a>.</p>

</div>
</div>
<a id="a351595a30d9cc8f3f9623dcb7c74b26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351595a30d9cc8f3f9623dcb7c74b26a">&#9670;&nbsp;</a></span>requires() <span class="overload">[37/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix ReturnType, std::uniform_random_bit_generator random_number_engine = std::mt19937, typename... Dists&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#a2df14967a1282177068bd8aaff491e65">has_dynamic_dimensions</a>&lt; ReturnType &gt;                                                                                &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The distributions are allocated to each element of the matrix, according to one of the following options:</p>
<ul>
<li>One distribution for the entire matrix. The following example constructs a 2-by-2 matrix (m) in which each element is a random value selected based on a distribution with mean 1.0 and standard deviation 0.3: <div class="fragment"><div class="line"><span class="keyword">using</span> N = std::normal_distribution&lt;double&gt;;</div>
<div class="line"><span class="keyword">auto</span> m = randomize&lt;Matrix&lt;Dimensions&lt;2&gt;, Dimensions&lt;2&gt;, Eigen::Matrix&lt;double, 2, 2&gt;&gt;&gt;(N {1.0, 0.3}));</div>
</div><!-- fragment --></li>
<li>One distribution for each matrix element. The following code constructs a 2-by-2 matrix n containing random values around mean 1.0, 2.0, 3.0, and 4.0 (in row-major order), with standard deviations of 0.3, 0.3, 0.0 (by default, since no s.d. is specified as a parameter), and 0.3: <div class="fragment"><div class="line"><span class="keyword">auto</span> n = randomize&lt;Matrix&lt;Dimensions&lt;2&gt;, Dimensions&lt;2&gt;, Eigen::Matrix&lt;double, 2, 2&gt;&gt;&gt;(N {1.0, 0.3}, N {2.0, 0.3}, 3.0, N {4.0, 0.3})));</div>
</div><!-- fragment --></li>
<li>One distribution for each row. The following code constructs a 3-by-2 (o) or 2-by-2 (p) matrices in which elements in each row are selected according to the three (o) or two (p) listed distribution parameters: <div class="fragment"><div class="line"><span class="keyword">auto</span> o = randomize&lt;Matrix&lt;Dimensions&lt;3&gt;, FixedDescriptor&lt;angle::Radians, angle::Radians&gt;, Eigen::Matrix&lt;double, 3, 2&gt;&gt;&gt;(N {1.0, 0.3}, 2.0, N {3.0, 0.3})));</div>
<div class="line"><span class="keyword">auto</span> p = randomize&lt;Matrix&lt;Dimensions&lt;2&gt;, FixedDescriptor&lt;angle::Radians, angle::Radians&gt;, Eigen::Matrix&lt;double, 2, 2&gt;&gt;&gt;(N {1.0, 0.3}, N {2.0, 0.3})));</div>
</div><!-- fragment --> Note that in the case of p, there is an ambiguity as to whether the listed distributions correspond to rows or columns. In case of such an ambiguity, this function assumes that the parameters correspond to the rows.</li>
<li>One distribution for each column. The following code constructs 2-by-3 matrix m in which elements in each column are selected according to the three listed distribution parameters: <div class="fragment"><div class="line"><span class="keyword">auto</span> m = randomize&lt;Matrix&lt;FixedDescriptor&lt;angle::Radians, angle::Radians&gt;, Dimensions&lt;3&gt;, Eigen::Matrix&lt;double, 2, 3&gt;&gt;&gt;(N {1.0, 0.3}, 2.0, N {3.0, 0.3})));</div>
</div><!-- fragment --></li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ReturnType</td><td>The return type reflecting the size of the matrix to be filled. The actual result will be a fixed typed matrix. </td></tr>
    <tr><td class="paramname">random_number_engine</td><td>The random number engine. </td></tr>
    <tr><td class="paramname">Dists</td><td>A set of distributions (e.g., std::normal_distribution&lt;double&gt;) or, alternatively, means (a definite, non-stochastic value). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="typed-matrix-overloads_8hpp_source.html#l00801">801</a> of file <a class="el" href="typed-matrix-overloads_8hpp_source.html">typed-matrix-overloads.hpp</a>.</p>

</div>
</div>
<a id="abf91ff0c7bf6c4b4465a0522bda93604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf91ff0c7bf6c4b4465a0522bda93604">&#9670;&nbsp;</a></span>requires() <span class="overload">[38/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;diagonal_matrix Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not std::is_base_of_v&lt; <a class="el" href="namespaceOpenKalman.html#af0f4a7708985c78ea8155a7e2dc9905c">SelfAdjointMatrix</a>, std::decay_t&lt; Arg &gt;&gt;           &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign from another <a class="el" href="namespaceOpenKalman.html#afbbcbf9bf2f925d0dc32e7942a08507c">hermitian_matrix</a>.</p>
<p>Construct from a hermitian, non-diagonal wrapper of the same storage type. </p>

</div>
</div>
<a id="ab10efc09aa0d06509a1b86a8f0616886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10efc09aa0d06509a1b86a8f0616886">&#9670;&nbsp;</a></span>requires() <span class="overload">[39/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool must_be_unique = false, bool must_be_exact = false, typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">not <a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a>&lt; A &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not <a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a>&lt; B &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> not&#160;</td>
          <td class="paramname"><em>must_be_unique</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The interface to the relevant linear algebra library determines what happens if A is not invertible. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">must_be_unique</td><td>Determines whether the function throws an exception if the solution X is non-unique (e.g., if the equation is under-determined) </td></tr>
    <tr><td class="paramname">must_be_exact</td><td>Determines whether the function throws an exception if it cannot return an exact solution, such as if the equation is over-determined. If <code>false<code>, then the function will return an estimate instead of throwing an exception. </code></code></td></tr>
    <tr><td class="paramname">A</td><td><code><code>The matrix A in the equation AX = B </code></code></td></tr>
    <tr><td class="paramname">B</td><td><code><code>The matrix B in the equation AX = B </code></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><code> The unique solution X of the equation AX = B. If <code>must_be_unique</code>, then the function can return any valid solution for X. In particular, if <code>must_be_unique</code>, the function has the following behavior:<ul>
<li>If A is a <a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a>, then the result X will also be a <a class="el" href="namespaceOpenKalman.html#aa0674aa914eb3ec11e5bd68221094ef9">zero</a> </li>
</ul>
</code></code></dd></dl>

</div>
</div>
<a id="aed14ff54203adfde6276b06d6eceeb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed14ff54203adfde6276b06d6eceeb85">&#9670;&nbsp;</a></span>requires() <span class="overload">[40/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible Arg, scalar_constant S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">S&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide an object by a scalar value. </p>

<p class="definition">Definition at line <a class="el" href="scalar__product_8hpp_source.html#l00045">45</a> of file <a class="el" href="scalar__product_8hpp_source.html">scalar_product.hpp</a>.</p>

</div>
</div>
<a id="a3c50f80dd02e0cdef3b395406dc34c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c50f80dd02e0cdef3b395406dc34c50">&#9670;&nbsp;</a></span>requires() <span class="overload">[41/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;vector_space_descriptor... Ds, typename Operation , indexible... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...&#160;</td>
          <td class="paramname">Args, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">== <span class="keyword">sizeof</span>...(Args))</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> make_matrix(<span class="keyword">const</span> Args...args)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">using</span> Scalar = std::common_type_t&lt;Args...&gt;;</div>
<div class="line">    <span class="keyword">using</span> Mat = Eigen3::eigen_matrix_t&lt;Scalar, dimension_size_of_v&lt;RowCoefficients&gt;, dimension_size_of_v&lt;ColumnCoefficients&gt;&gt;;</div>
<div class="line">    <span class="keywordflow">return</span> Matrix&lt;RowCoefficients, ColumnCoefficients, Mat&gt;(make_dense_object_from&lt;Mat&gt;(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>Scalar<span class="keyword">&gt;</span>(args)...));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>&lt;<a class="code" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> ... Args&gt; requires (<span class="keyword">sizeof</span>...(Args) &gt; 0)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  auto make_matrix(const Args ... args)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> make_matrix&lt;Dimensions&lt;<span class="keyword">sizeof</span>...(Args)&gt;, <a class="code" href="namespaceOpenKalman_1_1vector__space__descriptors.html#ad493abd40cb8f785ad005b91f3b34058">Axis</a>&gt;(args...);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  </div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span>&lt;<a class="code" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> Scalar</div>
<div class="ttc" id="anamespaceOpenKalman_1_1vector__space__descriptors_html_ad493abd40cb8f785ad005b91f3b34058"><div class="ttname"><a href="namespaceOpenKalman_1_1vector__space__descriptors.html#ad493abd40cb8f785ad005b91f3b34058">OpenKalman::vector_space_descriptors::Axis</a></div><div class="ttdeci">Dimensions&lt; 1 &gt; Axis</div><div class="ttdoc">Alias for a 1D euclidean vector_space_descriptor object.</div><div class="ttdef"><b>Definition:</b> <a href="Dimensions_8hpp_source.html#l00174">Dimensions.hpp:174</a></div></div>
<div class="ttc" id="anamespaceOpenKalman_html_aae7f9880c66287c68d382f6a1352d069"><div class="ttname"><a href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">OpenKalman::scalar_type</a></div><div class="ttdeci">concept scalar_type</div><div class="ttdoc">T is a scalar type.</div><div class="ttdef"><b>Definition:</b> <a href="scalar__type_8hpp_source.html#l00030">scalar_type.hpp:30</a></div></div>
</div><!-- fragment --><p>This overload is for unary, binary, and higher n-ary operations. Examples:</p><ul>
<li>Unary operation, no broadcasting: <div class="fragment"><div class="line"><span class="keyword">auto</span> ds32 = std::tuple {Dimensions&lt;3&gt;{}, Dimensions&lt;2&gt;{}};</div>
<div class="line"><span class="keyword">auto</span> op1 = [](<span class="keyword">auto</span> arg){<span class="keywordflow">return</span> 3 * arg;};</div>
<div class="line"><span class="keyword">auto</span> M = Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt;</div>
<div class="line"><span class="keyword">auto</span> m32 = make_dense_object_from&lt;M&gt;(ds32, 1, 2, 3, 4, 5, 6);</div>
<div class="line">std::cout &lt;&lt; n_ary_operation(ds32, op1, m32) &lt;&lt; std::endl;</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">3, 6,</div>
<div class="line">9, 12,</div>
<div class="line">15, 18</div>
</div><!-- fragment --></li>
<li>Unary operation, broadcasting: <div class="fragment"><div class="line"><span class="keyword">auto</span> ds31 = std::tuple {Dimensions&lt;3&gt;{}, Dimensions&lt;1&gt;{}};</div>
<div class="line"><span class="keyword">auto</span> m31 = make_dense_object_from&lt;M&gt;(ds31, 1, 2, 3);</div>
<div class="line">std::cout &lt;&lt; n_ary_operation(ds32, op1, m31) &lt;&lt; std::endl;</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">3, 3,</div>
<div class="line">6, 6,</div>
<div class="line">9, 9</div>
</div><!-- fragment --></li>
<li>Binary operation, no broadcasting: <div class="fragment"><div class="line"><span class="keyword">auto</span> op2 = [](<span class="keyword">auto</span> arg1, <span class="keyword">auto</span> arg2){<span class="keywordflow">return</span> 3 * arg1 + arg2;};</div>
<div class="line">std::cout &lt;&lt; n_ary_operation(ds32, op2, m32, 2 * m32) &lt;&lt; std::endl;</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">5, 10,</div>
<div class="line">15, 20,</div>
<div class="line">25, 30</div>
</div><!-- fragment --></li>
<li>Binary operation, broadcasting: <div class="fragment"><div class="line">std::cout &lt;&lt; n_ary_operation(ds32, op2, m31, 2 * m32) &lt;&lt; std::endl;</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">5, 7,</div>
<div class="line">12, 14,</div>
<div class="line">19, 21</div>
</div><!-- fragment --></li>
<li>Binary operation, broadcasting, with indices: <div class="fragment"><div class="line"><span class="keyword">auto</span> op2b = [](<span class="keyword">auto</span> arg1, <span class="keyword">auto</span> arg2, std::size_t row, std::size_t col){<span class="keywordflow">return</span> 3 * arg1 + arg2 + row + col;};</div>
<div class="line">std::cout &lt;&lt; n_ary_operation(ds32, op2b, m31, 2 * m32) &lt;&lt; std::endl;</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">5, 8,</div>
<div class="line">13, 16,</div>
<div class="line">21, 24</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ds</td><td><a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> objects defining the size of the result. </td></tr>
    <tr><td class="paramname">Operation</td><td>The n-ary operation taking n arguments and, optionally, a set of indices indicating the location within the result. The operation must return a scalar value. </td></tr>
    <tr><td class="paramname">Args</td><td>The arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix or array in which each component is the result of calling Operation on corresponding components from each of the arguments, in the order specified. </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="n__ary__operation_8hpp_source.html#l00310">310</a> of file <a class="el" href="n__ary__operation_8hpp_source.html">n_ary_operation.hpp</a>.</p>

</div>
</div>
<a id="a069d6e208bb47413b71e0a4e11192b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069d6e208bb47413b71e0a4e11192b68">&#9670;&nbsp;</a></span>requires() <span class="overload">[42/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Operation , indexible... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...&#160;</td>
          <td class="paramname">Args, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>Each of the arguments may be expanded by broadcasting. The result will derive each dimension from the largest corresponding dimension among the arguments. Examples:</p><ul>
<li>Binary operation, broadcasting: <div class="fragment"><div class="line"><span class="keyword">auto</span> M = Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt;</div>
<div class="line"><span class="keyword">auto</span> op2a = [](<span class="keyword">auto</span> arg1, <span class="keyword">auto</span> arg2){<span class="keywordflow">return</span> 3 * arg1 + arg2;};</div>
<div class="line"><span class="keyword">auto</span> m31 = make_dense_object_from&lt;M&gt;(ds31, 1, 2, 3);</div>
<div class="line"><span class="keyword">auto</span> m32 = make_dense_object_from&lt;M&gt;(ds32, 1, 2, 3, 4, 5, 6);</div>
<div class="line">std::cout &lt;&lt; n_ary_operation(op2a, m31, 2 * m32) &lt;&lt; std::endl;</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">5, 7,</div>
<div class="line">12, 14,</div>
<div class="line">19, 21</div>
</div><!-- fragment --></li>
<li>Binary operation, broadcasting, with indices: <div class="fragment"><div class="line"><span class="keyword">auto</span> op2b = [](<span class="keyword">auto</span> arg1, <span class="keyword">auto</span> arg2, std::size_t row, std::size_t col){<span class="keywordflow">return</span> 3 * arg1 + arg2 + row + col;};</div>
<div class="line">std::cout &lt;&lt; n_ary_operation(op2b, m31, 2 * m32) &lt;&lt; std::endl;</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">5, 8,</div>
<div class="line">13, 16,</div>
<div class="line">21, 24</div>
</div><!-- fragment --></li>
<li>Unary operation, with indices: <div class="fragment"><div class="line"><span class="keyword">auto</span> op1a = [](<span class="keyword">auto</span>&amp; arg, std::size_t row, std::size_t col){<span class="keywordflow">return</span> arg + row + col;};</div>
<div class="line">std::cout &lt;&lt; n_ary_operation(op1a, m32) &lt;&lt; std::endl;</div>
</div><!-- fragment --> Output: <div class="fragment"><div class="line">1, 3,</div>
<div class="line">4, 6,</div>
<div class="line">7, 9</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Operation</td><td>The n-ary operation taking n arguments and, optionally, a set of indices. The operation must return a scalar value. </td></tr>
    <tr><td class="paramname">Args</td><td>The arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix or array in which each component is the result of calling Operation on corresponding components from each of the arguments, in the order specified. </dd></dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="n__ary__operation_8hpp_source.html#l00478">478</a> of file <a class="el" href="n__ary__operation_8hpp_source.html">n_ary_operation.hpp</a>.</p>

</div>
</div>
<a id="a82d5a4bfb7b801f7f11517471a8b97ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d5a4bfb7b801f7f11517471a8b97ee">&#9670;&nbsp;</a></span>requires() <span class="overload">[43/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::convertible_to&lt; const Scalar &gt; ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...&#160;</td>
          <td class="paramname">Args, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This assumes, without checking, that the coefficients represent a self-adjoint matrix. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>List of scalar values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="adapters_2SelfAdjointMatrix_8hpp_source.html#l00194">194</a> of file <a class="el" href="adapters_2SelfAdjointMatrix_8hpp_source.html">SelfAdjointMatrix.hpp</a>.</p>

</div>
</div>
<a id="a8aa5429eae98e1949363eb143a48ba8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa5429eae98e1949363eb143a48ba8b">&#9670;&nbsp;</a></span>requires() <span class="overload">[44/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... indices, typename Operation , indexible... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...&#160;</td>
          <td class="paramname">Args, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an indexible object of order <em>k</em>, a "chip" is a subset of that object, having order in the range (0, <em>k</em>]. This function takes same-size chips from each of the arguments and performs an operation returning a chip (of the same size), for every possible chip within the result. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">indices</td><td>The one-dimensional indices of the chip (optionally excluding any trailing 1D indices). If omitted, the order of the chip is the same as that of the highest-order indexible argument. Note: the list of indices must be non-repeating, or a compile-time assertion will fail. </td></tr>
    <tr><td class="paramname">Operation</td><td>An n-ary operation (unary, binary, etc.) on n chips of the same size. In addition to taking one or more chips as arguments, the operation may optionally take <code>sizeof...(indices)</code> indices (in the same order as <code>indices</code>). </td></tr>
    <tr><td class="paramname">Args</td><td>The arguments, which must be the same size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object of the same size as the highest-order argument. For example, a chipwise operation between a 3&times;4 matrix and either a 3&times;1 row or 1&times;4 column vector is a 3&times;4 matrix. (The vector is replicated vertically or horizontally, respectively, to fill the size of the matrix.) </dd></dl>

</div>
</div>
<a id="a1475f0750497f10e6dfd9af0084ce5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1475f0750497f10e6dfd9af0084ce5de">&#9670;&nbsp;</a></span>requires() <span class="overload">[45/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;writable Arg, indexible Block, index_value... Begin&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...(Begin) &gt;=index_count_v&lt; Arg &gt;        &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The <a class="el" href="namespaceOpenKalman.html#abd7388b89ddb8b8aa2c0e1be66900dee">writable</a> object in which the slice is to be assigned. </td></tr>
    <tr><td class="paramname">block</td><td>The block to be set. </td></tr>
    <tr><td class="paramname">begin</td><td>A tuple specifying, for each index of Arg in order, the beginning <a class="el" href="namespaceOpenKalman.html#a8b8a5ca9cb2a660eb584981e1339b87a">index_value</a>. </td></tr>
    <tr><td class="paramname">size</td><td>A tuple specifying, for each index of Arg in order, the dimensions of the extracted block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to arg as modified. </dd></dl>

</div>
</div>
<a id="a3c5df307d607f8e4623e586dda547901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5df307d607f8e4623e586dda547901">&#9670;&nbsp;</a></span>requires() <span class="overload">[46/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... indices, indexible Arg, index_value... Begin, index_value... Size&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...                                                &#160;</td>
          <td class="paramname">Begin = <code>=&#160;sizeof...(Size)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>If indices are specified, only those indices will be subsetted. Otherwise, the Begin and Size parameters are taken in index order. Any omitting trailing indices (for which there are no Begin or Size parameters) are included whole. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">indices</td><td>The index or indices of the particular dimensions to be specified, in any order (optional). If this is omitted, the Begin and Size parameters proceed in index order. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The indexible object from which a slice is to be taken. </td></tr>
    <tr><td class="paramname">begin</td><td>A tuple corresponding to each of indices, each element specifying the beginning <a class="el" href="namespaceOpenKalman.html#a8b8a5ca9cb2a660eb584981e1339b87a">index_value</a>. If indices are not specified, the tuple proceeds in normal index order. </td></tr>
    <tr><td class="paramname">size</td><td>A tuple corresponding to each of indices, each element specifying the dimensions of the extracted block. If indices are not specified, the tuple proceeds in normal index order. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="get__slice_8hpp_source.html#l00107">107</a> of file <a class="el" href="get__slice_8hpp_source.html">get_slice.hpp</a>.</p>

</div>
</div>
<a id="a36f0f93bfee9b8ff1801c7b75066a841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f0f93bfee9b8ff1801c7b75066a841">&#9670;&nbsp;</a></span>requires() <span class="overload">[47/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible PatternMatrix, scalar_constant Scalar, auto... constant&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...      &#160;</td>
          <td class="paramname">constant = <code>=0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The constant value can be <a class="el" href="namespaceOpenKalman.html#aa745cbaa0edbfed7d1da05691e07d47baa90e37207f27e1996845a3c7d594fd0a">static</a> (known at compile time), or <a class="el" href="namespaceOpenKalman.html#aa745cbaa0edbfed7d1da05691e07d47ba32c2b7f95065494184e8b5799d3618e7">dynamic</a> (known only at runtime). Examples: </p><div class="fragment"><div class="line"><span class="keyword">using</span> T = Eigen::Matrix&lt;double, 3, 2&gt;; <span class="comment">// A 3-by-2 matrix of scalar-type double.</span></div>
<div class="line">ConstantAdapter&lt;T&gt; c1 {3.0}; <span class="comment">// Construct a 3-by-2 double constant of shape T with value 3.0 (known at runtime).</span></div>
<div class="line">ConstantAdapter&lt;T, int&gt; c2 {3}; <span class="comment">// Construct a 3-by-2 int constant of shape T with value 3 (known at runtime).</span></div>
<div class="line">ConstantAdapter&lt;T, int, 1&gt; c3; <span class="comment">// Construct a 3-by-2 int constant of shape T with value 1 (known at compile time).</span></div>
<div class="line">ConstantAdapter&lt;T, double, 1&gt; c4; <span class="comment">// Construct a 3-by-2 double constant of shape T with value 1.0 (known at compile time).</span></div>
<div class="line">ConstantAdapter&lt;T, std::integral_constant&lt;int, 1&gt;&gt; c5; <span class="comment">// Construct a 3-by-2 int constant of shape T with value 1 (known at compile time).</span></div>
<div class="line">ConstantAdapter&lt;T, std::complex&lt;double&gt;&gt; c6 {std::complex&lt;double&gt;{4, 5}}; <span class="comment">// Construct a 3-by-2 complex constant of shape T and value 4.0 + 5.0i (known at runtime).</span></div>
<div class="line">ConstantAdapter&lt;T, std::complex&lt;double&gt;, 4, 5&gt; c7; <span class="comment">// Construct a 3-by-2 A complex constant of shape T and value 4.0 + 5.0i (known at compile time).</span></div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PatternMatrix</td><td>An <a class="el" href="namespaceOpenKalman.html#a357b81b7e7664f628fc14bcd5bb3bdc0">indexible</a> object reflecting the size and shape of the constant object </td></tr>
    <tr><td class="paramname">Scalar</td><td>A <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> reflecting the type of the constant </td></tr>
    <tr><td class="paramname">constant</td><td>Optional parameters for constructing Scalar at compile time. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="adapters_2ConstantAdapter_8hpp_source.html#l00030">30</a> of file <a class="el" href="adapters_2ConstantAdapter_8hpp_source.html">ConstantAdapter.hpp</a>.</p>

</div>
</div>
<a id="aa30135b36d5d792be0f05ccc85ff286c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30135b36d5d792be0f05ccc85ff286c">&#9670;&nbsp;</a></span>requires() <span class="overload">[48/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible T, scalar_constant C, vector_space_descriptor... Ds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...(Ds) !            &#160;</td>
          <td class="paramname"> = <code>0</code></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constant object is a matrix or tensor in which every component is the same scalar value. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An \indexible object (matrix or tensor) from a particular library. </td></tr>
    <tr><td class="paramname">C</td><td>A <a class="el" href="namespaceOpenKalman.html#a72829d83ccbc836bfb60d395cd4d5331">scalar_constant</a> </td></tr>
    <tr><td class="paramname">Ds</td><td>A set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> defining the dimensions of each index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0ea18e74abb7e98eca12b32cfcdcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0ea18e74abb7e98eca12b32cfcdcd5">&#9670;&nbsp;</a></span>requires() <span class="overload">[49/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;vector_space_descriptor... Ds, indexible Block, indexible... Blocks&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...                                      &#160;</td>
          <td class="paramname">Ds) &gt;=std::max({index_count_v&lt; Block &gt;, index_count_v&lt; Blocks &gt;...}</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ds</td><td>A set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> for the resulting matrix or tensor. </td></tr>
    <tr><td class="paramname">Block</td><td>The first block </td></tr>
    <tr><td class="paramname">Blocks</td><td>Subsequent blocks </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tile_8hpp_source.html#l00105">105</a> of file <a class="el" href="tile_8hpp_source.html">tile.hpp</a>.</p>

</div>
</div>
<a id="a3f739bf230b05b500ec8971ec94a4d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f739bf230b05b500ec8971ec94a4d61">&#9670;&nbsp;</a></span>requires() <span class="overload">[50/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible T, scalar_type Scalar = scalar_type_of_t&lt;T&gt;, vector_space_descriptor... Ds&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...                                         &#160;</td>
          <td class="paramname">Ds = <code>=&#160;index_count_v&lt;T&gt;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or other tensor within a particular library. Its details are not important. </td></tr>
    <tr><td class="paramname">Scalar</td><td>An optional scalar type for the new zero matrix. By default, T's scalar type is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ds</td><td>A set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> defining the dimensions of each index. If none are provided and T has no dynamic dimensions, the function takes <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> from T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b403d6ff4f5ead605b12940841659f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b403d6ff4f5ead605b12940841659f6">&#9670;&nbsp;</a></span>requires() <span class="overload">[51/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... indices, indexible Arg, detail::concatenate_dimensions_match&lt; Arg &gt;... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...&#160;</td>
          <td class="paramname">indices, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a matrix or tensor into sub-parts, where the split is the same for every index.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">indices</td><td>The indices along which the concatenation occurs. For example,<ul>
<li>if indices is {0}, concatenation is along row index 0, and is a vertical concatenation;</li>
<li>if indices is {1}, concatenation is along column index 1, and is a horizontal concatenation; and</li>
<li>if indices is {0, 1} or {1, 0}, concatenation is diagonal along both row and column directions. </li>
</ul>
</td></tr>
    <tr><td class="paramname">Arg</td><td>First object to be concatenated </td></tr>
    <tr><td class="paramname">Args</td><td>Other objects to be concatenated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The concatenated object </dd></dl>
<p>This is an inverse of the <a class="el" href="namespaceOpenKalman.html#a5eea165f22b79ddfa5081d4019853b47">concatenate</a> operation. In other words, for all <code>std::size_t i..., j...</code> and <code>indexible a...</code>, and given the function <code>template&lt;std::size_t...i&gt; auto f(auto a) { return get_vector_space_descriptor&lt;i&gt;(a)...}; }</code> <code>((split&lt;i...&gt;(concatenate&lt;i...&gt;(a...), get_vector_space_descriptor&lt;j&gt;(a)...) == std::tuple{a...}) and ...)</code>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">indices</td><td>The indices along which to make the split. E.g., 0 means to split along rows, 1 means to split along columns, {0, 1} means to split diagonally. </td></tr>
    <tr><td class="paramname">Arg</td><td>The matrix or tensor to be split. </td></tr>
    <tr><td class="paramname">Ds</td><td>A set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> (the same for for each of indices) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f654f5665cd41eb79ed2e08e8c1f6d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f654f5665cd41eb79ed2e08e8c1f6d2">&#9670;&nbsp;</a></span>requires() <span class="overload">[52/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... indices, writable Arg, indexible Chip, index_value... Ixs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...         &#160;</td>
          <td class="paramname">indices = <code>=&#160;sizeof...(Ixs)</code></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A chip is a special type of "thin" slice of width 1 in one or more dimensions, and otherwise no reduction in extents. For example, the result could be a row vector, a column vector, a matrix (e.g., if the input object is a rank-3 or higher tensor), etc. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">indices</td><td>The index or indices of the dimension(s) that have been collapsed to a single dimension. For example, if the input object is a matrix, a value of {0} will result in a row vector and a value of {1} will result in a column vector. If the input object is a rank-3 tensor, a value of {0, 1} will result in a matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The indexible object in which the chip is to be set. </td></tr>
    <tr><td class="paramname">chip</td><td>The chip to be set. It must be a chip, meaning that the dimension is 1 for each of <code>indices</code>. </td></tr>
    <tr><td class="paramname">is</td><td>The index value(s) corresponding to <code>indices</code>, in the same order. The values may be positive std::integral types or a positive std::integral_constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arg as modified </dd></dl>

</div>
</div>
<a id="a78802460b0a8da10df93ac7617b10e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78802460b0a8da10df93ac7617b10e5d">&#9670;&nbsp;</a></span>requires() <span class="overload">[53/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... indices, indexible Arg, index_value... Ixs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...               &#160;</td>
          <td class="paramname">indices = <code>=&#160;sizeof...(Ixs)</code></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A chip is a special type of "thin" slice of width 1 in one or more dimensions, and otherwise no reduction in extents. For example, the result could be a row vector, a column vector, a matrix (e.g., if the input object is a rank-3 or higher tensor), etc. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">indices</td><td>The index or indices of the dimension(s) to be collapsed to a single dimension. For example, if the input object is a matrix, a value of {0} will result in a row vector, a value of {1} will result in a column vector, and a value of {0, 1} will result in a one-dimensional vector. If the input object is a rank-3 tensor, a value of {1, 2} will result in a row vector. If no indices are listed, the argument will be returned unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ixs</td><td>The index value corresponding to each of the <code>indices</code>, in the same order. The values may be positive std::integral types or a positive std::integral_constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A sub-array of the argument </dd></dl>

</div>
</div>
<a id="ae79f99eb35747cf1389a13ca1626459e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae79f99eb35747cf1389a13ca1626459e">&#9670;&nbsp;</a></span>requires() <span class="overload">[54/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typed_matrix V, typed_matrix ... Vs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof...              &#160;</td>
          <td class="paramname">Vs = <code>=&#160;0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate one or more matrix objects vertically. </p>

</div>
</div>
<a id="a2d1c07f9e38b6f117bc553d02fa52f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d1c07f9e38b6f117bc553d02fa52f85">&#9670;&nbsp;</a></span>requires() <span class="overload">[55/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="get__index__dimension__of_8hpp_source.html#l00044">44</a> of file <a class="el" href="get__index__dimension__of_8hpp_source.html">get_index_dimension_of.hpp</a>.</p>

</div>
</div>
<a id="ab34b2cc15f9dbea2b3972dfeed9d0e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34b2cc15f9dbea2b3972dfeed9d0e91">&#9670;&nbsp;</a></span>requires() <span class="overload">[56/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="index__count_8hpp_source.html#l00053">53</a> of file <a class="el" href="index__count_8hpp_source.html">index_count.hpp</a>.</p>

</div>
</div>
<a id="ac3fef8225fd0142e06907ef6cbb96290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fef8225fd0142e06907ef6cbb96290">&#9670;&nbsp;</a></span>requires() <span class="overload">[57/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TriangleType t = TriangleType::lower, indexible Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">t          &#160;</td>
          <td class="paramname"> = <code>=&#160;<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba81e073b428b50247daba38531dcf412a">TriangleType::lower</a>&#160;<a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a>&#160;t&#160;==&#160;<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">TriangleType::upper</a>&#160;<a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a>&#160;t&#160;==&#160;<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209baa0e17e2709a0404ae3d7de03b8ea9093">TriangleType::diagonal</a></code></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">t</td><td>The intended <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209b">TriangleType</a> of the result. </td></tr>
    <tr><td class="paramname">Arg</td><td>A general matrix to be made triangular. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="make__triangular__matrix_8hpp_source.html#l00027">27</a> of file <a class="el" href="make__triangular__matrix_8hpp_source.html">make_triangular_matrix.hpp</a>.</p>

</div>
</div>
<a id="a417b4ea4656920e8251eb4783cd5977a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417b4ea4656920e8251eb4783cd5977a">&#9670;&nbsp;</a></span>requires() <span class="overload">[58/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TriangleType triangle_type, hermitian_matrix&lt; Qualification::depends_on_dynamic_shape &gt; A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">triangle_type !                 &#160;</td>
          <td class="paramname"> = <code><a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209baa0e17e2709a0404ae3d7de03b8ea9093">TriangleType::diagonal</a>&#160;<a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a>&#160;<a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>&lt;A&gt;</code></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A</td><td>A hermitian matrix. </td></tr>
    <tr><td class="paramname">triangle_type</td><td>Either <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a" title="An upper-right triangular matrix.">TriangleType::upper</a>, <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba81e073b428b50247daba38531dcf412a" title="A lower-left triangular matrix.">TriangleType::lower</a>, or <a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209baa0e17e2709a0404ae3d7de03b8ea9093" title="A diagonal matrix (both a lower-left and an upper-right triangular matrix).">TriangleType::diagonal</a> (only if A is a <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T, where the argument is in the form A = TT<sup>T</sup>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="cholesky__factor_8hpp_source.html#l00030">30</a> of file <a class="el" href="cholesky__factor_8hpp_source.html">cholesky_factor.hpp</a>.</p>

</div>
</div>
<a id="a434176cb05fac21968ffd2d6d16813c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434176cb05fac21968ffd2d6d16813c8">&#9670;&nbsp;</a></span>requires() <span class="overload">[59/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TriangleType triangle_type, typed_matrix Arg&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype">triangle_type      &#160;</td>
          <td class="paramname"> = <code>=&#160;<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba81e073b428b50247daba38531dcf412a">TriangleType::lower</a>&#160;<a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a>&#160;triangle_type&#160;==&#160;<a class="el" href="namespaceOpenKalman.html#a04d7114313206e555dfb932ccc82209ba0122b4c2c01ee1c698ecc309d2b8eb5a">TriangleType::upper</a></code></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a SquareRootCovariance from a <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="adapters_2Covariance_8hpp_source.html#l01017">1017</a> of file <a class="el" href="adapters_2Covariance_8hpp_source.html">Covariance.hpp</a>.</p>

</div>
</div>
<a id="abecad8b8032d1d3565c353c5f839a9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecad8b8032d1d3565c353c5f839a9de">&#9670;&nbsp;</a></span>requires() <span class="overload">[60/60]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;vector M, typename Cov , std::uniform_random_bit_generator re = std::mt19937&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenKalman::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a>&lt; M &gt; <a class="el" href="namespaceOpenKalman.html#a689b926c307aee8a9b8c177b1c7a389f">or</a> <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>&lt; M &gt;                         &#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>A <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a> or <a class="el" href="namespaceOpenKalman.html#a3d5132d834a8b3d816e1ab09a2912737">typed_matrix_nestable</a>. </td></tr>
    <tr><td class="paramname">Cov</td><td>A <a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a> or <a class="el" href="namespaceOpenKalman.html#addb015187a4dc31623f1917928e0ce69">covariance_nestable</a>. </td></tr>
    <tr><td class="paramname">re</td><td>A random number engine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="namespaceOpenKalman.html#a2e676386d6ed5b7749578d8a4e966d96">gaussian_distribution</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload excludes the case in which M is <a class="el" href="namespaceOpenKalman.html#aa47b21e50b1569c5b7cf3824fdd2be87">typed_matrix</a> <em>and</em> Cov is <a class="el" href="namespaceOpenKalman.html#a7f321ae7c589c6f337efe84ccd948586">covariance</a>. </dd></dl>

</div>
</div>
<a id="a4d81b2f9af6a61cf3f9727ef17a5650b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d81b2f9af6a61cf3f9727ef17a5650b">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;covariance M, std::convertible_to&lt; scalar_type_of_t&lt; M &gt;&gt; S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto OpenKalman::scale </td>
          <td>(</td>
          <td class="paramtype">M &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale a covariance by a factor. Equivalent to multiplication by the square of a scalar. For a square root covariance, this is equivalent to multiplication by the scalar. </p>

<p class="definition">Definition at line <a class="el" href="covariance-arithmetic_8hpp_source.html#l00519">519</a> of file <a class="el" href="covariance-arithmetic_8hpp_source.html">covariance-arithmetic.hpp</a>.</p>

</div>
</div>
<a id="af856ae93af81c5aa773607a257889e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af856ae93af81c5aa773607a257889e02">&#9670;&nbsp;</a></span>set_component() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Indices , std::enable_if_t&lt; writable_by_component&lt; Arg, Indices &gt; and index_value&lt;  decltype, int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Arg&amp;&amp; OpenKalman::set_component </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Indices &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>The object to be accessed. </td></tr>
    <tr><td class="paramname">Indices</td><td>An input range object containing the indices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The modified Arg </dd></dl>

<p class="definition">Definition at line <a class="el" href="set__component_8hpp_source.html#l00060">60</a> of file <a class="el" href="set__component_8hpp_source.html">set_component.hpp</a>.</p>

</div>
</div>
<a id="ab1a0ba0d290788c643191cc5abca9f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a0ba0d290788c643191cc5abca9f87">&#9670;&nbsp;</a></span>set_component() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename Indices , std::enable_if_t&lt; index_value&lt; Indices &gt; and writable_by_component&lt; Arg, std::initializer_list&lt; Indices &gt;&gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Arg&amp;&amp; OpenKalman::set_component </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::initializer_list&lt; Indices &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="definition">Definition at line <a class="el" href="set__component_8hpp_source.html#l00077">77</a> of file <a class="el" href="set__component_8hpp_source.html">set_component.hpp</a>.</p>

</div>
</div>
<a id="ab182263021d646820f1a316607fdd6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab182263021d646820f1a316607fdd6c3">&#9670;&nbsp;</a></span>set_component() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename... I, std::enable_if_t&lt;(index_value&lt; I &gt; and ...) and writable_by_component&lt; Arg, std::array&lt; std::size_t, sizeof...(I)&gt;&gt; and(index_count&lt; Arg &gt;::value==dynamic_size or sizeof...(I) &gt;=index_count&lt; Arg &gt;::value) and internal::static_indices_within_bounds&lt; Arg, I... &gt;::value, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Arg&amp;&amp; OpenKalman::set_component </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceOpenKalman.html#abecbd87443fa0938b5d8f10271761dce">scalar_type_of_t</a>&lt; Arg &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<p>The number of indices must be at least <code>index_count_v&lt;Arg&gt;</code>. If the indices are integral constants, the function performs compile-time bounds checking to the extent possible. </p>

<p class="definition">Definition at line <a class="el" href="set__component_8hpp_source.html#l00100">100</a> of file <a class="el" href="set__component_8hpp_source.html">set_component.hpp</a>.</p>

</div>
</div>
<a id="a0b8e4069b6e4e19b55f854c27c67cd5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8e4069b6e4e19b55f854c27c67cd5b">&#9670;&nbsp;</a></span>set_wrapped_component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void OpenKalman::set_wrapped_component </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::decay_t&lt; std::invoke_result_t&lt; decltype(g), std::size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>local_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The operation is equivalent to setting the angle and then mapping to, and then back from, Euclidean space. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>An element setter that sets an element at the location of index i (e.g., <code>std::function&lt;void(std::size_t, double)</code>) </td></tr>
    <tr><td class="paramname">g</td><td>An element getter mapping an index i of type std::size_t to an element of <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> (e.g., <code>std::function&lt;double(std::size_t)</code>) </td></tr>
    <tr><td class="paramname">x</td><td>The new value to be set. </td></tr>
    <tr><td class="paramname">local_index</td><td>A local index accessing the element. </td></tr>
    <tr><td class="paramname">start</td><td>The starting location of the element within any larger set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="set__wrapped__component_8hpp_source.html#l00035">35</a> of file <a class="el" href="set__wrapped__component_8hpp_source.html">set_wrapped_component.hpp</a>.</p>

</div>
</div>
<a id="a6f5996abd144318dab61496c54bd6ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5996abd144318dab61496c54bd6ecd">&#9670;&nbsp;</a></span>tensor_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;interface::count_indices_defined_for T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">requires constexpr interface::get_vector_space_descriptor_defined_for&lt;T&gt; <a class="el" href="namespaceOpenKalman.html#a8b8a5ca9cb2a660eb584981e1339b87a">index_value</a> auto OpenKalman::tensor_order </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If T has any zero-dimensional indices, the tensor order is considered to be 0, based on the theory that a zero-dimensional vector space has 0 as its only element, and 0 is a scalar value. This may be subject to change. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>A matrix or array </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor__order_8hpp_source.html#l00074">74</a> of file <a class="el" href="tensor__order_8hpp_source.html">tensor_order.hpp</a>.</p>

</div>
</div>
<a id="acfeedf8c4ba9661b52baf52ea75a7037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfeedf8c4ba9661b52baf52ea75a7037">&#9670;&nbsp;</a></span>to_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;vector&lt; 0, Qualification::depends_on_dynamic_shape &gt; Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) <a class="el" href="namespaceOpenKalman.html#aabd606b45e391ddbb67fa785798b1a89">diagonal_matrix</a> OpenKalman::to_diagonal </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A column vector matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A diagonal matrix </dd></dl>

<p class="definition">Definition at line <a class="el" href="to__diagonal_8hpp_source.html#l00033">33</a> of file <a class="el" href="to__diagonal_8hpp_source.html">to_diagonal.hpp</a>.</p>

</div>
</div>
<a id="ab091294cccdb99cde1e29c4192441baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab091294cccdb99cde1e29c4192441baa">&#9670;&nbsp;</a></span>to_euclidean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;wrappable Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) OpenKalman::to_euclidean </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>A matrix or tensor. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="to__euclidean_8hpp_source.html#l00031">31</a> of file <a class="el" href="to__euclidean_8hpp_source.html">to_euclidean.hpp</a>.</p>

</div>
</div>
<a id="a6b649f52fb62a29f355e2d70dd85fbab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b649f52fb62a29f355e2d70dd85fbab">&#9670;&nbsp;</a></span>to_euclidean_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> auto OpenKalman::to_euclidean_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const auto &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>euclidean_local_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>An element getter mapping an index i of type std::size_t to an element of <a class="el" href="namespaceOpenKalman.html#aae7f9880c66287c68d382f6a1352d069">scalar_type</a> (e.g., <code>std::function&lt;double(std::size_t)</code>) </td></tr>
    <tr><td class="paramname">euclidean_local_index</td><td>A local index accessing the coordinate in Euclidean space </td></tr>
    <tr><td class="paramname">start</td><td>The starting location of the angle within any larger set of <a class="el" href="namespaceOpenKalman.html#a6aa798b43668ea60705a78485a84a200">vector_space_descriptor</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="to__euclidean__element_8hpp_source.html#l00033">33</a> of file <a class="el" href="to__euclidean__element_8hpp_source.html">to_euclidean_element.hpp</a>.</p>

</div>
</div>
<a id="a1ccae583b05933bcbc9afff632b7be5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccae583b05933bcbc9afff632b7be5f">&#9670;&nbsp;</a></span>to_native_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible LibraryObject, indexible Arg&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) OpenKalman::to_native_matrix </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The new object will be one that is fully treated as native by the library associated with LibraryObject and that can be an input in any <a class="el" href="namespaceOpenKalman.html" title="The root namespace for OpenKalman.">OpenKalman</a> function associated with library LibraryObject. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">LibraryObject</td><td>Any indexible object from the library to which Arg is to be converted. It's shape or scalar type are irrelevant. </td></tr>
    <tr><td class="paramname">Arg</td><td>The argument </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="to__native__matrix_8hpp_source.html#l00031">31</a> of file <a class="el" href="to__native__matrix_8hpp_source.html">to_native_matrix.hpp</a>.</p>

</div>
</div>
<a id="a5c9ef446cddf13d347c406964c3bd6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9ef446cddf13d347c406964c3bd6ab">&#9670;&nbsp;</a></span>ToEuclideanExpr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;indexible Arg, vector_space_descriptor C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires (not <a class="el" href="namespaceOpenKalman.html#a8790c861060ce4dfc9868d45a10d73c4">from_euclidean_expr</a>&lt;NestedMatrix&gt;) struct ToEuclideanExpr OpenKalman::ToEuclideanExpr </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  ToEuclideanExpr&lt; C, passable_t&lt; Arg &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a1397f4d7afcc945903cb94f2058064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1397f4d7afcc945903cb94f2058064">&#9670;&nbsp;</a></span>vector_space_descriptors_match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;interface::count_indices_defined_for... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool OpenKalman::vector_space_descriptors_match </td>
          <td>(</td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>A set of tensors or matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceOpenKalman.html#af06c81bf543e750616dc3cb2115885d8" title="Specifies that a set of indexible objects have equivalent vector space descriptors for each index.">vector_space_descriptors_match_with</a> </dd>
<dd>
<a class="el" href="namespaceOpenKalman.html#a71866768ca1d2b98352a34f58eac26a4" title="Specifies that indexible objects Ts may have equivalent dimensions and vector-space types.">vector_space_descriptors_may_match_with</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vector__space__descriptors__match_8hpp_source.html#l00062">62</a> of file <a class="el" href="vector__space__descriptors__match_8hpp_source.html">vector_space_descriptors_match.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceOpenKalman.html">OpenKalman</a></li>
    <li class="footer">Generated on Sun Oct 20 2024 14:03:36 for OpenKalman by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
